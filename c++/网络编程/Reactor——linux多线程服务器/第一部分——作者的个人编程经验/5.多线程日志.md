## 一、常规日志库功能

- 日志消息有多种级别，如trace、debug、info、warn、error、fatal等
- 日志消息可能有多个目的地，如文件、socket、smtp等
- 日志消息格式可配置
- 可设置运行时过滤器，控制不同组件日志消息级别和目的地

作者认为除了第一项，其他都是非必须功能。日志的输出级别在运行时可调，这样同一个可执行文件可以分别在不同环境中输出不同级别日志，不需要重新编译、重启进程等。muduo调用muduo::Logger::setLogLevel生效。

### 1.日志滚动

对于分布式系统来说，日志目的地只有本地文件，日志的功能之一就是诊断网络故障。以本地文件为日志目的地，那么日志的滚动是必须的，可以简化日志归档的实现。日志滚动条件通常有两个：

- 文件大小
- 时间

muduo日志库的LogFile会自动根据文件大小和时间主题滚动日志文件。

典型的日志文件名：

logfile_test.2012060-144022.hostname.3605.log

主要由以下几个部分组成：

- logfile是进程名字，必要时可以加入程序版本
- 文件创建时间（GMT时区）
- 机器名称
- 进程id，同一程序反复重启，每次生成不同
- 统一后缀名 .log

muduo的日志文件滚动没有采用文件改名的方法，即dmesg.log是最新日志，按序号追溯。

- 日志文件压缩与归档不是日志库应有的功能，应该交给专门的脚本完成，这样不同服务程序可以共享同一基础设施。
- 磁盘监控也不是日志库必备功能，对于死循环写日志情况，开始几条日志最重要，磁盘清理会消除信息。

### 2.日志写入

往文件写日志常见问题是，若程序崩溃，最后几条日志丢失，因为日志库不是每条消息都flush硬盘。muduo日志库解决方法是：

- 定期（默认3s）将缓冲区的日志消息flush到硬盘；
- 每条内存中的日志消息都带有cookie（哨兵值），其值为某个函数地址，通过coredump文件中查找cookie能找到尚未写入磁盘的消息。

### 3.日志格式

日志格式固定最好，修改格式就重新编译代码。日志消息格式几个要点：

- 尽量每条日志占一行。方便文本分析命令进行分析。
- 时间戳精确到微秒。
- 始终使用GMT失去
- 打印线程id，方便分析多线程程序的时序，检测死锁。
- 打印日志级别
- 打印源文件名称和行号

避免在日志中出现正则表达式的元字符。

日志过滤器是有用的，可以放到编译期而不是运行时。同一个程序同时写多个日志文件是少见的，可以给后续的log归档来分流。

## 二、性能需求

- 每秒写几千上万条日志时没有明显性能损失
- 能应对一个进程产生大量日志数据的场景，如1G/min
- 不阻塞正常的执行流程
- 多线程中，不造成争用

作者列举的性能指标，往普通的7200rpm SATA硬盘写日志：

- 磁盘带宽约110MB/s，日志库应该能瞬间写满这个带宽
- 假如每条消息平均长度是110字节，即1s要写入100w条日志。

以上是高性能的日志库最低指标。如果磁盘带宽更高，其性能指标也要提高。

muduo的日志库实现优化措施：

- 时间戳字符串找到日志和时间两部分是缓冲的，一秒内的多条日志只需重新格式化微妙部分。
- 日志消息的前4个字段是定长的，可以避免中运行时求字符串长度。
- 线程id是预先格式化的字符串，输出在日志消息时只需要简单拷贝几个字节。
- 每行日志消息的源文件名部分采用编译器计算获得basename，避免运行期开销。

## 三、多线程异步日志

多线程程序要求日志库线程安全，两个线程的日志消息不会交织。作者认为一个多线程程序的每个进程写一个日志文件，便于分析。用一个背景线程收集日志消息，并写入日志文件，其他线程只发送消息到这个日志线程，称为异步日志。

多线程中，异步日志是必须的，在网络IO或者业务线程中写日志，可能造成阻塞，导致请求方超时或者耽误心跳包发送。在正常业务中应该彻底避免磁盘IO，这是使用one loop per thread模型的重要要求。

muduo采用的是双缓冲技术，基本思路是准备两个buffer，前端负责往bufferA填数据，后端负责buffer B的数据写入文件。当buffer A写满后，交换A、B，让后端写如buffer A的数据，前端填入buffer B消息，如此循环。两个buffer 好处是在新建日志消息时不等待磁盘文件操作，避免每条新日志都触发后端日志线程，降低开销。为了及时写入，日志库每3s会执行上述交换写入操作。

实际实现采用了四个缓冲区，进一步避免或减少日志前端等待。



