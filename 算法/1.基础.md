# 基础

## 一、评估算法优劣的核心指标

- 时间复杂度（流程决定）
- 额外空间复杂度（流程决定）
- 常数项时间（细节决定）

### 1.常数时间的操作，一个操作的执行时间不以具体样本量为转移，每次执行时间都固定。

例如，选择排序：

第一次：N*（获取+比较）+ 交换

第二次：（N-1）*（获取+比较）+ 交换

...

=》常数操作看为1：

= 2*{N+(N-1)+(N-2)+...}+N

= aN^2+bN+c

### 2.如何确定算法流程的总操作数量与样本数量间的表达式关系

- 想象该算法流程处理数据状况，按最差情况来
- 把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作
- 如果数据量是N，看看级别动作的数量与N是声明关系

### 3.如何确定算法流程的时间复杂度

当完成表达式的建立，只需要留下最高阶项，其他去掉，高阶系数也去掉，记为O。时间复杂度的意义就是衡量一个算法流程的复杂程度指标，只与数据量有关。

### 4.额外空间复杂度

与功能无关，用来支持流程而开辟的空间。作为输入/输出的空间，不算额外空间。

- 固定空间的——O（1）
- 需要开辟一个数组——O（n）

## 二、对数器

- 你想要测试的方法a
- 实现复杂度不好但是容易实现的方法b
- 实现一个随机样本产生器
- 把方法a和方法b跑相同的随机样本，看结果是否一致
- 如果一个随机样本使得比对结果不一致，打印样本进行修改
- 多次测试确定方法a正确

# 算法思想

## 一、二分法

常见的二分法是基于有序数组进行二分查找。正确的排除条件，就可以二分，不一定需要有序条件。

因为每次查找会将数据减半，每次操作后剩余数据量是1/（2^N)，即log2（N），可以写为logN。

常见问题：

- 有序数组中找某个数是否存在
- 有序数组中找>=某个数最左侧的位置
- 有序数组中找<=某个数最右侧的位置
- 局部最小值问题:位置1的数比位置0的数小，位置1的数就是局部最小；位置N的数比位置N-1的数小，位置N的数就是局部最小；位置i的数小于位置 i + 1的数，且小于位置i-1位置的数，位置i的数局部最小。

**PS**：

- （L+R）/ 2 这种写法有整数溢出的风险，以 L + （R-L）/ 2 的方式更好，再进化为位运算：L + （R-L）>> 1(右移一位，表示除2；乘2即左移一位)

- N * 2 + 1 转化为位运算就是 （（N  << 1) | 1) 

局部最小场景怎么二分？

条件：arr[0...N-1] 无序 相邻不等

- 先看0位置的数与1 位置的数大小，如果0 位置是局部最小，那么直接返回；否则可以断定，位置0往右走势是向下；
- 再看N-1 位置是否局部最小，如果N-1位置 是局部最小，那么直接返回；否则可以断定，位置N-1往左走势是向上。
- 在都不是局部最小的情况下，断定中间有局部最小值。
- 来到中间位置meddle，如果meddle位置数小于它两侧的数，则直接返回；否则，可以断定某一侧有局部最小。
- 这样循环二分，可以找到局部最小。

## 二、异或运算

