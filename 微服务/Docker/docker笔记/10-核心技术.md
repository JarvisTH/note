##一、基本架构
采用了标准的C/S架构，包括客户端、服务端两大核心组件，同时通过镜像仓库来存储镜像。客户端和服务端既可以运行在一个机器上，也可通过 socket 或者 RESTful API 来进行通信。

**1.服务端**
Docker 服务端一般在宿主主机后台运行， dockerd 作为服务端接受来自客户 的请求，并通过 containerd 具体处理与容器相关的请求，包括 建、运行 删除容器等。服务端主要包括四个组件：
- dockerd:：为客户端提供阻ST API ，响应 自客户端的请求 块化的架构，通过专门的 Engine 模块来分发管理各个来自客户端的任务 可以单独升级；
- docker-proxy：dockerd 的子进程，当需要进行容器端口映射时 docker-proxy 完成网络映射配置；
- containerd：dockerd子进程，提供gRPC 接口响应来自 dockerd 的请求，对下管理 runC镜像和容器环境。可以单独升级；
- containerd-shim：containerd 的子进程，为 runC容器提供支持，同时作为容器内进程的根进程。

dockerd 默认监听本地的 unix :///var/run/docker.sock 套接字，只允许本地的 root 用户或docker 用户组成员访问。可以通过－H选项来修改监昕的方式。

docker-proxy 只有当启动容器且使用端口映射时候才会执行，负责配置容器的端口映射规则。

**2.客户端**
用户使用的 Docker 可执行命令即为客户端程序,客户端发送命令后，等待服务端返回；一旦收到返回后，客户端立刻执行结束并退出。
客户端默认通过本地的 unix :///var/run/docker.sock 套接字向服务端发送命令 如果服务端没有监昕在默认的地址，则需要客户端在执行命令的时候显式地指定服务端地址。假定服务端监听在本地的 TCP 连接 1234 端口为 tcp://127.0.0.1: 1234 ，只有通过－H参数指定
了正确的地址信息才能连接到服务端：
```
docker -H tcp://127.0.0.1:1234 info
```
##二、命名空间
每个容器都可以拥有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统环境中一样。命名空间机制保证了容器之间彼此互不影响。
Docker 容器每次启动时候，通过调用func func setNamespaces(daemon *Daemon, s *specs. 
Spec, c *container.Container) error 方法来完成对各个命名空间的配置。
**1.进程命名空间**
Linux 通过进程命名管理进程号，对于同一进程（同 task struct ），在不同的命名空间中，看到的进程号不相同。进程命名名空间是一个父子关系的结构，子空间中的进程对于父空间是可见的。
新建一个 Ubuntu 容器，此时 docker containerd 进程作为父进程，为每个容器启动一个 docker-containerd-shim进程，作为该容器内所有进程的根进程。从宿主机上查看新建容器的进程的父进程 ，正是 docker-containerd-shim 进程。在容器内的进程空间中，则把 docker-containerd-shim 进程作为 0号根进程。![宿主机与容器内进程空间的关系](https://upload-images.jianshu.io/upload_images/9449419-4779583f9a1949a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**2.IPC命名空间**
容器中的进程交互还是采用了 Linux 常见的进程间交互方法，，包括信号 、消息队列和共 内存等方式PID 命名 间和 IPC 命名空间可以组合起来使用，同一个IPC 命名 间内的进程可以彼此可见，允许进行交互；不同空间的进程则无法交互。

**3.网络命名空间**
有了进程命名空间后，网络端口共享本地系统的端口。通过网络命名空间，可以实现网络隔离。一个网
络命名空间为进程提供了一个完全独立的网络协议栈的视图，包括网络设备接口、IPv4、IPv6 协议栈、IP路由表、 防火墙规则、sockets 等， 这样每个容器的网络就能隔离开来。
Docker 采用虚拟网络设备的方式，将不同命名空间的网络设备连接到一起。默认情况下， Docker 在宿 机上创建多个虚机网桥（如默认的网桥 docker0） ，容器中的虚拟网卡通过网桥进行连接。![Docker 将不同命名空间的网络
设备连接起来](https://upload-images.jianshu.io/upload_images/9449419-cdbc485a6684fbc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
使用docker network ls命令可以查看当前系统网桥。使用 brctl 工具（需要 bridge-utils 工具包 ，还可以看到连接到网桥的虚拟网口的
信息。每个容器默认分配一个网桥上的虚拟网口， 并将 docker0的IP 地址设为默认的网关，容器发起的网络流量通过宿主机的 iptables 规则进行转发。
```
brctl show
```
**4.挂载命名空间**
挂载（Mount MNT ）命名空间可以将一个进程的根文件系统限制到
一个特定的目录下。挂载命名空间允许不同命名空间的进程看到的本地文件位于宿主机中不同路径下，每个命名空间中的进程所看到的文件目录彼此是隔离的。

**5.UTS命名空间**
UTS (UNIX Time-sharing System）命名空间允许每个容器拥有独立的主机名和域名，从而可以虚拟出一个有独立主机名和网络空间的环境，就跟网络上一台独立的主机一样。如果没有手动指定主机名称，Docker容器的主机名就是返回的容器 ID 的前6字节前缀，否则为指定用户名
```
docker run --hostname test2 --name test1 -d ubuntu:18.04 /bin/bash 
docker inspect -f {{".config.Hostname"}} test1
```
**6.用户命名空间**
每个容器可以有不同的用户和组id。每个容器内部都可以有最高权限的 root 帐号，但跟宿主主机不在一个命名空间。

##三、控制组
控制组（ CGroups ），主要用来对共享资源进行隔离、限制、审计等。只有将分配到容器的资源进行控制，才能避免多个容器同时运行时对宿主机系统的资源竞争。每个控制组是一组对资源的限制，支持层级化结构。
- 资源限制：：可将组设置一定的内存限制。
- 优先级
- 资源审计：：用来统计系统实际上把多少资源用到适合的目的上，可以使用cpuacct 子系统记录某个进程组使用的 CPU 时间。
- 隔离：为组隔离命名空间，这样使得一个组不会看到另一个组的进程、网络连接和文件系统。
- 控制：执行挂起 恢复和重启动等操作。

用户可以在/sys/fs/cgroup/memory docker/目录下看到对 Docker 组应用的各种限制项，包括全局限制和位于子目录中对于某个容器的单独限制。用户可以通过修改这些文件值来控制组，从而限制 Docker应用资源。进人对应容器文件夹，可看到对应容器的限制和当前的使用状态。

##四、联合文件系统
