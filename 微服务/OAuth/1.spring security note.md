# 1.spring security 基础

## 一、前端环境准备

node.js安装目的是使用npm管理项目依赖的软件包，cnpm作为替代的包管理工具。使用Vue CLI无须关注复杂配置。

```
node -v
npm -v
npm install -g cnpm --registry=https://registry.npm.taobao.org
cnpm -v
```

## 二、后端环境

- jdk11 ：https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/
- maven
- IDEA:插件
  - envfile：环境变量加载
  - Lombok
  - http client
  - 热启动配置：setting-compiler-build project automatically。IDEA的注册表修改：双击shift，搜索registry action，进入注册表，勾选app running。

## 三.认证与授权

认证解决“我是谁”的问题。

授权解决“我能做什么”的问题。

对于简单的应用，只需要做认证就ok了。但对于需要区别用户的应用，需要做授权。



## 四、Spring Filter&Filter Chains

任何Spring web应用本质上是一个servlet，security filter在http请求到达controller之前过滤每个传入的http请求。

<img src="../../../../picbed/store/picbed/img/image-20220608000335991.png" alt="image-20220608000335991" style="zoom:67%;" />

filter chain：

![image-20220309231547638](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20220309231547638.png)

### 1.常见内建过滤器

![image-20220608000948901](../../../../picbed/store/picbed/img/image-20220608000948901.png)

## 五、HTTP请求结构

![image-20220608212035110](../../../../picbed/store/picbed/img/image-20220608212035110.png)

认证头Authorization：Basic user passwd

Content-Type：数据格式描述

## 六、HTTP响应

![image-20220608214142221](../../../../picbed/store/picbed/img/image-20220608214142221.png)

HTTP Basic Auth认证流程：

![image-20220608215311208](../../../../picbed/store/picbed/img/image-20220608215311208.png)

## 七、配置Spring Security

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests(req -> req.antMatchers("/api/**").authenticated())
                .formLogin(form -> form.disable())
                .httpBasic(Customizer.withDefaults())
                .csrf(csrf -> csrf.disable());
    }
}

@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests(req -> req.antMatchers("/api/**").authenticated())
                .formLogin(AbstractHttpConfigurer::disable)
                .httpBasic(Customizer.withDefaults())
                .csrf(AbstractHttpConfigurer::disable);
    }
}

// 传统写法
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers("/api/**").hasRole("USER")
                .anyRequest().authenticated()
                .and()
                .formLogin().loginPage("/login").usernameParameter("username1").and()
                .httpBasic().realmName("BA");
    }
}
```

一般security配置继承WebSecurityConfigurerAdapter，详细配置重写方法configure。

@EnableWebSecurity注解有属性debug，默认关闭。开启后，会打印相应日志。

```java
	@Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().mvcMatchers("/public/**");
    }
```

一般情况下，configure(WebSecurity web)可以配置忽略某些静态资源、获取采用静态资源路径，configure(HttpSecurity http)配置路径的安全性。

## 八、定制登录页

### 1.添加依赖

```
		<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <dependency>
            <groupId>org.webjars</groupId>
            <artifactId>bootstrap</artifactId>
            <version>4.5.0</version>
        </dependency>
        <dependency>
            <groupId>org.webjars</groupId>
            <artifactId>webjars-locator-core</artifactId>
        </dependency>
```

非前后端分离，使用前端模板。当然也可以实现前后端分离，这里只是quick look。

### 2.资源配置

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/webjars/**")
                .addResourceLocations("/webjars/")
                .resourceChain(false);
        registry.setOrder(1);
    }

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/login").setViewName("login");
        registry.setOrder(1);
    }
}
```

### 3.登录页面、认证、跨域、登出配置

#### 1.CSRF 攻击

![image-20220612224053595](../../../../picbed/store/picbed/img/image-20220612224053595.png)

- 解决方法一

![image-20220612224306942](../../../../picbed/store/picbed/img/image-20220612224306942.png)

- 解决方法二：IE浏览器不完全支持

![image-20220612224611607](../../../../picbed/store/picbed/img/image-20220612224611607.png)

#### 2.Remember-me功能

解决session过期后用户的直接访问。spring security提供开箱即用的配置rememberMe。原理是使用cookie存储用户名，过期时间，以及一个hash。hash ：md5（用户名+过期时间+密码+key）

![image-20220612225613911](../../../../picbed/store/picbed/img/image-20220612225613911.png)

#### 3.logout功能

![image-20220612225540531](../../../../picbed/store/picbed/img/image-20220612225540531.png)

### 4.定制登录/登出的处理

- spring security提供登录成功后的处理：AuthenticationSuccessHandler

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().mvcMatchers("/public/**")
                .requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests(req -> req.antMatchers("/api/**").authenticated())
                .formLogin(form -> form.loginPage("/login")
                        .successHandler((req, res, auth) -> {
                            res.setStatus(HttpStatus.OK.value());
                            res.getWriter().println();
                        }))
                .httpBasic(Customizer.withDefaults())
                .csrf(AbstractHttpConfigurer::disable);
    }
}
```

使用IDEA函数提取功能：

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().mvcMatchers("/public/**")
                .requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests(req -> req.antMatchers("/api/**").authenticated())
                .formLogin(form -> form.loginPage("/login")
                        .successHandler(getAuthenticationSuccessHandler()))
                .httpBasic(Customizer.withDefaults())
                .csrf(AbstractHttpConfigurer::disable);
    }

    private AuthenticationSuccessHandler getAuthenticationSuccessHandler() {
        return (req, res, auth) -> {
            res.setStatus(HttpStatus.OK.value());
            res.getWriter().println(objectMapper.writeValueAsString(auth));
        };
    }
}
```

- spring security提供登录失败后的处理：AuthenticationFailureHandler

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().mvcMatchers("/public/**")
                .requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests(req -> req.antMatchers("/api/**").authenticated())
                .formLogin(form -> form.loginPage("/login")
                        .successHandler(getAuthenticationSuccessHandler())
                        .failureHandler(getAuthenticationFailureHandler()))
                .httpBasic(Customizer.withDefaults())
                .csrf(AbstractHttpConfigurer::disable);
    }

    private AuthenticationFailureHandler getAuthenticationFailureHandler() {
        return (req, res, exp) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.UNAUTHORIZED.value());
            res.setContentType(MediaType.APPLICATION_JSON_VALUE);
            res.setCharacterEncoding("UTF-8");
            val errData = Map.of(
                    "title", "认证失败",
                    "details", exp.getMessage()
            );
            res.getWriter().println(objectMapper.writeValueAsString(errData));
        };
    }

    private AuthenticationSuccessHandler getAuthenticationSuccessHandler() {
        return (req, res, auth) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.OK.value());
            res.getWriter().println(objectMapper.writeValueAsString(auth));
        };
    }
}
```

- spring security提供登出成功后的处理：LogoutSuccessHandler

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().mvcMatchers("/public/**")
                .requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests(req -> req.antMatchers("/api/**").authenticated())
                .formLogin(form -> form.loginPage("/login")
                        .successHandler(getAuthenticationSuccessHandler())
                        .failureHandler(getAuthenticationFailureHandler()))
                .httpBasic(Customizer.withDefaults())
                .csrf(AbstractHttpConfigurer::disable)
                .logout(logout -> logout.logoutUrl("/perform_logout")
                        .logoutSuccessHandler((req, res, auth) -> {
                            // 定制内容
                        }));
    }

    private AuthenticationFailureHandler getAuthenticationFailureHandler() {
        return (req, res, exp) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.UNAUTHORIZED.value());
            res.setContentType(MediaType.APPLICATION_JSON_VALUE);
            res.setCharacterEncoding("UTF-8");
            val errData = Map.of(
                    "title", "认证失败",
                    "details", exp.getMessage()
            );
            res.getWriter().println(objectMapper.writeValueAsString(errData));
        };
    }

    private AuthenticationSuccessHandler getAuthenticationSuccessHandler() {
        return (req, res, auth) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.OK.value());
            res.getWriter().println(objectMapper.writeValueAsString(auth));
        };
    }
}
```

## 九、自定义Filter

表单登录——UsernamePasswordAuthenticationFilter：默认处理表单登录filter，仿照写的自定义filter如下:

```java
@RequiredArgsConstructor
public class RestAuthenticationFilter extends UsernamePasswordAuthenticationFilter {
    private final ObjectMapper objectMapper;

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        UsernamePasswordAuthenticationToken authRequest;

        try {
            InputStream is = request.getInputStream();
            val jsonNode = objectMapper.readTree(is);
            String username = jsonNode.get("username").textValue();
            String password = jsonNode.get("password").textValue();
            authRequest = new UsernamePasswordAuthenticationToken(username, password);
        } catch (IOException e) {
            e.printStackTrace();
            throw new BadCredentialsException("没有找到用户名或密码");
        }
        setDetails(request, authRequest);
        return this.getAuthenticationManager().authenticate(authRequest);
    }
}
```

怎么把自定义的登录认证filter加入到配置链中呢？

![image-20220619150928096](../../../../picbed/store/picbed/img/image-20220619150928096.png)

可以使用配置链条中的addfilter方法，有多种实现，根据需要选择。修改后的认证代码如下：

```java
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    private final ObjectMapper objectMapper;

    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().mvcMatchers("/public/**")
                .requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests(req -> req
                        .antMatchers("/authorize/**").permitAll()
                        .antMatchers("/admin/**").hasRole("ADMIN")
                        .antMatchers("/api/**").hasRole("USER")
                        .anyRequest().authenticated())
                .addFilterAt(restAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
                .csrf(AbstractHttpConfigurer::disable);
    }

    private RestAuthenticationFilter restAuthenticationFilter() throws Exception{
        RestAuthenticationFilter filter = new RestAuthenticationFilter(objectMapper);
        filter.setAuthenticationSuccessHandler(getAuthenticationSuccessHandler());
        filter.setAuthenticationFailureHandler(getAuthenticationFailureHandler());
        filter.setAuthenticationManager(authenticationManager());
        filter.setFilterProcessesUrl("/authorize/login");
        return filter;
    }

    private AuthenticationFailureHandler getAuthenticationFailureHandler() {
        return (req, res, exp) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.UNAUTHORIZED.value());
            res.setContentType(MediaType.APPLICATION_JSON_VALUE);
            res.setCharacterEncoding("UTF-8");
            val errData = Map.of(
                    "title", "认证失败",
                    "details", exp.getMessage()
            );
            res.getWriter().println(objectMapper.writeValueAsString(errData));
        };
    }

    private AuthenticationSuccessHandler getAuthenticationSuccessHandler() {
        return (req, res, auth) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.OK.value());
            res.getWriter().println(objectMapper.writeValueAsString(auth));
        };
    }
}
```

# 2.密码

## 一、密码存储

明文：明文简单。攻击方式也简单。

哈希：用密码做不可逆哈希，攻击方式就是预制哈希密码采样库，用密码哈希值与库中的哈希字符串做匹配。

加盐：不完全依赖密码，每次做哈希时，随机生成盐值，取盐值和密码做哈希。

自适应：自适应哈希函数，可以配置迭代次数（md5（md5（“text”））；可以配置随机的盐值；迭代次数与盐值存储于数据库；Bcrypt、scrypt、pdkdf2等。

## 二、 密码编码

```java
	@Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("user")
                .password(passwordEncoder().encode("123456"))
                .roles("USER", "ADMIN");
    }

	@Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
```

随着密码加密技术不断发展，以后可能存在更好的加密方式，如果加密方式不能被替换，导致以后 密码不安全，spring 提供了**多种编码器共存**的方式解决。DelegatingPasswordEncoder允许以不同格式验证密码，提供升级可能性。存储时，会加上算法标识。

```java
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    private final ObjectMapper objectMapper;

    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().mvcMatchers("/public/**")
                .requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests(req -> req
                        .antMatchers("/authorize/**").permitAll()
                        .antMatchers("/admin/**").hasRole("ADMIN")
                        .antMatchers("/api/**").hasRole("USER")
                        .anyRequest().authenticated())
                .addFilterAt(restAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
                .csrf(AbstractHttpConfigurer::disable)
                .formLogin(form -> form.loginPage("/login")         // 既保留rest登录也保留表单登录
                        .usernameParameter("username1")
                        .defaultSuccessUrl("/")
                        .successHandler(getAuthenticationSuccessHandler())
                        .failureHandler(getAuthenticationFailureHandler())
                        .permitAll())
                .logout(logout -> logout.logoutUrl("/perform_logout")
                        .logoutSuccessHandler((req, res, auth) -> {
                            System.out.println();
                        }))
                .rememberMe(rememberMe -> rememberMe.tokenValiditySeconds(60));
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("user")
                .password(passwordEncoder().encode("123456"))
                .roles("USER", "ADMIN");
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        val idForDefault = "bcrypt";
        val encoders = Map.of(
                idForDefault, new BCryptPasswordEncoder(),
                "SHA-1", new MessageDigestPasswordEncoder("SHA-1")
        );
        return new DelegatingPasswordEncoder(idForDefault, encoders);
    }

    private RestAuthenticationFilter restAuthenticationFilter() throws Exception{
        RestAuthenticationFilter filter = new RestAuthenticationFilter(objectMapper);
        filter.setAuthenticationSuccessHandler(getAuthenticationSuccessHandler());
        filter.setAuthenticationFailureHandler(getAuthenticationFailureHandler());
        filter.setAuthenticationManager(authenticationManager());
        filter.setFilterProcessesUrl("/authorize/login");
        return filter;
    }

    private AuthenticationFailureHandler getAuthenticationFailureHandler() {
        return (req, res, exp) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.UNAUTHORIZED.value());
            res.setContentType(MediaType.APPLICATION_JSON_VALUE);
            res.setCharacterEncoding("UTF-8");
            val errData = Map.of(
                    "title", "认证失败",
                    "details", exp.getMessage()
            );
            res.getWriter().println(objectMapper.writeValueAsString(errData));
        };
    }

    private AuthenticationSuccessHandler getAuthenticationSuccessHandler() {
        return (req, res, auth) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.OK.value());
            res.getWriter().println(objectMapper.writeValueAsString(auth));
        };
    }
}
```

DelegatingPasswordEncoder以 {id}encoderPassword 形式存储，密码匹配：encoder.matches(CharSequence, String)。CharSequence是明文密码，String数据库中的hash后的字符串，传入做匹配。

**密码升级**：实现UserDetailsPasswordService中updatePassword。大致逻辑就是以旧方式登录成功后，将明文密码使用新的方式加密，存入数据库。

## 三、JSR 380认证框架

提供一系列的注解，利用注解进行字段的验证，可以用到集合中的元素。

### 1.添加依赖

```xml
	   <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
```

### 2.常用注解

![image-20220619161115424](../../../../picbed/store/picbed/img/image-20220619161115424.png)

![image-20220619161157221](../../../../picbed/store/picbed/img/image-20220619161157221.png)

### 3.使用示例

- 添加领域对象

```java
@Data
public class User implements Serializable {
    private String username;
    private String password;
    private String email;
    private String name;
}
```

- 添加dto对象：dto对象主要用于外部对象与内部对象隔离

```java
@Data
public class UserDto implements Serializable {
    @NonNull
    @NotBlank
    @Size(min = 4, max = 50, message = "用户名长度信息 4-50 字符之间")
    private String username;
    @NonNull
    @NotBlank
    @Size(min = 8, max = 20, message = "密码长度信息 8-20 字符之间")
    private String password;
    @NonNull
    @NotBlank
    @Size(min = 8, max = 20, message = "密码长度信息 8-20 字符之间")
    private String matchPassword;
    @Email     //@Pattern(regexp = "xxxx")  自定义邮箱格式
    @NotNull
    private String email;
    @NonNull
    @NotBlank
    @Size(min = 8, max = 20, message = "姓名长度信息 8-20 字符之间")
    private String name;
}
```

- 添加controller

```java
@RequestMapping("/authorize")
@RestController
public class AuthorizeResource {

    @PostMapping("register")
    public UserDto register(@Valid @RequestBody UserDto userDto) {
        return userDto;
    }
}
```

### 4.自定义注解

- 创建注解

```java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = EmailValidator.class)
@Documented
public @interface ValidEmail {
    String message() default "Invalid email";
    
    // 属性
    Class<?>[] groups() default {};

    // 属性
    Class<? extends Payload>[] payload() default {};
}
```

- 实现注解逻辑

```java
public class EmailValidator implements ConstraintValidator<ValidEmail, String> {
    private final static String EMAIL_PATTERN = "xxxxx";

    @Override
    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
        return validateEmail(s);
    }

    @Override
    public void initialize(ValidEmail constraintAnnotation) {}

    private boolean validateEmail(final String email) {
        val pattern = Pattern.compile(EMAIL_PATTERN);
        val matcher = pattern.matcher(email);
        return matcher.matches();
    }
}
```

- 使用自定义注解

```java
@Data
public class UserDto implements Serializable {
    @NonNull
    @NotBlank
    @Size(min = 4, max = 50, message = "用户名长度信息 4-50 字符之间")
    private String username;
    @NonNull
    @NotBlank
    @Size(min = 8, max = 20, message = "密码长度信息 8-20 字符之间")
    private String password;
    @NonNull
    @NotBlank
    @Size(min = 8, max = 20, message = "密码长度信息 8-20 字符之间")
    private String matchPassword;
    @ValidEmail			// 自定义注解
    @NotNull
    private String email;
    @NonNull
    @NotBlank
    @Size(min = 8, max = 20, message = "姓名长度信息 8-20 字符之间")
    private String name;
}
```



## 四、密码验证规则

密码验证比较复杂，使用Passay框架进行验证。**封装验证逻辑在注解中，有效剥离验证逻辑和业务逻辑**。

对于2个以上属性的**复合验证**，可以写一个应用于类的注解。

### 1.密码验证注解

#### 1.添加依赖

```xml
		   <dependency>
                <groupId>org.passay</groupId>
                <artifactId>passay</artifactId>
                <version>1.6.1</version>
            </dependency>
```

#### 2.创建注解

```java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PasswordConstraintValidator.class)
@Documented
public @interface ValidPassword {
    String message() default "Invalid email";

    // 属性
    Class<?>[] groups() default {};

    // 属性
    Class<? extends Payload>[] payload() default {};
}
```

#### 3.实现注解逻辑

```java
public class PasswordConstraintValidator implements ConstraintValidator<ValidPassword, String> {
    @Override
    public boolean isValid(String password, ConstraintValidatorContext constraintValidatorContext) {
        val validator = new PasswordValidator(Arrays.asList(
                new LengthRule(8, 30),
                new CharacterRule(EnglishCharacterData.UpperCase,1),
                new CharacterRule(EnglishCharacterData.LowerCase,1),
                new CharacterRule(EnglishCharacterData.Special,1),
                new IllegalSequenceRule(EnglishSequenceData.Alphabetical,5,false), //不允许5个连续字符
                new IllegalSequenceRule(EnglishSequenceData.Numerical,5,false), // 不允许5个数字
                new IllegalSequenceRule(EnglishSequenceData.USQwerty,5,false),  // 不允许键盘上5个连续字符 例如qwert
                new WhitespaceRule()    // 空格
        ));
        val result = validator.validate(new PasswordData(password));
        return result.isValid();
    }

    @Override
    public void initialize(ValidPassword constraintAnnotation) {}
}
```

#### 4.使用注解

```java
@Data
public class UserDto implements Serializable {
    @NonNull
    @NotBlank
    @Size(min = 4, max = 50, message = "用户名长度信息 4-50 字符之间")
    private String username;
    @NonNull
    @ValidPassword			// 自定义密码验证注解
    private String password;
    @NonNull
    @ValidPassword			// 自定义密码验证注解
    private String matchPassword;
    @ValidEmail
    @NotNull
    private String email;
    @NonNull
    @NotBlank
    @Size(min = 8, max = 20, message = "姓名长度信息 8-20 字符之间")
    private String name;
}
```

### 2.复合验证

#### 1.创建注解

```java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PasswordMatchValidator.class)
@Documented
public @interface PasswordMatch {
    String message() default "Invalid password";

    // 属性
    Class<?>[] groups() default {};

    // 属性
    Class<? extends Payload>[] payload() default {};
}
```

#### 2.实现注解逻辑

```java
public class PasswordMatchValidator implements ConstraintValidator<PasswordMatch, UserDto> {
    @Override
    public boolean isValid(UserDto userDto, ConstraintValidatorContext constraintValidatorContext) {
        return userDto.getMatchPassword().equals(userDto.getMatchPassword());
    }

    @Override
    public void initialize(PasswordMatch constraintAnnotation) {}
}
```

#### 3.使用注解

```java
@Data
@PasswordMatch		// 自定义复合验证注解
public class UserDto implements Serializable {
    @NonNull
    @NotBlank
    @Size(min = 4, max = 50, message = "用户名长度信息 4-50 字符之间")
    private String username;
    @NonNull
    @ValidPassword
    private String password;
    @NonNull
    private String matchPassword;
    @ValidEmail
    @NotNull
    private String email;
    @NonNull
    @NotBlank
    @Size(min = 8, max = 20, message = "姓名长度信息 8-20 字符之间")
    private String name;
}
```

注意复合验证注解，使用在类上。

### 五、Passay异常的国际化

#### 1.创建消息解析器

```java
@RequiredArgsConstructor
public class PasswordConstraintValidator implements ConstraintValidator<ValidPassword, String> {
    private final SpringMessageResolver springMessageResolver;

    @Override
    public boolean isValid(String password, ConstraintValidatorContext constraintValidatorContext) {
        val validator = new PasswordValidator(springMessageResolver, Arrays.asList(
                new LengthRule(8, 30),
                new CharacterRule(EnglishCharacterData.UpperCase, 1),
                new CharacterRule(EnglishCharacterData.LowerCase, 1),
                new CharacterRule(EnglishCharacterData.Special, 1),
                new IllegalSequenceRule(EnglishSequenceData.Alphabetical, 5, false), //不允许5个连续字符
                new IllegalSequenceRule(EnglishSequenceData.Numerical, 5, false), // 不允许5个数字
                new IllegalSequenceRule(EnglishSequenceData.USQwerty, 5, false),  // 不允许键盘上5个连续字符 例如qwert
                new WhitespaceRule()    // 空格
        ));
        val result = validator.validate(new PasswordData(password));
        constraintValidatorContext.disableDefaultConstraintViolation();
        constraintValidatorContext.buildConstraintViolationWithTemplate(String.join(",", validator.getMessages(result)))
                .addConstraintViolation();
        return result.isValid();
    }

    @Override
    public void initialize(ValidPassword constraintAnnotation) {
    }
}
```

#### 2.配置验证器使用消息解析器

```java
@Configuration
@RequiredArgsConstructor
public class WebMvcConfig implements WebMvcConfigurer {

    private final MessageSource messageSource;

    // passay 国际化
    @Bean  
    public MessageResolver messageResolver() {
        return new SpringMessageResolver(messageSource);
    }

    // validation 国际化
    @Bean
    public LocalValidatorFactoryBean localValidatorFactoryBean() {
        LocalValidatorFactoryBean bean = new LocalValidatorFactoryBean();
        bean.setValidationMessageSource(messageSource);
        return bean;
    }

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/webjars/**")
                .addResourceLocations("/webjars/")
                .resourceChain(false);
        registry.setOrder(1);
    }

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/login").setViewName("login");
        registry.setOrder(1);
    }
}
```

#### 3.在对应注解中写消息的键值

- 添加对应的message 资源到 message properties文件中
- 在对应注解中写消息的键值

#### 4.MessageResolver解析



#### 5.SpringMessageResolver解析



#### 6.LocalValidatorFactoryBean解析

# 3.异常的同一处理

### 一、依赖库引入

```xml
<dependency>
    <groupId>org.zalando</groupId>
    <artifactId>problem-spring-web</artifactId>
    <version>0.27.0</version>
</dependency>
```

### 二、ExceptionHandler定义

```java
@ControllerAdvice
public class ExceptionHandler implements ProblemHandling {

    @Override
    public boolean isCausalChainsEnabled() {
        return true;
    }
}
```

```java
public class SecurityExceptionHandler implements SecurityAdviceTrait {
}
```

### 三、异常配置

```java
@EnableWebSecurity
@RequiredArgsConstructor
@Import(SecurityProblemSupport.class)  //import 类， 不是自动注入
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    private final ObjectMapper objectMapper;
    private final SecurityProblemSupport securityProblemSupport;	// 注入依赖

    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().mvcMatchers("/public/**")
                .requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.exceptionHandling(exp -> exp
                        .accessDeniedHandler(securityProblemSupport))	// 配置异常处理
                .authorizeRequests(req -> req
                        .antMatchers("/authorize/**").permitAll()
                        .antMatchers("/admin/**").hasRole("ADMIN")
                        .antMatchers("/api/**").hasRole("USER")
                        .anyRequest().authenticated())
                .addFilterAt(restAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
                .csrf(AbstractHttpConfigurer::disable)
                .formLogin(form -> form.loginPage("/login")         // 既保留rest登录也保留表单登录
                        .usernameParameter("username1")
                        .defaultSuccessUrl("/")
                        .successHandler(getAuthenticationSuccessHandler())
                        .failureHandler(getAuthenticationFailureHandler())
                        .permitAll())
                .logout(logout -> logout.logoutUrl("/perform_logout")
                        .logoutSuccessHandler((req, res, auth) -> {
                            System.out.println();
                        }))
                .rememberMe(rememberMe -> rememberMe.tokenValiditySeconds(60));
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("user")
                .password(passwordEncoder().encode("123456"))
                .roles("USER", "ADMIN");
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        val idForDefault = "bcrypt";
        val encoders = Map.of(
                idForDefault, new BCryptPasswordEncoder(),
                "SHA-1", new MessageDigestPasswordEncoder("SHA-1")
        );
        return new DelegatingPasswordEncoder(idForDefault, encoders);
    }

    private RestAuthenticationFilter restAuthenticationFilter() throws Exception{
        RestAuthenticationFilter filter = new RestAuthenticationFilter(objectMapper);
        filter.setAuthenticationSuccessHandler(getAuthenticationSuccessHandler());
        filter.setAuthenticationFailureHandler(getAuthenticationFailureHandler());
        filter.setAuthenticationManager(authenticationManager());
        filter.setFilterProcessesUrl("/authorize/login");
        return filter;
    }

    private AuthenticationFailureHandler getAuthenticationFailureHandler() {
        return (req, res, exp) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.UNAUTHORIZED.value());
            res.setContentType(MediaType.APPLICATION_JSON_VALUE);
            res.setCharacterEncoding("UTF-8");
            val errData = Map.of(
                    "title", "认证失败",
                    "details", exp.getMessage()
            );
            res.getWriter().println(objectMapper.writeValueAsString(errData));
        };
    }

    private AuthenticationSuccessHandler getAuthenticationSuccessHandler() {
        return (req, res, auth) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.OK.value());
            res.getWriter().println(objectMapper.writeValueAsString(auth));
        };
    }
}
```

处理完成后，返回的结果中的异常结构就比较清晰。

### 四、ProblemHandling解析



### 五、SecurityAdviceTrait解析



### 六、SecurityProblemSupport解析



# 4.多安全配置

可以理解为既想保留Rest api访问，也想保留form login访问。两种访问采用不同的方式与配置。

## 一、表单url配置策略

```java
@Configuration
@Order(100)     // 对于表单登录
public class LoginSecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests(req -> req.anyRequest().authenticated())
                .formLogin(form -> form.loginPage("/login")
                        .usernameParameter("username1")
                        .defaultSuccessUrl("/")
                        .permitAll())
                .logout(logout -> logout.logoutUrl("/perform_logout"))
                .rememberMe(rememberMe -> rememberMe.tokenValiditySeconds(60).rememberMeCookieDomain("xxxx"));
    }

    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().mvcMatchers("/public/**")
                .requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    }
}
```

## 二、rest api访问配置策略

```java
@EnableWebSecurity
@RequiredArgsConstructor
@Import(SecurityProblemSupport.class)
@Order(99)   // 针对rest api 配置
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    private final ObjectMapper objectMapper;
    private final SecurityProblemSupport securityProblemSupport;

    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().mvcMatchers("/public/**");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.requestMatchers(req -> req.mvcMatchers("authorize/**","/admin/**","/api/**"))
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .exceptionHandling(exp -> exp
                        .accessDeniedHandler(securityProblemSupport))
                .authorizeRequests(req -> req
                        .antMatchers("/authorize/**").permitAll()
                        .antMatchers("/admin/**").hasRole("ADMIN")
                        .antMatchers("/api/**").hasRole("USER")
                        .anyRequest().authenticated())
                .addFilterAt(restAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
                .csrf(AbstractHttpConfigurer::disable);
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("user")
                .password(passwordEncoder().encode("123456"))
                .roles("USER", "ADMIN");
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        val idForDefault = "bcrypt";
        val encoders = Map.of(
                idForDefault, new BCryptPasswordEncoder(),
                "SHA-1", new MessageDigestPasswordEncoder("SHA-1")
        );
        return new DelegatingPasswordEncoder(idForDefault, encoders);
    }

    private RestAuthenticationFilter restAuthenticationFilter() throws Exception{
        RestAuthenticationFilter filter = new RestAuthenticationFilter(objectMapper);
        filter.setAuthenticationSuccessHandler(getAuthenticationSuccessHandler());
        filter.setAuthenticationFailureHandler(getAuthenticationFailureHandler());
        filter.setAuthenticationManager(authenticationManager());
        filter.setFilterProcessesUrl("/authorize/login");
        return filter;
    }

    private AuthenticationFailureHandler getAuthenticationFailureHandler() {
        return (req, res, exp) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.UNAUTHORIZED.value());
            res.setContentType(MediaType.APPLICATION_JSON_VALUE);
            res.setCharacterEncoding("UTF-8");
            val errData = Map.of(
                    "title", "认证失败",
                    "details", exp.getMessage()
            );
            res.getWriter().println(objectMapper.writeValueAsString(errData));
        };
    }

    private AuthenticationSuccessHandler getAuthenticationSuccessHandler() {
        return (req, res, auth) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.OK.value());
            res.getWriter().println(objectMapper.writeValueAsString(auth));
        };
    }
}
```

# 5.核心组件

## 一、spring security框架

```xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
```

模块：

 ![image-20220620172052554](../../../../picbed/store/picbed/img/image-20220620172052554.png)



## 二、认证核心组件、流程、代码解析

### 1.核心组件

- SecurityContext：存储当前认证的用户（与程序交互的主体）的详细信息
- SecurityContextHolder:工具类，提供对安全上下文的访问，默认情况下，使用ThreadLocal对象存储安全上下文。
- Authentication：存储当前用户的详细信息；principal可以理解为用户信息；credentials可以理解为密码；authorities可以理解为权限

![image-20220620172702989](../../../../picbed/store/picbed/img/image-20220620172702989.png)

### 2.Authentication

核心元素，常见的如UsernamePasswordAuthenticationToken。

![image-20220620172928893](../../../../picbed/store/picbed/img/image-20220620172928893.png)

### 3.UserDetials、UserDetailsService

通常场景下用户具备的一系列属性约束，就是userdetails。

从数据存储中根据用户名找到用户，就是UserDetailsService完成。这两个对象不负责认证，只提供数据。一般是通过扩展实现自定义数据库结构。

```java
public interface UserDetailsService {
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```

UserDetails在spring中设计为一个接口，可以方便扩展，这就是它可以指代任何用户对象的原因。用户有的约束，其实就是userdetails提供的，比如用户过期、锁定等。

```java
public interface UserDetails extends Serializable {
    Collection<? extends GrantedAuthority> getAuthorities();

    String getPassword();

    String getUsername();

    boolean isAccountNonExpired();

    boolean isAccountNonLocked();

    boolean isCredentialsNonExpired();

    boolean isEnabled();
}
```

## 三、基于数据库认证

最基础的表：**用户表与角色表**。

![image-20220620175000920](../../../../picbed/store/picbed/img/image-20220620175000920.png)

- 添加依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
```

- 在yml中配置h2内存数据库的信息：用户名、密码、driver、url、界面等

- 配置数据库认证：

```java
@EnableWebSecurity
@RequiredArgsConstructor
@Import(SecurityProblemSupport.class)
@Order(99)   // 针对rest api 配置
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    private final ObjectMapper objectMapper;
    private final SecurityProblemSupport securityProblemSupport;
    private final DataSource dataSource;

    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().mvcMatchers("/public/**","/h2-console/*");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.requestMatchers(req -> req.mvcMatchers("authorize/**","/admin/**","/api/**"))
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .exceptionHandling(exp -> exp
                        .accessDeniedHandler(securityProblemSupport))
                .authorizeRequests(req -> req
                        .antMatchers("/authorize/**").permitAll()
                        .antMatchers("/admin/**").hasRole("ADMIN")
                        .antMatchers("/api/**").hasRole("USER")
                        .anyRequest().authenticated())
                .addFilterAt(restAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
                .csrf(AbstractHttpConfigurer::disable);
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.jdbcAuthentication()
                .withDefaultSchema()
                .dataSource(dataSource)
                .withUser("user")
                .password(passwordEncoder().encode("123456"))
                .roles("USER", "ADMIN");
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        val idForDefault = "bcrypt";
        val encoders = Map.of(
                idForDefault, new BCryptPasswordEncoder(),
                "SHA-1", new MessageDigestPasswordEncoder("SHA-1")
        );
        return new DelegatingPasswordEncoder(idForDefault, encoders);
    }

    private RestAuthenticationFilter restAuthenticationFilter() throws Exception{
        RestAuthenticationFilter filter = new RestAuthenticationFilter(objectMapper);
        filter.setAuthenticationSuccessHandler(getAuthenticationSuccessHandler());
        filter.setAuthenticationFailureHandler(getAuthenticationFailureHandler());
        filter.setAuthenticationManager(authenticationManager());
        filter.setFilterProcessesUrl("/authorize/login");
        return filter;
    }

    private AuthenticationFailureHandler getAuthenticationFailureHandler() {
        return (req, res, exp) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.UNAUTHORIZED.value());
            res.setContentType(MediaType.APPLICATION_JSON_VALUE);
            res.setCharacterEncoding("UTF-8");
            val errData = Map.of(
                    "title", "认证失败",
                    "details", exp.getMessage()
            );
            res.getWriter().println(objectMapper.writeValueAsString(errData));
        };
    }

    private AuthenticationSuccessHandler getAuthenticationSuccessHandler() {
        return (req, res, auth) -> {
            ObjectMapper objectMapper = new ObjectMapper();
            res.setStatus(HttpStatus.OK.value());
            res.getWriter().println(objectMapper.writeValueAsString(auth));
        };
    }
}
```

- 简单的自定义查询语句

![image-20220620180648355](../../../../picbed/store/picbed/img/image-20220620180648355.png)

提供这两个信息给配置接口就可以，里面可以写sql查询语句，提供了非常大的数据库定制化。



## 四、深度定制化数据库

withUser为什么可以创建出用户呢？因为它使用JdbcUserDetailsManager，内部使用sql创建了用户。

定制自己的数据库表结构，对于jdbc，内建了JdbcUserDetailsManager，用JdbcDaoImpl实现。内部的几个query，可以自己去替换，从而实现定制化。

实现自己的UserDetails、UserDetailsService。

### 1.基于JPA定制

- 首先引入jpa的依赖。
- 实现用户表、UserDetails接口
- 实现角色表、GrantedAuthority接口
- 定义表与表的关系



## 五、环境与环境变量

一般至少由2个以上的环境：开发、生成、预发布、测试等。

spring中的环境配置：application-{profile}.xml

使用系统环境变量：${DB_SCHEMA:test},外部环境变量动态赋值给应用。

application.xml配置的是各个环境配置文件中公有的内容。



## 六、自动化测试

Web的集成测试可以使用@SpringBootTest注解，使用MockMvc执行请求以及响应去判断。一般mock请求接口时，不需要关注安全认证授权，因为qpring会自己处理。如果测试时，需要安全认证授权，可以在构建MockMvc时应用Spring Security。使用@WithMockUser，使用虚拟用户测试运行，默认角色是user。

![image-20230108174546560](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230108174546560.png)

## 七、源码认证过程

### 1.数据库认证

<img src="https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230108204800271.png" alt="image-20230108204800271" style="zoom:67%;" />

- AuthenticationProvider：对于不同的认证机制，会有不同的Provider
- AuthenticationManager：负责处理身份认证，构造函数要求传入所有AuthenticationProvider，内建AuthenticationManager叫做ProviderManager。

### 2.LDAP认证

![image-20230108214036222](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230108214036222.png)

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
