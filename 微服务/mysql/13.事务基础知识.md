## 一、数据库事务概述  

事务是数据库区别于文件系统的重要特性之一,当我们有了事务就会让数据库始终保持一致性,同时我们还能通过事务的机制恢复到某个时间点,这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。

### 1.存储引擎支持情况

**SHOW ENGINES** 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。  

![image-20231014160208709](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231014160208709.png)

能看出在 MySQL 中，**只有InnoDB 是支持事务的**。  

### 2.基本概念

- 事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态。
- 事务处理的原则：保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被**提交( commit )**，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务**回滚( rollback )**到最初状态。

### 3.事务的ACID特性  

- **原子性**（atomicity）  ：原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。  

- **一致性**（consistency）  ：国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对Consistency的阐述。根据定义，一致性是指事务执行前后，数据从一个 合法性状态 变换到另外一个 合法性状态 。这种状态是 语义上 的而不是语法上的，跟具体的业务有关。由原子性、持久性、隔离性共同保证。

  那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。

  **举例1**:A账户有200元,转账300元出去,此时A账户余额为-100元。你自然就发现了此时数据是不一致的,为什么呢?因为你定义了一个状态,余额这列必须>=0。

  **举例2**:A账户200元,转账50元给B账户,A账户的钱扣了,但是B账户因为各种意外,余额并没有增加。你也知道此时数据是不一致的,为什么呢?因为你定义了一个状态,要求A+B的总余额必须不变

  **举例3**:在数据表中我们将姓名字段设置为唯一性约束,这时当事务进行提交或者事务发生回滚的时候,如果数据表中的姓名不唯一,就破坏了事务的一致性要求。

- **隔离型**（isolation）  ：事务的隔离性是指一个事务的执行 不能被其他事务干扰 ，即一个事务内部的操作及使用的数据对 并发 的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。  

  如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：  

  ```sql
  UPDATE accounts SET money = money - 50 WHERE NAME = 'AA';
  UPDATE accounts SET money = money + 50 WHERE NAME = 'BB';
  ```

  ![image-20231014161211766](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231014161211766.png)

- **持久性**（durability）  ：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 **永久性**的 ，接下来的其他操作和数据库故障不应该对其有任何影响  。

  持久性是通过 **事务日志** 来保证的。日志包括了 **重做日志** 和 **回滚日志** 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的**好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性**。  

### 4.事务的状态  

事务 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把 事务 大致划分成几个状态：  

- **活动**的（active）  ：事务对应的数据库操作正在执行过程中时，我们就说该事务处在 活动的 状态。  
- **部分提交**的（partially committed）  ：当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 没有刷新到磁盘时，我们就说该事务处在 部分提交的 状态。  
- **失败**的（failed）  ：当事务处在 活动的 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失败的 状态  
- 中止的（aborted）  ：如果事务执行了一部分而变为 失败的 状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 回滚 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 中止的 状态。  
- **提交**的（committed）  ：当一个处在 部分提交的 状态的事务将修改过的数据都 同步到磁盘 上之后，我们就可以说该事务处在了 提交的 状态。  

![image-20231014162121350](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231014162121350.png)

## 二、如何使用事务  

使用事务有两种方式，分别为 显式事务 和 隐式事务 。  

### 1.显式事务  

步骤1： START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。  

START TRANSACTION 语句相较于 BEGIN 特别之处在于，后边能跟随几个 修饰符   ：

① **READ ONLY** ：标识当前事务是一个 只读事务 ，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。

② READ WRITE ：标识当前事务是一个 读写事务 ，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。

③ **WITH CONSISTENT SNAPSHOT** ：启动一致性读。

```sql
START TRANSACTION READ ONLY,WITH CONSISTENT SNAPSHOT
```

- READ ONLY和 READ WRITE是用来设置所谓的事务**访问模式**的,就是以只读还是读写的方式来访问数据库中的数据,一个事务的访问模式**不能同时既设置为只读的也设置为读写的**,所以不能同时把 READ ONLY和READ WRITE放到 START TRANSACTION语句后边。
- 如果我们不显式指定事务的访问模式,那么该事务的访问模式就是**读写模式**

步骤2：一系列事务中的操作（主要是DML，不含DDL）  

步骤3：**提交事务 或 中止事务（即回滚事务）**  ：COMMIT  、ROLLBACK  、ROLLBACK TO [SAVEPOINT]  （将事务回滚到某个保存点）。

```sql
# 在事务中创建保存点，方便后续针对保存点进行回滚，一个事务可以存在多个保存点
savepoint name；

# 删除保存点
release savepoint name;

# 回滚到保存点
rollback to 保存点名称;
```

> 补充:只读事务中只是不允许修改那些其他事务也能访问到的表中的数据,对于临时表来说(我们使用CREATE TMEPORARY TABLE创建的表),由于它们只能在当前会话中可见,所以**只读事务其实也是可以对临时表进行增、删、改操作的**

### 2.隐式事务  

MySQL中有一个系统变量 autocommit ：  

```sql
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
```

默认情况下,如果我们不显式的使用 START TRANSACTI0N或者 BEGIN语句开启一个事务,那么每一条语句都算是一个独立的事务,这种特性称之为**事务的自动提交**。也就是说,不以 START TRANSACTI0N或者 BEGIN语句显式的开启一个事务,那么下边这两条语句就相当于放到两个独立的事务中去执行。

想关闭这种 自动提交 的功能，可以使用下边两种方法之一：  

- 显式的的使用 START TRANSACTION 或者 BEGIN 语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。

- 把系统变量 autocommit 的值设置为 OFF ，就像这样：  

  ```sql
  mysql> set autocommit=off;
  或
  mysql> set autocommit=0;
  ```

相同的SQL代码,只是在事务开始之前设置了**SET @@completion_type=1;**,结果就和我们第一次处理的一样,只有一个“张三”。这是为什么呢？

MSQL中 completion_type参数的作用,实际上这个参数有3种可能：

1. completion=0,这是**默认情况**。当我们执行 COMMIT的时候会提交事务,在执行下一个事务时,还需要使用 **START TRANSACTION或者 BEGIN**来开启
2.  completion=1,这种情况下,当我们**提交事务后**,相当于执行了 **COMMIT AND CHAIN**,也就是**开启链式事务**,即当我们提交事务之后会**开启一个相同隔离级别的事务**
3. completion=2,这种情况下 COMMIT= COMMIT AND RELEASE,也就是当我们提交后,会**自动与服务器断开连接**。

### 3.隐式提交数据的情况  

- 数据定义语言（Data definition language，缩写为：**DDL**）  

  数据库对象,指的就是数据库、表、视图、存储过程等结构。当我们使用 CREATE、 ALTER、DROP等语句去修改数据库对象时,就会隐式的提交前边语句所属于的事务。即

  ```sql
  begin;
  
  select...
  update...
  ...
  create table... # 隐式提交前面的所属于的事务
  ```

- **隐式使用或修改mysql数据库中的表**    

  当我们使用 ALTER USER、 CREATE USER、 DROP USER、 GRANT、 RENAME USER、 REVOKE、SETPASSWORD等语句时也会隐式的提交前边语句所属于的事务。

- **事务控制或关于锁定的语句**  

  ① 当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会 隐式的提交 上一个事务。即：

  ```sql
  begin;
  
  select..
  update...
  ...
  begin;# 提交事务
  ```

  ② 当前的 **autocommit** 系统变量的值为 OFF ，我们**手动把它调为 ON** 时，也会 **隐式的提交** 前边语句所属的事务。

  

  ③ 使用 **LOCK TABLES 、 UNLOCK TABLES** 等关于锁定的语句也会 隐式的提交 前边语句所属的事务。

- **加载数据的语句**  

  使用L0 AD DATA语句来批量往数据库中导入数据时,也会隐式的提交前边语句所属的事务

- **关于MySQL复制的一些语句**  

  使用 START SLAVE、 STOP SLAVE、 RESET SLAVE、 CHANGE MASTER T0等语句时会**隐式的提交**前边语句所属的事务

- 其它的一些语句  

  使用 ANALYZE TABLE、 CACHE INDEX、 CHECK TABLE、 FLUSH、 LOAD INDEX INTO CACHE、OPTIMIZE TABLE、 REPAIR TABLE、 RESET等语句也会隐式的提交前边语句所属的事务。

>当我们设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。
>
>当我们设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。

## 三、事务隔离级别  

MySQL是一个 客户端／服务器 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称为一个**会话（ Session ）**。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务有 **隔离性** 的特性，理论上在某个事务 **对某个数据进行访问** 时，其他事务应该进行 **排队** ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 **性能影响太大** ，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 **性能尽量高些** ，那就看二者如何权衡取舍了。

### 1.数据准备  

```sql
CREATE TABLE student (
studentno INT,
name VARCHAR(20),
class varchar(20),
PRIMARY KEY (studentno)
) Engine=InnoDB CHARSET=utf8;

INSERT INTO student VALUES(1, '小谷', '1班');
```

### 2.数据并发问题  

针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在 **不保证串行执行** （也就是执行完一个再执行另一个）的情况下可能会出现哪些问题：

- **脏写（ Dirty Write ）**  

对于两个事务 Session A、Session B，如果事务Session A 修改了 另一个 **未提交** 事务Session B 修改过 的数据，那就意味着发生了 脏写  

![image-20231014171009481](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231014171009481.png)

- **脏读（ Dirty Read ）**  

对于两个事务 Session A、Session B，Session A 读取 了已经被 Session B **更新** 但还 **没有被提交** 的字段。之后若 Session B **回滚** ，Session A **读取** 的内容就是 **临时且无效** 的。  

![image-20231014171038616](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231014171038616.png)

- **不可重复读（ Non-Repeatable Read ）**  

对于两个事务Session A、Session B，Session A **读取** 了一个字段，然后 Session B **更新** 了该字段。 之后Session A **再次读取** 同一个字段， 值就不同 了。那就意味着发生了不可重复读。  

![image-20231014171204935](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231014171204935.png)

- **幻读（ Phantom ）**  

对于两个事务Session A、Session B, Session A 从一个表中 **读取** 了一个字段, 然后 Session B 在该表中 **插入** 了一些新的行。 之后, 如果 Session A 再次读取 **同一个表**, 就会多出几行。那就意味着发生了幻读 。

有的同学会有疑问,那如果 Session b中删除了一些符合 studentno>9的记录而不是插入新记录,那 Session a之后再根据 studentno>的条件读取的记录变少了,这种现象算不算幻读呢?这种现象不属于幻读,幻读强调的是一个事务按照某个相同条件多次读取记录时,后读取时**读到了之前没有读到的记录**。

![image-20231014171331418](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231014171331418.png)

其实RR也是可以避免幻读的,通过对 select操作手动加**行X锁(独占锁)**( SELECT… FOR UPDATE这也正是SER| ALIZABLE隔离级别下会隐式为你做的事情)。同时,即便当前记录不存在,比如id=3是不存在的,当前事务也会获得一把记录锁(因为 Innodb的行锁锁定的是索引,故记录实体存在与否没关系,**存在就加行X锁,不存在就加间隙锁**),其他事务则无法插入此索引的记录,故杜绝了幻读。

在 **SERIALIZABLE**隔离级别下,step1执行时是会隐式的添加**行(X)锁/gap(X)锁**的,从而step2会被阻塞step3会正常执行,待事务1提交后,事务2才能继续执行(主键冲突执行失败),对于事务1来说业务是正确的,成功的阻塞扼杀了扰乱业务的事务2,对于事务1来说他前期读取的结果是可以支撑其后续业务的。

### 3.SQL中的四种隔离级别  

**脏写 > 脏读 > 不可重复读 > 幻读**  

愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。 SQL标准 中设立了4个 隔离级别 ：  

- **READ UNCOMMITTED ：读未提交**，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。
- **READ COMMITTED ：读已提交**，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。
- **REPEATABLE READ ：可重复读**，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。
- **SERIALIZABLE ：可串行化**，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。

![image-20231014171702072](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231014171702072.png)

**脏写** 怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。  

不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4种事务隔离级别与并发性能的关系如下：  

<img src="https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231014171757215.png" alt="image-20231014171757215" style="zoom:50%;" />

### 4.MySQL支持的四种隔离级别  

MySQL的**默认隔离级别为REPEATABLE READ**，我们可以手动修改一下事务的隔离级别。  

```sql
mysql> SHOW VARIABLES LIKE 'tx_isolation'; # 5.7.20版本以前
Empty set (0.00 sec)

mysql> SHOW VARIABLES LIKE 'transaction_isolation'; # 5.7.20以后
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+

mysql> SELECT @@transaction_isolation; # 任何版本都可以
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
```

### 5.如何设置事务的隔离级别  

通过下面的语句修改事务的隔离级别：  

```sql
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;
#其中，隔离级别格式：
> READ UNCOMMITTED
> READ COMMITTED
> REPEATABLE READ
> SERIALIZABLE
```

或者

```sql
SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = '隔离级别'
#其中，隔离级别格式：
> READ-UNCOMMITTED
> READ-COMMITTED
> REPEATABLE-READ
> SERIALIZABLE
```

**关于设置时使用GLOBAL或SESSION的影响**：  

- 使用 GLOBAL 关键字（在全局范围影响）  

```sql
SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;
#或
SET GLOBAL TRANSACTION_ISOLATION = 'SERIALIZABLE';
```

当前已经存在的会话无效，只对执行完该语句之后产生的会话起作用。

- 使用 SESSION 关键字（在会话范围影响）： 

```sql
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
#或
SET SESSION TRANSACTION_ISOLATION = 'SERIALIZABLE';
```

对当前会话的所有后续的事务有效，如果在事务之间执行，则对后续的事务有效。

该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务。

## 四、事务的常见分类  

从事务理论的角度来看，可以把事务分为以下几种类型：

- 扁平事务（Flat Transactions）



- 带有保存点的扁平事务（Flat Transactions with Savepoints）



- 链事务（Chained Transactions）



- 嵌套事务（Nested Transactions）



- 分布式事务（Distributed Transactions）

