在数据库调优中,我们的目标就是**响应时间更快,吞吐量更大**。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。

## 一、数据库服务器的优化步骤  

当我们遇到数据库调优问题的时候，该如何思考呢？

整个流程划分成了 **观察（Show status） 和 行动（Action）** 两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。

![image-20231003163403074](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231003163403074.png)

![image-20231003163423693](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231003163423693.png)

以上就是数据库调优的流程思路。如果我们发现执行SQL时存在不规则延迟或卡顿的时候,就可以采用分析工具帮我们定位有问题的sQL,这三种分析工具你可以理解是sQL调优的三个步骤:**慢查询、 EXPLAIN和SHOWPROFILING**。

![image-20231003163833347](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231003163833347.png)

##  二、查看系统性能参数

在MySQL中，可以使用 SHOW STATUS 语句查询一些MySQL数据库服务器的 性能参数 、 执行频率 。  

```sql
SHOW [GLOBAL|SESSION] STATUS LIKE '参数';
```

一些常用的性能参数如下：

- Connections：连接MySQL服务器的次数。
-  Uptime：MySQL服务器的上线时间。
- Slow_queries：慢查询的次数。 
- Innodb_rows_read：Select查询返回的行数 
- Innodb_rows_inserted：执行INSERT操作插入的行数 
-  Innodb_rows_updated：执行UPDATE操作更新的行数 
- Innodb_rows_deleted：执行DELETE操作删除的行数 
-  Com_select：查询操作的次数。 
-  Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。 
- Com_update：更新操作的次数。
-  Com_delete：删除操作的次数  

## 三、统计SQL的查询成本：last_query_cost  

一条sqL查询语句在执行前需要确定查询执行计划,如果存在多种执行计划的话, MYSQL会计算每个执行计划所需要的成本,从中选择**成本最小**的一个作为最终执行的执行计划。

如果我们想要查看某条SQL语句的查询成本,可以在执行完这条SQL语句之后,通过查看当前会话中的**last_query-cost**变量值来得到当前查询的成本。它通常也是我们**评价一个查询的执行效率**的一个常用指标。这个查询成本对应的是**SQL语句所需要读取的页的数量**。我们依然使用第8章的 student info表为例：

```sql
CREATE TABLE `student_info` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`student_id` INT NOT NULL ,
`name` VARCHAR(20) DEFAULT NULL,
`course_id` INT NOT NULL ,
`class_id` INT(11) DEFAULT NULL,
`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

如果我们想要查询 id=900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：  

```sql
mysql> SELECT student_id, class_id, NAME, create_time FROM student_info WHERE id = 900001;
+------------+----------+--------+---------------------+
| student_id | class_id | NAME   | create_time         |
+------------+----------+--------+---------------------+
|     172896 |    10000 | qXSwDE | 2023-09-28 08:33:41 |
+------------+----------+--------+---------------------+
1 row in set (0.01 sec)
```

然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：  

```sql
mysql> show status like 'last_query_cost';
+-----------------+----------+
| Variable_name   | Value    |
+-----------------+----------+
| Last_query_cost | 1.000000 |
+-----------------+----------+
```

想要查询 id 在 900001 到 9000100 之间的学生记录呢？  

```sql
mysql> SELECT student_id, class_id, NAME, create_time FROM student_info  WHERE id BETWEEN 900001 AND 900100;
100 rows in set (0.00 sec)
mysql> show status like 'last_query_cost';
+-----------------+-----------+
| Variable_name   | Value     |
+-----------------+-----------+
| Last_query_cost | 20.290751 |
+-----------------+-----------+
```

能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了**顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找**。虽然 页数量（last_query_cost）增加了不少 ，但是通过**缓冲池的机制**，并 没有增加多少查询时间 。  

**使用场景**：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候  。

SQL查询是一个动态的过程,从页加载的角度来看,我们可以得到以下两点结论：

- **位置决定效率**。如果页就在数据库缓冲池中,那么效率是最高的,否则还需要从内存或者磁盘中进行读取,当然针对单个页的读取来说,如果页存在于内存中,会比在磁盘中读取效率高很多。
- **批量决定效率**。如果我们从磁盘中对单一页进行随机读,那么效率是很低的(差不多10ms),而采用顺序读取的方式,批量对页进行读取,平均一页的读取效率就会提升很多,甚至要快于单个页面在内存中的随机读取。

所以说,遇到I/O并不用担心,方法找对了,效率还是很高的。我们首先要考虑数据存放的位置,如果是经常使用的数据就要尽量放到缓冲池中,其次我们可以充分利用磁盘的吞吐能力,一次性批量读取数据,这样单个页的读取效率也就得到了提升。

## 四、定位执行慢的SQL：慢查询日志

MYSQL的慢查询日志,用来记录在 MYSQL中**响应时间超过阀值**的语句,具体指运行时间超过**long_query-time**值的sqL,则会被记录到慢查询日志中。 long_query_time的默认值为10,意思是运行10秒以上(不含10秒)的语句,认为是超出了我们的最大忍耐时间值。

它的主要作用是,帮助我们发现那些执行时间特别长的sQL査询,并且有针对性地进行优化,从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候,检査一下慢査询日志,找到那些慢查询,对解决问题很有帮助。比如—条sq执行超过5秒钟,我们就算慢sQL,希望能收集超过5秒的sql,结合 explain进行全面分析。

**默认情况下, MYSQL数据库没有开启慢查询日志**,需要我们手动来设置这个参数。如果不是调优需要的话,一般不建议启动该参数,因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。

### 1.开启slow_query_log  

```sql
mysql> show variables like '%slow_query_log';
+----------------+-------+
| Variable_name  | Value |
+----------------+-------+
| slow_query_log | OFF   |
+----------------+-------+
mysql> set global slow_query_log='ON';
```

查看下慢查询日志是否开启，以及慢查询日志文件的位置：  

```sql
mysql> show variables like '%slow_query_log%';
+---------------------+-----------------------------------+
| Variable_name       | Value                             |
+---------------------+-----------------------------------+
| slow_query_log      | ON                                |
| slow_query_log_file | /var/lib/mysql/localhost-slow.log |
+---------------------+-----------------------------------+
```

### 2.修改long_query_time阈值  

```sql
mysql> show variables like '%long_query_time%';
+-----------------+-----------+
| Variable_name   | Value     |
+-----------------+-----------+
| long_query_time | 10.000000 |
+-----------------+-----------+
```

把时间缩短，比如设置为 1 秒，可以这样设置：  

```sql
#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并执行下述语句
mysql > set global long_query_time = 1;
mysql> show global variables like '%long_query_time%';
mysql> set long_query_time=1;
mysql> show variables like '%long_query_time%';
```

**补充:配置文件中一并设置参数**

如下的方式相较于前面的命令行方式,可以看作是永久设置的方式。

修改my.cnf文件,[ mysqld下增加或修改参数long_ querytime、slow_query_log和slow_ query-log-file后,然后重启MsQL服务器。

```properties
[mysqld]
slow_query_log=0N #开启慢查询日志的开关
slow_query_1og_file=/var/1ib/mysq1/atguigu-s1ow.1og #慢查询日志的目录和文件名信息
long_query-time=3 #设置慢查询的阈值为3秒,超出此设定值的SQL即被记录到慢查询日志
log_output=FILE
```

如果不指定存储路径,慢查询日志将默认存储到MsQL数据库的数据文件夹下。如果不指定文件名，默认文件名为hostname-slow.log。

### 3.查看慢查询数目  

查询当前系统中有多少条慢查询记录 :

```sql
mysql> SHOW GLOBAL STATUS LIKE '%Slow_queries%';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Slow_queries  | 0     |
+---------------+-------+
```

### 4.案例演示  

- 创建student表

```sql
CREATE TABLE `student` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`stuno` INT NOT NULL ,
`name` VARCHAR(20) DEFAULT NULL,
`age` INT(3) DEFAULT NULL,
`classId` INT(11) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

- 设置参数log_bin_trust_function_creators  

创建函数，假如报错 ： This function has none of DETERMINISTIC  

命令开启：允许创建函数设置  

```sql
set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。
```

- 创建函数

```sql
DELIMITER //
CREATE FUNCTION rand_string(n INT)
RETURNS VARCHAR(255) #该函数会返回一个字符串
BEGIN
DECLARE chars_str VARCHAR(100) DEFAULT
'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
DECLARE return_str VARCHAR(255) DEFAULT '';
DECLARE i INT DEFAULT 0;
WHILE i < n DO
SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
SET i = i + 1;
END WHILE;
RETURN return_str;
END //
DELIMITER ;
#测试
SELECT rand_string(10);
```

```sql
DELIMITER //
CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)
BEGIN
DECLARE i INT DEFAULT 0;
SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;
RETURN i;
END //
DELIMITER ;
#测试：
SELECT rand_num(10,100);
```

- 创建存储过程

```sql
DELIMITER //
CREATE PROCEDURE insert_stu1( START INT , max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0; #设置手动提交事务
REPEAT #循环
SET i = i + 1; #赋值
INSERT INTO student (stuno, NAME ,age ,classId ) VALUES
((START+i),rand_string(6),rand_num(10,100),rand_num(10,1000));
UNTIL i = max_num
END REPEAT;
COMMIT; #提交事务
END //
DELIMITER ;
```

- 调用存储过程

```sql
#调用刚刚写好的函数, 4000000条记录,从100001号开始
CALL insert_stu1(100001,4000000);
```

### 5.测试及分析  

```sql
mysql> SELECT * FROM student WHERE stuno = 3455655;
+---------+---------+--------+------+---------+
| id      | stuno   | name   | age  | classId |
+---------+---------+--------+------+---------+
| 3355654 | 3455655 | HJxoYb |   30 |      41 |
+---------+---------+--------+------+---------+
1 row in set (1.13 sec)

mysql> SELECT * FROM student WHERE name = 'oQmLUr';
+---------+---------+--------+------+---------+
| id      | stuno   | name   | age  | classId |
+---------+---------+--------+------+---------+
|  794067 |  894068 | OQMlUR |   55 |     956 |
| 1401578 | 1501579 | oqMLuR |   12 |     583 |
| 1516652 | 1616653 | oqMLuR |   11 |     548 |
| 1990414 | 2090415 | oQmLUr |   97 |     824 |
| 2006833 | 2106834 | oQmLUr |   98 |     866 |
| 2686059 | 2786060 | oQmLUr |   99 |     916 |
| 2893120 | 2993121 | oQmLUr |   98 |     882 |
| 3401300 | 3501301 | Oqmlur |   54 |     416 |
| 3763038 | 3863039 | Oqmlur |   57 |     578 |
| 3783917 | 3883918 | OQMlUR |   51 |     815 |
| 3966718 | 4066719 | Oqmlur |   51 |     281 |
+---------+---------+--------+------+---------+
11 rows in set (1.23 sec)

mysql> show status like 'slow_queries';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Slow_queries  | 2     |
+---------------+-------+
```

查询学生编号为“3455655”的学生信息花费时间为1.13秒。查询学生姓名为“oQmLUr”的学生信息花费时间为1.23秒。已经达到了秒的数量级，说明目前查询效率是比较低的，下面的小节我们分析一下原因  ：

除了上述变量,控制慢查询日志的还有—个系统变量:**min_ examined_row_limit**。这个变量的意思是,**查询扫描过的最少记录数**。**这个变量和查询执行时间,共同组成了判别一个查询是否是慢查询的条件**。如果查询扫描过的记录数大于等于这个变量的值,并且查询执行时间超过 long_query_time的值,那么,这个查询就被记录到慢查询日志中;反之,则不被记录到慢查询日志中。

```sql
mysql> show variables like 'min%';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| min_examined_row_limit | 0     |
+------------------------+-------+
```

这个值默认是0。与 long_ query_time=10合在一起,表示只要查询的执行时间超过10秒，哪怕一个记录也没有扫描过,都要被记录到慢查询日志中。你也可以根据需要,通过修改“ my.Ini文件,来修改查询时长,或者通过SET指令,用SQL语句修改“ min_ examined_row_limit"的值。

### 6.慢查询日志分析工具：mysqldumpslow  

在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow 。  

查看mysqldumpslow的帮助信息 :

```shell
[root@localhost ~]# mysqldumpslow --help
Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]

Parse and summarize the MySQL slow query log. Options are

  --verbose    verbose
  --debug      debug
  --help       write this text to standard output

  -v           verbose
  -d           debug
  -s ORDER     what to sort by (al, at, ar, c, l, r, t), 'at' is default
                al: average lock time
                ar: average rows sent
                at: average query time
                 c: count
                 l: lock time
                 r: rows sent
                 t: query time
  -r           reverse the sort order (largest last instead of first)
  -t NUM       just show the top n queries
  -a           don't abstract all numbers to N and strings to 'S'
  -n NUM       abstract numbers with at least n digits within names
  -g PATTERN   grep: only consider stmts that include this string
  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),
               default is '*', i.e. match all
  -i NAME      name of server instance (if using mysql.server startup script)
  -l           don't subtract lock time from total time
```

mysqldumpslow 命令的具体参数如下：  

- -a: 不将数字抽象成N，字符串抽象成S

- -s: 是表示按照何种方式排序：
  - c: 访问次数
  - l: 锁定时间
  - r: 返回记录
  - t: 查询时间
  - al:平均锁定时间
  - ar:平均返回记录数
  - at:平均查询时间 （默认方式） 
  - ac:平均查询次数
- -t: 即为返回前面多少条的数据  
- -g: 后边搭配一个正则匹配模式，大小写不敏感的  

```shell
# 按照查询时间排序，查看前五条 SQL 语句
[root@localhost mysql]# mysqldumpslow -s t -t 5  /var/lib/mysql/localhost-slow.log

Reading mysql slow query log from /var/lib/mysql/localhost-slow.log
Count: 1  Time=555.48s (555s)  Lock=0.00s (0s)  Rows=0.0 (0), root[root]@localhost
  CALL insert_stu1(N,N)

Count: 1  Time=1.23s (1s)  Lock=0.00s (0s)  Rows=11.0 (11), root[root]@localhost
  SELECT * FROM student WHERE name = 'S'

Count: 1  Time=1.13s (1s)  Lock=0.00s (0s)  Rows=1.0 (1), root[root]@localhost
  SELECT * FROM student WHERE stuno = N

Died at /usr/bin/mysqldumpslow line 162, <> chunk 3.
```

工作常用参考：  

```shell
#得到返回记录集最多的10个SQL
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log
#得到访问次数最多的10个SQL
mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log
#得到按照时间排序的前10条里面含有左连接的查询语句
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/atguigu-slow.log
#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more
```

### 7.关闭慢查询日志  

**方式1：永久性方式**  

```properties
[mysqld]
slow_query_log=OFF
```

或者，把slow_query_log一项注释掉 或 删除  

```properties
[mysqld]
#slow_query_log =OFF
```

重启MySQL服务，执行如下语句查询慢日志功能 

```sql
SHOW VARIABLES LIKE '%slow%'; #查询慢查询日志所在目录
SHOW VARIABLES LIKE '%long_query_time%'; #查询超时时长
```

**方式2：临时性方式**  

使用SET语句来设置。 （1）停止MySQL慢查询日志功能，具体SQL语句如下。  

```sql
SET GLOBAL slow_query_log=off;
```

重启MySQL服务，使用SHOW语句查询慢查询日志功能信息，具体SQL语句如下  

```sql
SHOW VARIABLES LIKE '%slow%';
#以及
SHOW VARIABLES LIKE '%long_query_time%';
```

### 8.删除慢查询日志  

使用SHOW语句显示慢查询日志信息,具体SQL语句如下。

```sql
mysql> SHOW VARIABLES LIKE 'slow_query_log%';
+---------------------+-----------------------------------+
| Variable_name       | Value                             |
+---------------------+-----------------------------------+
| slow_query_log      | ON                                |
| slow_query_log_file | /var/lib/mysql/localhost-slow.log |
+---------------------+-----------------------------------+
```

从执行结果可以看出,慢查询日志的目录默认为 MYSQL的数据目录,在该目录下**手动删除慢查询日志文件**即可。

使用命令mysqladmin flush-logs来重新生成查询日志文件,具体命令如下,执行完毕会在数据目录下重新生成慢查询日志文件。

```shell
mysqladmin -uroot -p flush-logs slow
```

慢查询日志都是使用 mysqladmin flush-logs命令来删除重建的。使用时一定要注意,一旦执行了这个命令,慢查询日志都只存在新的日志文件中,如果需要旧的查询日志,就必须事先备份。

## 五、查询SQL执行成本：SHOW PROFILE  

show profile在《逻辑架构》章节中讲过,这里作为复习。

Show Profile是Mysq提供的可以用来分析当前会话中sαL都做了什么、执行的资源消耗情况的工具,可用于sql调优的测量。默认情况下处于**关闭状态**,并保存**最近15次的运行结果**。

我们可以在会话级别开启这个功能：

```sql
show variables like 'profiling';
```

通过设置 profiling='ON’ 来开启 show profile：  

```sql
set profiling = 'ON';
```

然后执行相关的查询语句。接着看下当前会话都有哪些 profiles，使用下面这条命令：  

```sql
mysql> SELECT * FROM student WHERE stuno = 3455655;
+---------+---------+--------+------+---------+
| id      | stuno   | name   | age  | classId |
+---------+---------+--------+------+---------+
| 3355654 | 3455655 | HJxoYb |   30 |      41 |
+---------+---------+--------+------+---------+
1 row in set (1.25 sec)

mysql> SELECT * FROM student WHERE name = 'oQmLUr';
+---------+---------+--------+------+---------+
| id      | stuno   | name   | age  | classId |
+---------+---------+--------+------+---------+
|  794067 |  894068 | OQMlUR |   55 |     956 |
| 1401578 | 1501579 | oqMLuR |   12 |     583 |
| 1516652 | 1616653 | oqMLuR |   11 |     548 |
| 1990414 | 2090415 | oQmLUr |   97 |     824 |
| 2006833 | 2106834 | oQmLUr |   98 |     866 |
| 2686059 | 2786060 | oQmLUr |   99 |     916 |
| 2893120 | 2993121 | oQmLUr |   98 |     882 |
| 3401300 | 3501301 | Oqmlur |   54 |     416 |
| 3763038 | 3863039 | Oqmlur |   57 |     578 |
| 3783917 | 3883918 | OQMlUR |   51 |     815 |
| 3966718 | 4066719 | Oqmlur |   51 |     281 |
+---------+---------+--------+------+---------+
11 rows in set (1.23 sec)

mysql> show profiles;
+----------+------------+---------------------------------------------+
| Query_ID | Duration   | Query                                       |
+----------+------------+---------------------------------------------+
|        1 | 0.01263425 | SELECT * FROM student WHERE stuno = 3455655 |
|        2 | 0.02270850 | show databases                              |
|        3 | 0.00024575 | SELECT DATABASE()                           |
|        4 | 0.00119950 | show databases                              |
|        5 | 0.01804425 | show tables                                 |
|        6 | 1.25131775 | SELECT * FROM student WHERE stuno = 3455655 |
|        7 | 1.23256350 | SELECT * FROM student WHERE name = 'oQmLUr' |
+----------+------------+---------------------------------------------+
7 rows in set, 1 warning (0.01 sec)
```

查看最近一次查询的开销，可以使用：  show profile;

想查看某一条记录，可以使用for：

```sql
mysql>  show profile for query 6;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000253 |
| Executing hook on transaction  | 0.000009 |
| starting                       | 0.000022 |
| checking permissions           | 0.000015 |
| Opening tables                 | 0.000088 |
| init                           | 0.000012 |
| System lock                    | 0.000023 |
| optimizing                     | 0.000017 |
| statistics                     | 0.000044 |
| preparing                      | 0.000047 |
| executing                      | 1.250297 |
| end                            | 0.000030 |
| query end                      | 0.000006 |
| waiting for handler commit     | 0.000010 |
| closing tables                 | 0.000012 |
| freeing items                  | 0.000033 |
| logging slow query             | 0.000366 |
| cleaning up                    | 0.000036 |
+--------------------------------+----------+
```

还可以查看其他信息，例如cpu、io等：

```sql
mysql> show profile cpu,block io for query 6;
+--------------------------------+----------+----------+------------+--------------+---------------+
| Status                         | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |
+--------------------------------+----------+----------+------------+--------------+---------------+
| starting                       | 0.000253 | 0.000160 |   0.000050 |            0 |             0 |
| Executing hook on transaction  | 0.000009 | 0.000005 |   0.000001 |            0 |             0 |
| starting                       | 0.000022 | 0.000016 |   0.000005 |            0 |             0 |
| checking permissions           | 0.000015 | 0.000010 |   0.000003 |            0 |             0 |
| Opening tables                 | 0.000088 | 0.000062 |   0.000019 |            0 |             0 |
| init                           | 0.000012 | 0.000008 |   0.000003 |            0 |             0 |
| System lock                    | 0.000023 | 0.000017 |   0.000005 |            0 |             0 |
| optimizing                     | 0.000017 | 0.000011 |   0.000004 |            0 |             0 |
| statistics                     | 0.000044 | 0.000031 |   0.000009 |            0 |             0 |
| preparing                      | 0.000047 | 0.000034 |   0.000011 |            0 |             0 |
| executing                      | 1.250297 | 0.931630 |   0.294635 |            0 |             0 |
| end                            | 0.000030 | 0.000012 |   0.000003 |            0 |             0 |
| query end                      | 0.000006 | 0.000004 |   0.000001 |            0 |             0 |
| waiting for handler commit     | 0.000010 | 0.000007 |   0.000003 |            0 |             0 |
| closing tables                 | 0.000012 | 0.000008 |   0.000002 |            0 |             0 |
| freeing items                  | 0.000033 | 0.000023 |   0.000007 |            0 |             0 |
| logging slow query             | 0.000366 | 0.000143 |   0.000000 |            0 |             8 |
| cleaning up                    | 0.000036 | 0.000033 |   0.000000 |            0 |             0 |
+--------------------------------+----------+----------+------------+--------------+---------------+
```

show profile的常用查询参数：  

① ALL：显示所有的开销信息。 

② BLOCK IO：显示块IO开销。 

③ CONTEXT SWITCHES：上下文切换开销。 

④ CPU：显示CPU开销信息。 

⑤ IPC：显示发送和接收开销信息。

 ⑥ MEMORY：显示内存开销信息。

 ⑦ PAGE FAULTS：显示页面错误开销信息。 

⑧ SOURCE：显示和Source_function，Source_file， Source_line相关的开销信息。

 ⑨ SWAPS：显示交换次数开销信息。  

**日常开发需注意的结论**

① converting HEAP to MYISAM:查询结果太大,内存不够,数据往磁盘上搬了。

② Creating tmp table:创建临时表。先拷贝数据到临时表,用完后再删除临时表

③ Copying to tmp table on disk:把内存中临时表复制到磁盘上,警惕!

④locked。

如果在 show profile诊断结果中出现了以上4条结果中的任何一条,则sq语句需要优化。

**注意:**不过 SHOW PROFILE命令将被弃用,我们可以从 information_schema中的 profiling数据表进行查看。

## 六、分析查询语句：EXPLAIN  

### 1.概述

**定位了查询慢的SQL之后,我们就可以使用 EXPLAIN或 DESCRIBE工具做针对性的分析查询语句**。 DESCRIBEL语句的使用方法与 EXPLAIN语句是一样的,并且分析结果也是一样的。

MYSQL中有专门负责优化 Select语句的优化器模块,主要功能:通过计算分析系统中收集到的统计信息,为客户端请求的 Query提供它认为最优的**执行计划**(他认为最优的数据检索方式,但不见得是DBA认为是最优的,这部分最耗费时间）。

这个执行计划展示了接下来具体执行查询的方式,比如多表连接的顺序是什么,对于每个表采用什么访问方法来具体执行查询等等。MysαL为我们提供了 **EXPLAIN**语句来帮助我们查看某个查询语句的具体执行计划,大家看懂EXPLAIN语句的各个输出项,可以有针对性的提升我们查询语句的性能。

**1.能做什么?**

- 表的读取顺序
- 数据读取操作的操作类型
- 哪些索引可以使用哪些索引被实际使用
- 表之间的引用
- 每张表有多少行被优化器查询

2.官网介绍

https://dev.mysql.com/doc/refman/5.7/en/explain-output.html  

https://dev.mysql.com/doc/refman/8.0/en/explain-output.html  

3.版本情况  

- MySQL 5.6.3以前只能 EXPLAIN SELECT ；MYSQL 5.6.3以后就可以 EXPLAIN SELECT，UPDATE，DELETE
- 在5.7以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示filtered 需要使用 explain extended 命令。在5.7版本后，默认explain直接显示partitions和filtered中的信息

### 2.基本语法

```sql
EXPLAIN SELECT select_options
或者
DESCRIBE SELECT select_options
```

执行explain时并没有真正执行后面的语句，可以安全查看执行计划。

![image-20231003185501733](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231003185501733.png)

### 3.数据准备

- 建表

```sql
CREATE TABLE s1 (
id INT AUTO_INCREMENT,
key1 VARCHAR(100),
key2 INT,
key3 VARCHAR(100),
key_part1 VARCHAR(100),
key_part2 VARCHAR(100),
key_part3 VARCHAR(100),
common_field VARCHAR(100),
PRIMARY KEY (id),
INDEX idx_key1 (key1),
UNIQUE INDEX idx_key2 (key2),
INDEX idx_key3 (key3),
INDEX idx_key_part(key_part1, key_part2, key_part3)
) ENGINE=INNODB CHARSET=utf8;

CREATE TABLE s2 (
id INT AUTO_INCREMENT,
key1 VARCHAR(100),
key2 INT,
key3 VARCHAR(100),
key_part1 VARCHAR(100),
key_part2 VARCHAR(100),
key_part3 VARCHAR(100),
common_field VARCHAR(100),
PRIMARY KEY (id),
INDEX idx_key1 (key1),
UNIQUE INDEX idx_key2 (key2),
INDEX idx_key3 (key3),
INDEX idx_key_part(key_part1, key_part2, key_part3)
) ENGINE=INNODB CHARSET=utf8;
```

- 设置参数 log_bin_trust_function_creators  

```
set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效
```

- 创建函数  

```sql
DELIMITER //
CREATE FUNCTION rand_string1(n INT)
RETURNS VARCHAR(255) #该函数会返回一个字符串
BEGIN
DECLARE chars_str VARCHAR(100) DEFAULT
'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
DECLARE return_str VARCHAR(255) DEFAULT '';
DECLARE i INT DEFAULT 0;
WHILE i < n DO
SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
SET i = i + 1;
END WHILE;
RETURN return_str;
END //
DELIMITER ;
```

- 创建存储过程  

```sql
DELIMITER //
CREATE PROCEDURE insert_s1 (IN min_num INT (10),IN max_num INT (10))
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0;
REPEAT
SET i = i + 1;
INSERT INTO s1 VALUES(
(min_num + i),
rand_string1(6),
(min_num + 30 * i + 5),
rand_string1(6),
rand_string1(10),
rand_string1(5),
rand_string1(10),
rand_string1(10));
UNTIL i = max_num
END REPEAT;
COMMIT;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE insert_s2 (IN min_num INT (10),IN max_num INT (10))
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0;
REPEAT
SET i = i + 1;
INSERT INTO s2 VALUES(
(min_num + i),
rand_string1(6),
(min_num + 30 * i + 5),
rand_string1(6),
rand_string1(10),
rand_string1(5),
rand_string1(10),
rand_string1(10));
UNTIL i = max_num
END REPEAT;
COMMIT;
END //
DELIMITER ;
```

- 调用存储过程  

```sql
CALL insert_s1(10001,10000);
CALL insert_s2(10001,10000);
```

### 4.EXPLAIN各列作用  

#### 1.table

不论我们的查询语句有多复杂，里边儿 包含了**多少个表** ，到最后也是需要对每个表进行 **单表访问** 的，所以MySQL规定EXPLAIN语句输出的**每条记录都对应着某个单表的访问方法**，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称） 。

```sql
mysql> explain select * from s1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9868 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
mysql> explain select * from s1 inner join s2 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: s2
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9965
     filtered: 100.00
        Extra: Using join buffer (hash join)
2 rows in set, 1 warning (0.00 sec)
```

#### 2.id

在一个大的查询语句中，每个select关键字都对应一个唯一id。

写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里只有一个 SELECT 关键字，比如下边这个查询语句：  

```sql
SELECT * FROM s1 WHERE key1 = 'a';
```

稍微复杂一点的连接查询中也只有一个 SELECT 关键字，比如：  s1是驱动表，s2是被驱动表

```sql
mysql> explain select * from s1 inner join s2 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: s2
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9965
     filtered: 100.00
        Extra: Using join buffer (hash join)
```

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = 'a') \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: ALL
possible_keys: idx_key1
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: Using where
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: s2
   partitions: NULL
         type: eq_ref
possible_keys: idx_key2
          key: idx_key2
      key_len: 5
          ref: atguigudb1.s1.key1
         rows: 1
     filtered: 10.00
        Extra: Using index condition; Using where
        
 # 查询优化器可能对涉及子查询的语句进行重写
```

```sql
mysql> EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2 \G;
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: s1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 2
  select_type: UNION
        table: s2
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9965
     filtered: 100.00
        Extra: NULL
*************************** 3. row ***************************
           id: NULL
  select_type: UNION RESULT
        table: <union1,2>
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: Using temporary
 # Union取并集，去重复数据，需要在临时表中操作。
```

```sql
mysql> EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9868 |   100.00 | NULL  |
|  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9965 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+

# UNION ALL 不需要去重，所以不需要临时表
```

- **id如果相同，可以认为是一组，从上往下顺序执行**
- **在所有组中，id值越大，优先级越高，越先执行**
- **关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好**

#### 3.select_type  

一条大的查询语句里边可以包含若干个 SELECT关键字,**每个 SELECT关键字代表着一个小的查询语句**,而每个SELECT关键字的FROM子句中都可以包含若干张表(这些表用来做连接查询),**每一张表都对应着执行计划输出中的一条记录**,对于在同一个 SELECT关键字中的表来说,它们的d值是相同的。

MYSQL为每一个 SELECT关键字代表的小查询都定义了一个称之为 **select_type** l的属性,意思是我们只要知道了某个小查询的 select_type属性,就知道了这个**小查询在整个大查询中扮演了一个什么角色**,我们看一下select_type都能取哪些值,请看官方文档

![image-20231003191630756](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231003191630756.png)

- **查询语句中不包含 UNION 或者子查询的查询都是 SIMPLE 类型**：

```sql
mysql> EXPLAIN SELECT * FROM s1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9868 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+

mysql> explain select * from s1 inner join s2 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: s2
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9965
     filtered: 100.00
        Extra: Using join buffer (hash join)
```

- **对于包含 UNION 或者 UNION ALL 或者子查询的查询，由几个小查询组成，最左边的查询的值是 primary， 其他的小查询是 UNION**：

```sql
mysql> EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9868 |   100.00 | NULL  |
|  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9965 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
```

**MYSQL 使用临时表完成 UNION 查询的去重工作，对这个临时表的查询就是 UNION RESULT**。

- 子查询

如果包含子查询的查询语句不能转为对应的 semi-join 形式（多表连接），并且子查询**不是相关子查询**，该子查询的第一个 select 关键字代表的查询值就是 **SUBQUERY**。

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a' \G;
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: s1
   partitions: NULL
         type: ALL
possible_keys: idx_key3
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: Using where
*************************** 2. row ***************************
           id: 2
  select_type: SUBQUERY
        table: s2
   partitions: NULL
         type: index
possible_keys: idx_key1
          key: idx_key1
      key_len: 303
          ref: NULL
         rows: 9965
     filtered: 100.00
        Extra: Using index
2 rows in set, 1 warning (0.00 sec)
```

如果包含子查询的查询语句不能转为对应的 semi-join 形式（多表连接），并且子查询是**相关子查询**，该子查询的第一个 select 关键字代表的查询值就是 **DEPENDENT SUBQUERY**。DEPENDENT SUBQUERY的查询可能会被执行多次。

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a' \G;
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: s1
   partitions: NULL
         type: ALL
possible_keys: idx_key3
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: Using where
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: s2
   partitions: NULL
         type: eq_ref
possible_keys: idx_key2,idx_key1
          key: idx_key2
      key_len: 5
          ref: atguigudb1.s1.key2
         rows: 1
     filtered: 10.00
        Extra: Using where
```

- DEPENDENT UNION

在包含 UNION 或者 UNION ALL的查询中，如果各个小查询都依赖外层查询，除了最左边的小查询，其他小查询都是 DEPENDENT UNION。

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = 'a' UNION SELECT key1 FROM s1 WHERE key1 = 'b') \G;
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: s1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: Using where
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: s2
   partitions: NULL
         type: ref
possible_keys: idx_key1
          key: idx_key1
      key_len: 303
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using where; Using index
*************************** 3. row ***************************
           id: 3
  select_type: DEPENDENT UNION
        table: s1
   partitions: NULL
         type: ref
possible_keys: idx_key1
          key: idx_key1
      key_len: 303
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using where; Using index
*************************** 4. row ***************************
           id: NULL
  select_type: UNION RESULT
        table: <union2,3>
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: Using temporary
4 rows in set, 1 warning (0.00 sec)
```

- DERIVED

对于包含 派生表 的查询，该派生表的子查询 就是 DERIVED。

```sql
mysql> EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c > 1 \G;
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: <derived2>
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 2
  select_type: DERIVED
        table: s1
   partitions: NULL
         type: index
possible_keys: idx_key1
          key: idx_key1
      key_len: 303
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: Using index
2 rows in set, 1 warning (0.00 sec)
```

- MATERIALIZED

当查询优化器执行包含子查询的语句时，选择将子查询与外层查询进行连接查询，该子查询对于的就是 MATERIALIZED。

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: ALL
possible_keys: idx_key1
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: Using where
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: <subquery2>
   partitions: NULL
         type: eq_ref
possible_keys: <auto_distinct_key>
          key: <auto_distinct_key>
      key_len: 303
          ref: atguigudb1.s1.key1
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 3. row ***************************
           id: 2
  select_type: MATERIALIZED
        table: s2
   partitions: NULL
         type: index
possible_keys: idx_key1
          key: idx_key1
      key_len: 303
          ref: NULL
         rows: 9965
     filtered: 100.00
        Extra: Using index
3 rows in set, 1 warning (0.01 sec)

# 子查询被转为了物化表。
```

#### 4.partitions (可略)  

代表分区表中的命中情况,非分区表,该项为NULL。一般情况下我们的查询语句的执行计划的 partitions列的值都是NULL

#### 5.type *

执行计划的一条记录就代表着 MYSQL对某个表的**执行查询时的访问方法**,又称访问类型”,其中的type列就表明了这个访问方法是啥,是较为重要的一个指标。比如,看到type列的值是ref,表明MSQL即将使用ref访问方法来执行对s1表的查询。

完整的访问方法如下： **system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL 。**  

结果值从最好到最坏依次是： **system > const > eq_ref > ref** > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > **range > index > ALL** 其中比较重要的几个提取出来（见上图中的加粗）。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 const级别。  

- system：当表中**只有一条记录**，并且该表使用的引擎统计数据是精确的，例如MyISAM、Memory

```sql
mysql> CREATE TABLE t(i int) Engine=MyISAM;
Query OK, 0 rows affected (0.03 sec)

mysql> INSERT INTO t VALUES(1);
Query OK, 1 row affected (0.02 sec)

mysql> EXPLAIN SELECT * FROM t \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t
   partitions: NULL
         type: system
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: NULL
```

- const：当根据主键或者唯一的二级索引与常数进行等值匹配时，对单表的访问方法。

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE id = 10005 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: const
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
        
mysql> EXPLAIN SELECT * FROM s1 WHERE key3 = 10066 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: ALL
possible_keys: idx_key3
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 10.00
        Extra: Using where
```

- eq_ref：在连接查询中，如果被驱动表是通过主键或者唯一二级索引等值匹配方式进行访问的（如果该主键或唯一二级索引是联合索引的话，所以索引列都必须等值比较）

```sql
mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: s2
   partitions: NULL
         type: eq_ref
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: atguigudb1.s1.id
         rows: 1
     filtered: 100.00
        Extra: NULL
```

MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问方法是 eq_ref ，表明在访问s1表的时候可以 通过主键的等值匹配 来进行访问。  

- ref ： 通过普通二级索引与常量进行等值匹配查询

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: ref
possible_keys: idx_key1
          key: idx_key1
      key_len: 303
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
```

- ref_or_null：对普通的二级索引进行等值匹配，该列索引值可以为null

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key1 IS NULL \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: ref_or_null
possible_keys: idx_key1
          key: idx_key1
      key_len: 303
          ref: const
         rows: 2
     filtered: 100.00
        Extra: Using index condition
```

- index_merge ： 单表访问方法时在某些场景下可以使用 Intersection、union、sort-union 这三种索引合并的方式来执行查询

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: index_merge
possible_keys: idx_key1,idx_key3
          key: idx_key1,idx_key3
      key_len: 303,303
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: Using union(idx_key1,idx_key3); Using where
 # 查询语句中必须是 OR，不能是AND，ADN只会用一个索引
```

从执行计划的 type 列的值是 index_merge 就可以看出，MySQL 打算使用索引合并的方式来执行对 s1 表的查询  。

- unique_subquery ： 针对在一些包含子查询 的查询语句中，如果查询优化器决定将 in 子查询 转为 exists 子查询，而且子查询可以使用到主键进行等值匹配的话

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = 'a' \G;
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: s1
   partitions: NULL
         type: ALL
possible_keys: idx_key3
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: Using where
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: s2
   partitions: NULL
         type: unique_subquery
possible_keys: PRIMARY,idx_key1
          key: PRIMARY
      key_len: 4
          ref: func
         rows: 1
     filtered: 10.00
        Extra: Using where
2 rows in set, 2 warnings (0.00 sec)
```

- range： 使用索引获取某些范围区间的记录

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN ('a', 'b', 'c') \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: range
possible_keys: idx_key1
          key: idx_key1
      key_len: 303
          ref: NULL
         rows: 3
     filtered: 100.00
        Extra: Using index condition

mysql> EXPLAIN SELECT * FROM s1 WHERE key1 > 'a' AND key1 < 'b' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: range
possible_keys: idx_key1
          key: idx_key1
      key_len: 303
          ref: NULL
         rows: 371
     filtered: 100.00
        Extra: Using index condition
```

- index ： 可以使用**索引覆盖（不用回表操作就能找到数据）**，但需要扫描全部的索引记录时

```sql
mysql> EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: index
possible_keys: idx_key_part
          key: idx_key_part
      key_len: 909
          ref: NULL
         rows: 9868
     filtered: 10.00
        Extra: Using where; Using index
# key_part2 key_part3 都是联合索引idx_key_part 的一部分，利用索引去遍历一遍
```

- ALL ： 全 扫描
- fulltext  ： 全文索引

一般来说,这些访问方法中除了all这个访问方法外,其余的访问方法都能用到索引,除了 index_merge访问方法外,其余的访问方法都最多只能用到一个索引。

#### 6.possible_keys和key  

在 EXPLAIN语句输出的执行计划中, **possible_keys**列表示在某个查询语句中,对某个表执行单表查询时可能用到的索引有哪些。一般查询涉及到的字段上若存在索引,则该索引将被列出,但不一定被查询使用。**key列表示实际用到的索引有哪些**,如果为NULL,则没有使用索引。

比方说下边这个查询：

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key3 = 'a' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: ref
possible_keys: idx_key1,idx_key3
          key: idx_key3
      key_len: 303
          ref: const
         rows: 1
     filtered: 5.00
        Extra: Using where
```

#### 7.key_len *

实际使用索引的长度（字节数），帮助检测是否充分利用了索引，值越大越好（与自己比）。

```
varchar(10)变长字段且允许NULL = 10*( character set:utf8=3,gbk=2,1atin1=1)+1(NULL)+2(变长字段)
varchar(10)变长字段且不允许NULLL = 10*( character set:utf8=3,gbk=2,1atin1=1)+2(变长字段)
char(10)固定字段且允许NULL = 10*( character set: utf8=3, gbk=2, latin1=1)+1(NULL) 
char(10)固定字段且不允许NULL = 10
```

#### 8.ref 

当使用索引列等值查询时，与索引列等值匹配的对象信息。

```sql
mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: s2
   partitions: NULL
         type: eq_ref
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: atguigudb1.s1.id
         rows: 1
     filtered: 100.00
        Extra: NULL
```

#### 9.rows   *

预估需要读取的记录条数，值越小越好。

#### 10.filtered  

某个表经过搜索条件过滤后剩余记录条数满足sql要求的百分比，越大越好。如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND common_field = 'a' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: range
possible_keys: idx_key1
          key: idx_key1
      key_len: 303
          ref: NULL
         rows: 400
     filtered: 10.00
        Extra: Using index condition; Using where
```

满足key1 > 'z'的有 400条记录，并且满足common_field条件的有只有10%，即40条记录。

对单表查询来说，这个列没有什么意义，更关注 连接查询 中驱动表对应的执行计划记录的filtered值，决定了被驱动表要执行的次数（rows * filtered）

```sql
mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = 'a' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: ALL
possible_keys: idx_key1
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9868
     filtered: 10.00
        Extra: Using where
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: s2
   partitions: NULL
         type: ref
possible_keys: idx_key1
          key: idx_key1
      key_len: 303
          ref: atguigudb1.s1.key1
         rows: 1
     filtered: 100.00
        Extra: NULL
```

#### 11.Extra   *

顾名思义, Extra列是用来说明一些额外信息的,包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来更准确的**理解 MYSQL到底将如何执行给定的查询语句**。MySQ提供的额外信息有好几十个,我们就不一个—个介绍了,所以我们只挑比较重要的额外信息介绍给大家。

- No tables used：当查询语句没有from子句时携带整个额外信息。

有些搜索条件虽然出现了索引列，但是却不能使用索引；

在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，Mysql一般会为其分配一块叫 join buffer 的内存块加快查询速度，就是所说的 **基于块的嵌套循环算法**。

当我们使用左(外)连接时,如果 WHERE`子句中包含要求被驱动表的某个列等于NULL 值的搜索条件,而且那个列又是不允许存储NULL 值的,那么在该表的执行计划的 Extra列就会提示 Not exists额外信息。

如果执行计划的 Extra列出现了 Using intersect(.)提示,说明准备使用 Intersect索引合并的方式执行查询,括号中的表示需要进行索引合并的索引名称；

如果出现了 Using union(.…)提示,说明准备使用 Union索引合并的方式执行查询;出现了 Using sort union(..)提示,说明准备使用`sort-Union`索引合并的方式执行查询。

当我们的IMIT子句的参数为0时,表示压根儿不打算从表中读出任何记录,将会提示该额外信息。

很多情况下排序操作无法使用到索引,只能在内存中(记录较少的时候)或者磁盘中(记录较多的时候)进行排序, MYSQL把这种在内存中或者磁盘上进行排序的方式统称为**文件排序**(英文名: filesort)如果某个查询需要使用文件排序的方式执行查询,就会在执行计划的 Extra列中显示 Using filesort提示。

在许多查询的执行过程中,Mysql可能会借助临时表来完成一些功能,比如去重、排序之类的,比如我们在执行许多包含 DISTINCT、` GROUP BY`、 UNION等子句的查询过程中,如果不能有效利用索引来完成查询,MySL很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表,在执行计划的 Extra列将会显示 Using temporary提示。

执行计划中出现 Using temporary并不是一个好的征兆,因为建立与维护临时表要付出很大成本的,所以我们最好能使用索引来替代掉使用临时表。比如:扫描指定的索引 idx key即可。

#### 12.小结

- EXPLAIN不考虑各种Cache
- EXPLAIN不能显示MySQL在执行查询时所作的优化工作
- EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况
- 部分统计信息是估算的，并非精确值

## 七、EXPLAIN 进一步使用

### 1.四种输出格式

#### 1.传统格式  

传统格式简单明了，输出是一个表格形式，概要说明查询计划。  



#### 2.JSON格式

第1种格式中介绍的ε XPLAIN语句输岀中缺少了一个衡量执行计划好坏的重要属性一一**成本**。而JSoN格式是四种格式里面输出信息最详尽的格式,里面**包含了执行的成本信息**。

在EXPLAIN单词和真正的查询语句中间加上 **FORMAT=JSON** 。  

```sql
EXPLAIN FORMAT=JSON SELECT ....
```

![image-20231004162421178](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231004162421178.png)

```sql
mysql> EXPLAIN format=json SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = 'a' \G;
*************************** 1. row ***************************
EXPLAIN: {
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "1387.93"		# 查询成本
    },
    "nested_loop": [
      {
        "table": {
          "table_name": "s1",
          "access_type": "ALL",	
          "possible_keys": [
            "idx_key1"
          ],
          "rows_examined_per_scan": 9868,
          "rows_produced_per_join": 986,
          "filtered": "10.00",
          "cost_info": {
            "read_cost": "912.37",
            "eval_cost": "98.68",
            "prefix_cost": "1011.05",
            "data_read_per_join": "1M"	# 读取的数据量
          },
          "used_columns": [				# 呈现的字段
            "id",
            "key1",
            "key2",
            "key3",
            "key_part1",
            "key_part2",
            "key_part3",
            "common_field"
          ],
          "attached_condition": "((`atguigudb1`.`s1`.`common_field` = 'a') and (`atguigudb1`.`s1`.`key1` is not null))"									# 查询条件
        }
      },
      {
        "table": {						# 被驱动的表
          "table_name": "s2",
          "access_type": "ref",
          "possible_keys": [
            "idx_key1"
          ],
          "key": "idx_key1",
          "used_key_parts": [
            "key1"
          ],
          "key_length": "303",
          "ref": [
            "atguigudb1.s1.key1"
          ],
          "rows_examined_per_scan": 1,
          "rows_produced_per_join": 1076,
          "filtered": "100.00",
          "cost_info": {
            "read_cost": "269.20",
            "eval_cost": "107.68",
            "prefix_cost": "1387.93",
            "data_read_per_join": "1M"
          },
          "used_columns": [
            "id",
            "key1",
            "key2",
            "key3",
            "key_part1",
            "key_part2",
            "key_part3",
            "common_field"
          ]
        }
      }
    ]
  }
}
```

```json
"cost_info": {
            "read_cost": "912.37",
            "eval_cost": "98.68",
            "prefix_cost": "1011.05",
            "data_read_per_join": "1M"
          }
```

**read_cost** 是由下边这两部分组成的：  

- IO 成本  
- 检测 rows × (1 - filter) 条记录的 CPU 成本  

rows和filter都是我们前边介绍执行计划的输出列，在JSON格式的执行计划中，rows相当于rows_examined_per_scan，filtered名称不变。  

**eval_cost** 是这样计算的：  检测 rows × filter 条记录的成本。  

**prefix_cost** 就是单独查询 s1 表的成本，也就是  read_cost + eval_cost  

**data_read_per_join** 表示在此次查询中需要读取的数据量  。

对于 s2 表的 "cost_info" 部分是这样的 ，由于 s2 表是被驱动表，所以可能被读取多次，这里的 read_cost 和 eval_cost 是访问多次 s2 表后累加起来的值，大家主要关注里边儿的 prefix_cost 的值代表的是整个连接查询预计的成本，也就是单次查询 s1 表和多次查询 s2 表后的成本的和，也就是：  269.20 + 107.68  + 1011.05 = 1387.93



#### 3.TREE格式

TREE格式是8.0.16版本之后引入的新格式，主要根据查询的 **各个部分之间的关系 和 各部分的执行顺序** 来描述如何查询  。

在EXPLAIN单词和真正的查询语句中间加上 **FORMAT=TREE**

```sql
mysql> EXPLAIN format=tree SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = 'a' \G;
*************************** 1. row ***************************
EXPLAIN: -> Nested loop inner join  (cost=1387.93 rows=1077)
    -> Filter: ((s1.common_field = 'a') and (s1.key1 is not null))  (cost=1011.05 rows=987)
        -> Table scan on s1  (cost=1011.05 rows=9868)
    -> Index lookup on s2 using idx_key1 (key1=s1.key1)  (cost=0.27 rows=1)
```



#### 4.可视化格式

可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。通过点击Workbench的放大镜图标，即可生成可视化的查询计划。  

### 2.SHOWWARNINGS的使用

在我们使用 EXPLAIN语句查看了某个查询的执行计划后,紧接着还可以使用 SHOW WARNINGS语句查看与这个查询的执行计划有关的一些扩展信息,比如这样：

```sql
mysql> EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: s2
   partitions: NULL
         type: ALL
possible_keys: idx_key1
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9965
     filtered: 90.00
        Extra: Using where
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: s1
   partitions: NULL
         type: ref
possible_keys: idx_key1
          key: idx_key1
      key_len: 303
          ref: atguigudb1.s2.key1
         rows: 1
     filtered: 100.00
        Extra: Using index
2 rows in set, 1 warning (0.00 sec)

mysql> show warnings \G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `atguigudb1`.`s1`.`key1` AS `key1`,`atguigudb1`.`s2`.`key1` AS `key1` from `atguigudb1`.`s1` join `atguigudb1`.`s2` where ((`atguigudb1`.`s1`.`key1` = `atguigudb1`.`s2`.`key1`) and (`atguigudb1`.`s2`.`common_field` is not null))
1 row in set (0.00 sec)
```

大家可以看到 SHOW WARNINGS展示出来的信息有三个字段,分别是Level、Code、 Message。常见的就是code为1003的信息,当Code值为1003时, Message字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左(外)连接查询,但是有一个s2.common_field Is NOT null的条件,这就会导致查询优化器把左(外)连接查询优化为内连接查询,从 SHOW WARNINGS的 Message字段也可以看出来,原本的 LEFT JOIN已经变成了join。

## 八、分析优化器执行计划：trace  

**0PTIMIZER_ TRACE**是 MYSQL5.6引入的一项跟踪功能,它可以跟踪优化器做岀的各种决策(比如访问表的方法、各种开销计算、各种转换等),并将跟踪结果记录到 **INFORMATION_SCHEMA. OPTIMIZER_TRACE**表中。

此功能**默认关闭**。开启 trace,并设置格式为JSON,同时设置 trace最大能够使用的内存大小,避免解析过程中因为默认内存过小而不能够完整展示。

```sql
SET optimizer_trace="enabled=on",end_markers_in_json=on;
set optimizer_trace_max_mem_size=1000000;
```

开启后，可分析如下语句 ：

- SELECT
- INSERT
- REPLACE
- UPDATE
- DELETE
- EXPLAIN 
- SET 
- DECLARE 
- CASE 
- IF 
- RETURN 
- CALL

例子：

```sql
mysql> select * from student where id < 10;
+----+--------+--------+------+---------+
| id | stuno  | name   | age  | classId |
+----+--------+--------+------+---------+
|  1 | 100002 | WsbaYQ |   25 |     435 |
|  2 | 100003 | JQnQpa |   29 |     998 |
|  3 | 100004 | sQXtZR |   25 |     366 |
|  4 | 100005 | puemWX |   94 |     812 |
|  5 | 100006 | nTJAFD |   96 |     105 |
|  6 | 100007 | JQlJyA |   21 |     110 |
|  7 | 100008 | gqmmwA |   29 |     531 |
|  8 | 100009 | axmQvF |   83 |     208 |
|  9 | 100010 | EqPcRd |   84 |     875 |
+----+--------+--------+------+---------+
```

查询 information_schema.optimizer_trace 就可以知道MySQL是如何执行SQL的 ：  

```json
*************************** 1. row ***************************
//第1部分：查询语句
QUERY: select * from student where id < 10
//第2部分：QUERY字段对应语句的跟踪信息
TRACE: {
"steps": [
{
"join_preparation": { //预备工作
"select#": 1,
"steps": [
{
"expanded_query": "/* select#1 */ select `student`.`id` AS
`id`,`student`.`stuno` AS `stuno`,`student`.`name` AS `name`,`student`.`age` AS
`age`,`student`.`classId` AS `classId` from `student` where (`student`.`id` < 10)"
}
] /* steps */
} /* join_preparation */
},
{
"join_optimization": { //进行优化
"select#": 1,
"steps": [
{
"condition_processing": { //条件处理
"condition": "WHERE",
"original_condition": "(`student`.`id` < 10)",
"steps": [
{
"transformation": "equality_propagation",
"resulting_condition": "(`student`.`id` < 10)"
},
{
"transformation": "constant_propagation",
"resulting_condition": "(`student`.`id` < 10)"
},
{
"transformation": "trivial_condition_removal",
"resulting_condition": "(`student`.`id` < 10)"
}
] /* steps */
} /* condition_processing */
},
{
"substitute_generated_columns": { //替换生成的列
} /* substitute_generated_columns */
},
{
"table_dependencies": [ //表的依赖关系
{
"table": "`student`",
"row_may_be_null": false,
"map_bit": 0,
"depends_on_map_bits": [
] /* depends_on_map_bits */
}
] /* table_dependencies */
},
{
"ref_optimizer_key_uses": [ //使用键
] /* ref_optimizer_key_uses */
},
{
"rows_estimation": [ //行判断
{
"table": "`student`",
"range_analysis": {
"table_scan": {
"rows": 3973767,
"cost": 408558
} /* table_scan */, //扫描表
"potential_range_indexes": [ //潜在的范围索引
{
"index": "PRIMARY",
"usable": true,
"key_parts": [
"id"
] /* key_parts */
}
] /* potential_range_indexes */,
"setup_range_conditions": [ //设置范围条件
] /* setup_range_conditions */,
"group_index_range": {
"chosen": false,
"cause": "not_group_by_or_distinct"
} /* group_index_range */,
"skip_scan_range": {
"potential_skip_scan_indexes": [
{
"index": "PRIMARY",
"usable": false,
"cause": "query_references_nonkey_column"
}
] /* potential_skip_scan_indexes */
} /* skip_scan_range */,
"analyzing_range_alternatives": { //分析范围选项
"range_scan_alternatives": [
{
"index": "PRIMARY",
"ranges": [
"id < 10"
] /* ranges */,
"index_dives_for_eq_ranges": true,
"rowid_ordered": true,
"using_mrr": false,
"index_only": false,
"rows": 9,
"cost": 1.91986,
"chosen": true
}
] /* range_scan_alternatives */,
"analyzing_roworder_intersect": {
"usable": false,
"cause": "too_few_roworder_scans"
} /* analyzing_roworder_intersect */
} /* analyzing_range_alternatives */,
"chosen_range_access_summary": { //选择范围访问摘要
"range_access_plan": {
"type": "range_scan",
"index": "PRIMARY",
"rows": 9,
"ranges": [
"id < 10"
] /* ranges */
} /* range_access_plan */,
"rows_for_plan": 9,
"cost_for_plan": 1.91986,
"chosen": true
} /* chosen_range_access_summary */
} /* range_analysis */
}
] /* rows_estimation */
},
{
"considered_execution_plans": [ //考虑执行计划
{
"plan_prefix": [
] /* plan_prefix */,
"table": "`student`",
"best_access_path": { //最佳访问路径
"considered_access_paths": [
{
"rows_to_scan": 9,
"access_type": "range",
"range_details": {
"used_index": "PRIMARY"
} /* range_details */,
"resulting_rows": 9,
"cost": 2.81986,
"chosen": true
}
] /* considered_access_paths */
} /* best_access_path */,
"condition_filtering_pct": 100, //行过滤百分比
"rows_for_plan": 9,
"cost_for_plan": 2.81986,
"chosen": true
}
] /* considered_execution_plans */
},
{
"attaching_conditions_to_tables": { //将条件附加到表上
"original_condition": "(`student`.`id` < 10)",
"attached_conditions_computation": [
] /* attached_conditions_computation */,
"attached_conditions_summary": [ //附加条件概要
{
"table": "`student`",
"attached": "(`student`.`id` < 10)"
}
] /* attached_conditions_summary */
} /* attaching_conditions_to_tables */
},
{
"finalizing_table_conditions": [
{
"table": "`student`",
"original_table_condition": "(`student`.`id` < 10)",
"final_table_condition ": "(`student`.`id` < 10)"
}
] /* finalizing_table_conditions */
},
{
"refine_plan": [ //精简计划
{
"table": "`student`"
}
] /* refine_plan */
}
] /* steps */
} /* join_optimization */
},
{
"join_execution": { //执行
"select#": 1,
"steps": [
] /* steps */
} /* join_execution */
}
] /* steps */
} /
/第3部分：跟踪信息过长时，被截断的跟踪信息的字节数。
MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0 //丢失的超出最大容量的字节
//第4部分：执行跟踪语句的用户是否有查看对象的权限。当不具有权限时，该列信息为1且TRACE字段为空，一般在
调用带有SQL SECURITY DEFINER的视图或者是存储过程的情况下，会出现此问题。
INSUFFICIENT_PRIVILEGES: 0 //缺失权限
1 row in set (0.00 sec)
```

## 九.MySQL监控分析视图-sys schema  

关于Mysα的性能监控和问题诊断,我们一般都从 performance_ schema中去获取想要的数据,在MSQL5.7.7版本中新增 sys schema,它将 performance_ schema和 Information_ schema中的数据以更容易理解的方式总结归纳为”视图”,其目的就是**为了降低查询 performance_ schemal的复杂度**,让DBA能够快速的定位问题。下面看看这些库中都有哪些监控表和视图,掌握了这些,在我们开发和运维的过程中就起到了事半功倍的效果。

### 1.Sys schema视图摘要  

![image-20231004165359621](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20231004165359621.png)

### 2.Sys schema视图使用场景  

**索引情况**  

```sql
#1. 查询冗余索引
select * from sys.schema_redundant_indexes;
#2. 查询未使用过的索引
select * from sys.schema_unused_indexes;
#3. 查询索引的使用情况
select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted
from sys.schema_index_statistics where table_schema='dbname' ;
```

**表相关**  

```sql
# 1. 查询表的访问量
select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from
sys.schema_table_statistics group by table_schema,table_name order by io desc;
# 2. 查询占用bufferpool较多的表
select object_schema,object_name,allocated,data
from sys.innodb_buffer_stats_by_table order by allocated limit 10;
# 3. 查看表的全表扫描情况
select * from sys.statements_with_full_table_scans where db='dbname';
```

**语句相关**  

```sql
#1. 监控SQL执行的频率
select db,exec_count,query from sys.statement_analysis
order by exec_count desc;
#2. 监控使用了排序的SQL
select db,exec_count,first_seen,last_seen,query
from sys.statements_with_sorting limit 1;
#3. 监控使用了临时表或者磁盘临时表的SQL
select db,exec_count,tmp_tables,tmp_disk_tables,query
from sys.statement_analysis where tmp_tables>0 or tmp_disk_tables >0
order by (tmp_tables+tmp_disk_tables) desc;
```

**IO**

```sql
#1. 查看消耗磁盘IO的文件
select file,avg_read,avg_write,avg_read+avg_write as avg_io
from sys.io_global_by_file_by_bytes order by avg_read limit 10;
```

**Innodb 相关  **

```sql
#1. 行锁阻塞情况
select * from sys.innodb_lock_waits;
```

通过sys库去查询时,MQL会消耗大量资源去收集相关信息,严重的可能会导致业务请求被阻塞,从而引起故障。建议生产上不要频繁的去查询sys或者 performance_schema、 information schema来完成监控、巡检等工作。