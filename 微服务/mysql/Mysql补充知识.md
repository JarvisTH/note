## 一、存储引擎

## 1.InnoDB存储引擎的内存结构

Innodb存储引擎架构主要由两部分组成,内存结构和磁盘结构

![image-20240407151234646](../../../../picbed/store/picbed/img/image-20240407151234646.png)

InnoDB存储引擎的**内存结构**由4部分组成：

1. Buffer poo:缓冲池,作用就昰用来缓存表数据和索引数据,减少磁盘iO操作,提升效率。
2. Change Buffer:写缓冲区,是针对二级索引页(辅助索引)的更新优化措施。
3. Log Buffer:日志缓冲区,用来缓存写入磁盘上log文件( Redoi Undo)的数据,日志缓冲区的内容会定期的刷新到磁盘Log文件中。主要作用是:用来优化每次更新操作之后都要写入 redo log产生的磁盘iO的
4. Adaptive Hash Index:自适应Hash索引。 nno DB不支持手动创建哈希索引的,但是 node会进行自调优,如果判断建立自适应哈希索引能够提升查询效率,IηnoDB就会在自己的內存中创建相关的Hash索引。自适应指的是不需要人工手动干预,IηηoDB会根据自己的需求去创建自适应Hash索引。



## 2.buffer pool如何管理page页

Page页分类:在BP的底层采用的是链表数据结构管理Page。

Page根据状态可以分为3中类型

1) free Page:空闲Page,未被使用的Page。
2) Clean Page:被使用的Page,但是数据没有修改过。
3) dirty Page:脏页,被使用过的Page,并且数据被修改了,缓存页中的数据与磁盘的数据不一致的。

free list流程：

- 从free链表中获取空闲控制块
- 把缓存验对应的控制块信息填上
- 把缓存页对应free节点移除

flush list：存储脏页，被修改过的缓存页对应的控制块，加入到该list，等待刷盘。

lru list：表示正在使用的缓冲区，管理clean page和dirty page的可用性和释放，前面的链表（63%，new区域）存放经常被访问的数据，后面的链表存放较少使用的数据（old 区域）。

## 3.mysql使用的LRU与传统LRU的区别

普通LRU：最近最少使用，头插法（存在/不存在访问后都放入头部），末尾淘汰

缺点：

- buffer pool污染，某个sql扫描大量数据可能把bp中所有页都替换出去，大量热数据被淘汰，再次访问时产生大量磁盘io。
- 预读失效

改进后LRU：加入元素不是从表头插入，从midpoint插入（old区域头部）。访问该页，会把该页插入new区域头部，new区域最后一个页进入old区域头部。

冷数据区的数据页什么时候转入热数据？

- 只有同时满足【被访问】与【在old区域停留超过1s】两个条件,才会被插入到热数据区的头部。

## 4.Change buffer是什么，为什么只适用于辅助索引

change buffer：写缓冲区，针对二级索引页的更新优化措施。在进行DML操作时，如果请求辅助索引（非唯一索引）且**没有在缓冲池中**，首先把DML变更操作缓存中change buffer中，后面数据被读取时再将数据合并到BP。占用BP的空间，默认占用25%，最大50%，使用写多读少场景。

**触发merge**：

- 访问数据页时触发merge
- 系统后台线程定时merge
- 数据库正常关闭时merge

**change buffer更新流程**：

情况1:对于唯一索引来说,需要将数据页读入内存,判断有没有冲突,插入这个值,语句执行结束。在做唯一性校验时就把数据加入内存了，操作使用不到change buffer

情况2:对于普通索引来说,则是将更新操作缓存在 change Buffer

![image-20240402111736500](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20240402111736500.png)

## 5.自适应hash索引如何提高查询效率

AHI所作用的目标是频繁査询的数据页和索引页,而由于数据页是聚簇索引的一部分,因此AHI是建立在索引之上索引。

对于二级索引,如果命中AH,则将直接从AHI中获取二级索引也的记录指针,再根据主键沿着聚簇索引查询数据。

对于聚簇索引,如果聚簇索引查询命中AHI,则直接返回目标数据页的记录指针,此时就可以根据记录指针直接定位数据页。

MYSQL运行过程中,如果发现,有很多寻路很长(B+树层数太多,回表次数多)SQL,有很多SQL会命中相同的页Innodb就会在自己的内存缓冲区BP中,开辟一块区域,建立自适应哈希索引,加速查询。

Hash数据结构都是包含键(key)值( value)de在AHl,key就是经常访问的索引键值, value就是该索引键值匹配的完整记录所在的页面page位置。

## 6.InnoDB磁盘结构表空间作用

![image-20240403150800545](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20240403150800545.png)

表空间：InnoDB物理存储中的最高层

系统表空间：

 - 查看物理表空间文件ibdata， 是一个共享表空间，该空间的数据文件默认是ibdata1。
 - 数据字典：包含表结构、数据库名、表名、字段等元数据信息
 - 双写缓冲区：保证写入磁盘时页数据的完整性，防止发生写失效
 - 修改缓冲区：内存中change buffer对应的持久化区域，保证数据完整性
 - 回滚日志：记录数据修改前的状态，逻辑日志，主要实现事务回滚、MVCC

独立表空间：

	- 每个表都有自己h独立表空间，每个表数据和索引都存在自己的表空间中。
	- 作用是可以实现单表在不同数据库中的移动。独立表空间的空间可以回收(在执行删除或者清空操作后,存储空间会还给操作系统)

通用表空间：

	- 共享表空间，可以存储多个表数据，消耗内存更少，磁盘占用少
	- create tablespace gen-space add datafile ‘gen-space.ibd' file_block_size=16384;

回滚表空间：

- 保存回滚日志，默认保存在系统表空间ibdata中。
- undo 独立表空间设置：%innodb_undo_tablespace% = 0,什么时候需要开启undo表空间？
  - 由于系统表空间是不会自动缩减的,当出现大事务时候,undo日志不断增data1文件也会不断增大。
  - MYSQL.5.7引入了新的参数%innodb_undo_log_truncate%':可以设置表空间文件名的个数,要大于2,当有一个写满时,就会缩减,向另外—个文件继续写入。
  - MYSQL8.0开始,对Undo进行了分离,默认就会产生两个undo表空间文件,进行动态的扩容和收缩。

临时表空间：

- 存储用户创建的临时表和磁盘内部的临时表空间

- 5.7开始采用独立的临时表空间，命名ibtmp文件，默认无上限。

- 设置临时表大小：参数：tmp_table_size

- 如何监控临时表与临时表空间的使用情况：

  ![image-20240403153251949](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20240403153251949.png)

  

created_tmp_disk_tables / created_tmp_tables 不要超过0.25，超过可以加大tmp_table_size。

## 7.什么是写失效，Mysql如何解决写失效问题？

**什么是写失效?**

Linux文件系统页( OS Page)默认大小是**4KB,**而 MYSQLE的页(Page)默认大小是**16KB**。INNODBE的页和操作系统的页的大小不ー致, INNODBE的页写入磁盘时就需要分4次来写这时候,存在一种情况:

如果存储引擎正在写入的页的数据到磁盘时发生了宕机,这时如果我们只是写了一部分页,比如写4K,就宕机,这种情况就被叫做**写失效**,可能会导致数据的丢失,并且这种页数据的损坏,靠 redolog是无法恢复的。

**双写缓冲区 Doublewrite buffer**

双写缓冲区的岀现就是为了解决写失效问题。为IηnoDB存储引擎提供数据页的可靠性。

![image-20240403154106184](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20240403154106184.png)

- 内存结构: Doublewrite buffer,内存结构是由126个Page页构成的,大小是2MB
- 磁盘结构:DB磁盘结构是在系统表空间上128页,大小2MB

**数据双写的流程**:

在BP的Page页刷新到磁盘真正的位置之前,会将数据存储在 Doublewrite缓冲区。这样如果岀现宕机重启的情况,数据页被损坏了,那么就会在应用 Redo Log之前,需要通过该页的副本来还原该页,然后再进行 redo Log的重做, Double write实现了 Innodb引擎数据页的可靠性。

![image-20240403154844298](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20240403154844298.png)

双写：第一次写入系统表空间Doublewrite缓冲区，第二次写入数据文件ibd中。第一次顺序写入比较快，第二次离散写入，由于有完整副本存在，可以保证避免写失效。

Doublewrite和 redo Log：

​	在MySqL的 Innodb存储引擎中,Double write和 redo Log配合工作,确保数据的持久性和恢复能力。

**DML操作-> log buffer->如果直接把这些修改的页写到磁盘,可能会出现写失效的冋题**

**为了避免这个问题-->先写到 Doublewrite Buffer-->然后再写到磁盘数据文件**

**--》最后当事务提交时,即使系统崩溃了, redo Log也可以用重播事务来恢复**

**在恢复的过程中:如果存在损坏的数据页,那么 node就会去双写缓冲区中,找副本尝试恢复损坏的数据页。**

Doublewrite buffer相关参数,以下是一些与 Doublewrite buffer相关的参数及其含义：

1) innodb doublewrite:这个参数用于启用或禁用双写冲区。设置为1时启用,设置为0时禁用,默认值为1
2)  innodb doublewrite files:这个参数定义了多少个双写文件被使用。默认值为2,有效范围从2到127。
3)  innodb doublewrite_dir:这个参数指定了存储双写缓冲文件的目录的路径。默认为空字符串,表示将文件存储在数据目录中。
4)  innodb doublewrite_ batch size:这个参数定义了每次批处理操作写入的字节数。默认值为o,表示iηnoDB会选择最佳的批量大
5)  innodb_doublewrite_pages:这个参数定义了每个双写文件包含多少页面。默认值为128。

## 8.Mysql中脏页落盘机制

脏页:脏页指的就是修改了 Buffer poc中的数据页后,导致内存中的缓存页和磁盘上的数据页不一致了,这时候就岀现了脏页。

修改数据页时:首先修改缓冲池中的页,然后再以一定的频率刷新到磁盘上。脏页从缓冲池刷新到磁盘的操作,并不是在毎次发生更新的时候就触发,而是通过一种称为 **checkpoint机制**,刷新回磁盘。

redo log可能出现的问题：

- 缓冲池不是无限大的,也就是说不能够一直存储数据,而不去刷新磁盘。
- redo Log是循环使用,也不是无限大,所以 redo Log写满了怎么办?
- 当数据库运行了几个月甚至几年的时候后,这是数据库宕机了,重新应用 redolog,这个过程是会非常耗时,恢复的成本非常高。

checkpoint机制解决上面3个问题：

1)缓冲池不够用的时候,将脏页刷新到磁盘：当缓冲池中的空间无法存放新读取的页,这个时候lηoDB存储引擎就会迸行页的淘汰。使用LR∪算法,当缓冲池中的空间无法读取新的页的时候,将淘汰LRU链表尾部的页,如果这个被释放的页是脏页,就需要强制执行 checkpoint,将脏页刷新到磁盘。

2)重做日志不够用的,将脏页刷新到磁盘：

- 日志组概念
  - MYSQL为了优化磁盘持久化的开销,会有一个组提交( group commit)的机制。
  - 每个 node存储引擎,至少有一个重做日志文件组,每个文件组下面,至少有两个 redolog文件
  - 事务日志组的路径,当前目录是指的 MYSQL数据目录为日志组目录，%innodb_log_group%
  - 事务日志组事务日志文件个数，默认2个，%innodb_log_files%；每个日志大小，默认48M，总和最大512G，%innodb_log_file_size%
  - checkpoint机制就是把缓冲池中的脏页刷入磁盘。详细参考笔记redo log中的check point机制。

3)缩短数据库恢复的时间：当数据库发生宕机的时候,数据库不需要重做所有的日志,因为 checkpoint之前的页都是已经刷新回磁盘了。所以数据库只需要针对checkpoint后的 redolog进行恢复就可以了,这样减少了恢复的时间。

Checkpoint分为两种：

- sharp checkpoint:强制落盘。把内存中所有的脏页都执行落盘操作。只有当关闭数据库之前才会执行。
- Fuzzy checkpoint:模糊落盘。把一部分脏页执行落盘操作,分为四种。
  - Master Thrad Checkpoint:主线程定时将脏页写入磁盘,每秒或每10s执行一次脏页。
  - FLUSH LRU LIST buffer:poo有脏页换出,执行落盘。
  - Async./ Sync Flush checkpoint:当 redo log快写满的时候执行落盘。
    - 当 redo logi超过75%小于90%会执行异步落盘
    - 当 redo log超过90%,会执行同步落盘操作。会阻塞写操作。 
  - Dirty Page too much checkpoint:如果 buffer pool中脏页太多,脏页率超过75%执行落盘。

## 9.InnoDB后台线程

后台线程主要作用：

- 负责刷新内存池中的数据,保证缓冲池中缓存的数据都是最近的数据。
- 将内存中已经修改的数据文件,进行刷新,刷新到磁盘文件。

IO线程：

- read thread：负责读取操作，将磁盘数据页从磁盘加载到内存，4个。
- write thread：将缓存脏页刷新到磁盘，4个。
- log thread：将日志缓冲区的内容刷新到磁盘，1个。
- insert buffer thread：将缓冲区内容刷新到磁盘，1个。

**purge thread**：在事务提交之后，其使用的undo日志就不需要了，该线程会回收以及分配的undo页，默认4个，加快回收速度。

page cheaner thread：将脏页数据刷新到磁盘，刷盘之后对应的redo log也可以被覆盖，既可以同步数据，又可以达到redolog循环使用目的。

master thread：负责调度其他线程，内部由两种操作方式：

- 每隔1s：
  - 刷新脏页数据到磁盘,当脏页比例达达75%才进行
  - 合并写缓冲区数据:并不是毎秒刷新,如果前一秒的次数小于5,就认为IO压力比较小,才会去执行合并插入缓冲的操作。
  - 刷新日志缓冲区到磁盘：即使事务没有提交, innodb也会每秒将重做日志缓冲刷新到重日志文件中。
- 每隔10s：
  - 刷新脏页数据到磁盘
  - 合并写缓冲区数据
  - 刷新日志缓冲区
  - 删除无用undo

## 10.innodb的逻辑存储结构

![image-20240405160141692](../../../../picbed/store/picbed/img/image-20240405160141692.png)

![image-20240405160205249](../../../../picbed/store/picbed/img/image-20240405160205249.png)

## 11.行溢出

行格式分类：

表的行格式决定了它的行是如何进行物理存储的,反过来说行格式的选择会影响到査询和DML操作的性能。

希望在单个Page中能够容纳更多的行,査询和索引査找就可以更快的工作,缓冲池中所需的内存更少,写入更新的时候所需lO更小。

Innodb存储引擎支持四种行格式：

- redundan：淘汰，5.0前
-  compact：经常使用
- dynamic：默认值，可以进行数据压缩
- compressed：更加节省空间

```sql
create table name ROW_FORMAT=行格式名称
```

**compact行溢出机制**：

- 什么是行溢出？

如果某些字段的信息过长,无法存储在β树的节点中,这时候会被单独分配空间,此时这个页被称为溢串页,这种现象就被称为**行溢出**。

Page=16KB   16384字节,一个 varchar类型列最多可以存储65532个字节,一个页就无法存储这个 varchar类型的列。如果一个表有这样一个大字段,一个页就无法存储一条完整的记录,这时候就会发行溢出,多出的数据就在溢出页中。

- **行溢出机制**

当发生行溢出的时候,数据页只保存前768个字节的前缀数据,以及溢出页地址,指向行溢出页。

![image-20240405161248589](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20240405161248589.png)

dynamic与compressed在处理行溢出时，数据页不会存储真实数据的前768字节，完全溢出到溢出页中，只保留指针指向溢出页。

## 二、索引与查询优化

## 1.一棵B+数可以存放多少数据

1.计算根节点指针数:假设表的主键是int类型,占用的就是4个字节,指针的大小为6个字节,一个页大概可以存储:16384B/(4B+6B）= 1638,一个节点最多可以存储1638个索引指针。

2.计算叶子节点的能够存储的记录数:假设一行记录的数据大小1KB,那么一页就可以存储16行数据。16KB/1KB=16

3.一颗高度为2的B+Tree可以存放的记录为

1638*16=26208条数据记录,同样的方式就可以推算出高度3的B+Tree可以存放:1638 * 1638 * 16=42938704,可以存放4000多万条的数据

4.所以 InnoDB中**B+Tree高度一般就是1-3层**,就可以满足干万级别的数据的存储,在査找数据的时候一次页的査找代表一次O,所以通过主键索引査询通常情况只需要1-3次io操作就可以查到数据。

## 2.索引下推

![image-20240405162614066](../../../../picbed/store/picbed/img/image-20240405162614066.png)

![image-20240405162631815](../../../../picbed/store/picbed/img/image-20240405162631815.png)

总结:如果没有索下推优化,当进行索引査询时,首先要根据索引来查找记录,然后再根据 where条件进行过滤,得到想要的数据。在支持ICP之后,MysQL在取出索引的同时,判断是否可以进行 where条件过滤,再进行索引查询,如果可以就提前进行过滤,在某些场景下可以大大的减少回表的次数,提升数据库性能。

## 3.三星索引

对于一个查询而言,一个三星索引,可能是其最好的索引。三星要满足的条件如下：

1.一星:索引将相关的记录放在一起,可以获得一星。如果一个査询相关的索引行是相邻的或者距离相对较近,必须要扫描的索引片的宽度就会缩短,扫描的范围就变小了。

2.二星:如果索引中的数据顺序和査找中的排列顺序一致的,就获得二星(排序星」在满足一星的情况下,当查询需要排序时,排序字段是有索引的,索引本身是有序的,就不需要另外排序。

3.三星:如果索引中包含了查询所要的所有数据列,就获得第三颗星在使用到了覆盖索引的情况下,查询不需要回表了,查询性能得到提升

## 4.哪些情况导致sql语句查询性能下降

**原因1:请求了不需要的数据**,可以细分为3中情况：

- 查询了不需要的记录

  ```sql
  explain select * from  order limit 10000, 10;
  ```

  对于上面的sql，实际情况是 MYSQL会查询出全部的结果集,客户段会接受这些结果集,抛弃大部分不需要的数据。

- 总是取出全部的列：取岀全部的列,会让优化器无法完成索引覆盖扫描,还会带来额外的开销,比如增加iO、内存的消耗。 select * 最好不用。
- 重复查询相同的数据：不断重复执行相同的査询,然后每次返回完全相同的数据,这也是比较消耗资源的。最好使用缓存。

**原因2:扫描了过多的额外记录**。可以根据查询开销的三个指标进行判断：

- 响应时间。
  - 服务时间+排队时间=响应时间
  - 服务时间指的是数据库处理这个查询所花费的时间。
  - 排队时间等待某些资源被释放,所耗费的时间
- 扫描的行数和返回的行数。
  - 理想情况下扫描的行数和返回的行数应该相同,实际呢这种情况并不多,例如在一个关联査询时,服务器就必须要扫描多行才能生成结果集中的一行
- 扫描的行数和返回的类型。
  - 依据 Explain给出的诊断结果中type列,来去进行查询开销的判断:全变扫描-->索引扫描->范围扫描->唯一索引査询->常数引用，扫描行数从小到大
  - 如果type的值处在一个不合格的区间,最好的解决办法就是创建一个合适的索引

## 5.慢查询优化

思路：

- 优先选择优化高并发执行的SQL,因为高并发的SQL发生问题带来的后果比较严重。比如下面两种情况：
  - SQL1:每小时执行10000次,每次有20个|O,优化之后每次18个0,每小时节省2万次|O。
  - SQL2:每小时执行10次,每次20000个O,优化后每次减少2000个O,每小时节省2万次O。
  - SQL2更难与优化,SQL1比较好优化。但是SQL2属于高并发SQL,更加急需优化。
- 定位优化对象的性能瓶颈,在去优化SQL时,优化的方向分为三个：
  - IO(数据访问消耗的时间太多了,查看是否正确的使用了索引)。
  - CP∪(数据运算花费了太多的时间,数据的运算分组排序是不是有问题)
  - 网络带宽(考虑增加网络带宽)。
- 明确优化的目标
  - 需要根据数据库当前的状态。
  - 数据库与该条SQL关系。
  - 当前SQL的功能
  - 最好的情况消耗的资源,最坏的情况消耗的資源。
  - 优化的结果只有一个,就是给用户一个好的体验。
- 从 Explain入手
  - 只有 Explain能告诉你,当前SQL的执行状态。
- 永远用小的结果集驱动大的结果集
  - 减少内层表读取的次数。
  - 尽可能在索引中完成排序。
  - 只获取自己需要的列。
  - 只使用最有效的过滤条件。
- 尽量避免复杂的join和子查询
  - 每条SQL的ON操作,建议不要超过三张表。
  - 可以将复杂的SQL,拆分为小的单个表的SQL来执行,获取结果,在程序中进行封装。

## 三、事务与锁机制

## 1.线上修改大表结构风险

在线修改大表结构可能产生的影响

- 在线修改大表结构时,执行的时长往往是不可预估,一般时间都是比较长的。
- 由于修改表结构操作是表级锁,因此在修改表结构时,就会影响到写入操作。
- 如果长时间的修改表结构,中途修改失败,由于修改表结构是一个事务,因此失败是还原表结构,在还原的期间,是一直锁表的状态不允许写入
- 修改大表的结构容易导致数据库的PU和io等性能的消耗,使 MYSQLI服务性能下降。
- 在修改大表结构时容易导致主从的延时,从而影响业务读取。

修改方式：

- 对表加锁(表此时只读）
- 复制原表的物理结构
- 修改表的物理结构
- 把原表数据导入到中间表,数据同步完成后,锁定中间表,并删除原表
-  rename中间表为原表
- 刷新字典表，释放锁

## 2.Innodb行锁如何优化

合理运用 Innodb行级锁,应该做好以下几点:

1.尽可能的让所有的数据检索都通过索引完成,避免 Innodb因为无法对索引键加锁,导致升级为行级锁的问题。

2.合理的设计索引,让 innodb在索引键加锁的时候准确度更髙,锁定的范围更小,避免因为锁定导致影响其他的査询操作。

3.尽可能的减少基于范围的数据检索,避免因为间隙锁带来的负面影响,锁定了一些不应该锁定的记录

4.尽可能的控制事务的大小,减少锁定的资源量和锁定的时间长度。

5.在业务允许的情况下,尽量选择使用较低的事务隔离界别,减少MySαL因为实现事务隔离级别所带来的附加成本。查询系统中行锁的使用情况

![image-20240405170035565](../../../../picbed/store/picbed/img/image-20240405170035565.png)

## 3.cont(列名)、count(*)、count(1)

执行效果上：

-  count(*)包括了所有的列,在统计的时候不会忽略列值为nu的数据。*
- count(1)用1表示代码行,在统计时不会忽略列值为nu的数据。
- count(列名)在统计时,会忽略值为null 的数据,就是说某个字段的值为null 时就不统计

执行效率上看:

- innodb存储引擎: count(字段)< count(1)= count( * )
  - Innodb通过遍历最小的可用的二级索引来处理 select count( * )语句,如果二级索引不存在,则通过扫描聚簇索引来处理
  - Innodb是以同样的方式区处理 count(1)和 count( * )
- MYISAN存储引擎: count字段)< count(1)<= count( * )
  - MYISAM存储量数据的准确的行数,使用 count( * )直接返回总行数，优先寻找count( * ),再者count（1）
- count(列名)会遍历整个表,但是不同的是,会先获取列,然后判断是否为空,然后再累加,因此 count(列名)不如前两者。

## 4.分页查询优化

一般的分页查询使用limit关键来实现。

情况1:如果偏移量是固定,返回的记录数昰变化的,返回的记录数不断增加,对执行的效率有什么影响吗?

```sql
select from user limit 1000,1；
select from user limit 1000,10:
select from user limit 1000,100;
select from user limit 1000,1000;
```

结论:在查询记录时,返回的记录量低于100条,查询的时间是基本没有变化的。但是随着査询的记录量越大,所花费的时间也就越多。

情况2: 如果査询偏移量变化,返回的记录数固定,对执行时间有什么影响呢?

```sql
select from user limit 1,1000;
select from user limit 100, 1000:
select from user limit 1000, 1000;
select from user limit 10000,1000;
```

结论:在査询记录时,如果査询记录量相同,偏移量是不断变化的,那么超过100以后随着偏移量的不断的增加,查询的时间就会急剧増加。

优化方式1:通过索引进行分页

- 直接进行limit操作,会产生全表扫描,速度会很慢, limit限制是从结果集M位置处取岀N条数据,其他拋弃

- 假设id是连续递增,可以根据査询的页数和査询的记录数算岀要査询的id的范围,然后配合limit使用。

  ```sql
  select * from user where id >= 1001 limit 100;
  ```

- 择语优化方式2:利用子查询优化

  ```sql
  -- 首先定位偏移位置的工D
  select id from user where limit 10000, 1;
  
  -- 根据获取到的工D向后查询
  select from user where id >= (select id from user where limit 10000, 1) limit 1000;
  ```

## 5.MySQL有哪几种加锁范围

MYSQL中按照加锁范围分类,大致有三种：

- 全局锁：是对整个的数据库实例加锁,添加全局锁之后以下的一些语句会被阻塞

  - 数据更新(DML)

  - 数据定义语句

  - 更新类事务无法提交

  - 全局锁的典型的应用场景:做全库的逻辑备份,重新做主从的时候

  - 全局锁的使用方式

    ```sql
    -- 第一种方式 推荐使用 客户端异常会自动释放
    flush tables with read lock:
    unlock tables;
    
    -- 第二种方式 不建议使用
    set global readonly = true;
    ```

- 表级锁

- 行级锁

## 6.为什么说插入 、更新、删除都是归为当前读

MVCC多版本并发控制的机制中,读操作被分为两类：

- 快照读:简单的 select操作时不加锁,属于快照读select * from user
- 当前读:特殊的读操作,插入、更新、删除操作,都属于当前读（需要去比对当前数据）,需要加锁

当前读读取的是最新的版本记录。并且,在读取之后,还需要保证其他并发事务不会修改当前的记录,对读取的记录加锁的,除了 in share mode对读取的记录加的是共享锁以外,其他操作加的都是X锁 排他锁。

```sql
insert into ...
update table ...
delete from ...
select * from user in share mode;
select * from user for update;
```



分析SQL语句的加锁情况时,应该注意以下几个问题:

- id列是不是主键?
- 当前系统的隔离级别是什么?
- id列如果不是主键,那么id列上有没有索引?
- id列上如果有索引,这个索引是不是唯一索引。
- sQL的执行计划是什么?索引扫描、全表扫描



## 7.mysql什么时候需要分库分表

什么情况下需要用到分库分表：

- 单机存储容量达到瓶颈。
- 服务器连接数和处理能里能力达到上限。
- 单表数据量超过1000万条或者达到100G时候,可以考虑分库分表。

分库分表方式：

- 垂直分库：按照业务不同,将不同的表进行分类,相同业务下的表放到一个数据库上将数据库部署到不同的服务器上,减轻单台服务器负载压力。
- 垂直分表：表中的字段太多,包含大字段的时候,在查询时对数据库iO、内存来说压力是比较大的,在数据更新时,会产生大量 binlog日志, MYSQL在进行主从同步时有延时风险。垂直分表指的是将一个表,按照字段进行拆分,拆分成多个表。冷热数据分离。

垂直拆分:垂直分库和垂直分表解决业务层面的耦合,业务清晰。可以针对不同业务的数据进行分级管理t在高并发场景下,垂直分库一定程度能够提高访问性能。但是垂直拆分无法解决单表数据量多大的问题。

- 水平分库：指的是根据表中的数据的逻辑关系,将同一个表的数据按照某种条件拆分到**多台数据库服务器**中。
- 水平分表：对于数据量比较大的一张表,按照规则把一张表的数据,拆分到多张表中,但是这些表**还是在同一个数据库**。

垂直拆分:属于结构性的拆分,不会涉及到数据。一般是在数据库设计阶段就完成。

水平拆分:属于按照数据进行拆分。是在数据达到一定阶段时,才会进行。

## MySQL函数

## ifnull、isnull、nullif

- **isnull(expr)**

如expr 为null，那么isnull() 的返回值为 1，否则返回值为 0。
mysql> select isnull(1+1);
-> 0
mysql> select isnull(1/0);
-> 1
使用= 的null 值对比通常是错误的。

- **IFNULL(expr1,expr2)**

假如expr1  不为  **NULL**，则  IFNULL()  的返回值为  expr1;
否则其返回值为  expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。

**mysql**>  SELECT  IFNULL(1,0);  
 ->  1  
**mysql**>  SELECT  IFNULL(**NULL**,10);  
->  10  
 **mysql**>  SELECT  IFNULL(1/0,10);  
 ->  10  
**mysql**>  SELECT IFNULL(1/0,'yes');  

->  'yes' 

- **NULLIF(expr1,expr2)**

如果expr1 =  expr2   成立，那么返回值为**NULL**，否则返回值为  expr1。

**mysql**>  SELECT NULLIF(1,1);  

->  **NULL**  
**mysql**>  SELECT  NULLIF(1,2);  
 ->  1 

如果参数不相等，则  **MySQL**  两次求得的值为   expr1  。
