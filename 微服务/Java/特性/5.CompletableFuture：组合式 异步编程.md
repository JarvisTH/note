分支/合并框架以及并行流是实现并行处理的工具；它们将一个操作分为多个子操作，在多个不同的核、 CPU甚至是机器上并行地执行这些子操作。  

实现并发，而非并行，或者你的主要目标是在同一个CPU上执行几个松耦合的任务，充分利用CPU的核，让其足够忙碌，从而最大化程序的吞吐量，那么你其实真正想做的是避免因为等待远程服务的返回，或者对数据库的查询，而阻塞线程的执行，浪费计算资源，因为这种等待的时间很可能相当长。  Future接口，尤其是它的新版实现CompletableFuture，是处理这种情况的利器。  

![image-20230311095307633](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230311095307633.png)

##  

Future接口在Java 5中被引入，设计初ᛱ是对将来某个时刻发生的结果进行建模。它建模了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。在Future中触发那些潜在耗时的操作把调用线程解放出来，让它能继续执行其他有价值的工作，不再需要等待耗时的操作完成。  

Future的另一个优点是它比更底层的Thread更易用。要使用Future，通常你只需要将耗时的操作封装在一个Callable对象中，再将它提交给ExecutorService。

![image-20230311095655369](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230311095655369.png)

如果该长时间运行的操作永远不返回了会怎样？为了处理这种可能性，推荐使用重载版本的get方法，它接受一个超时的参数，可以定义线程等待Future结果的最长时间 。



**异步任务工具类**：

```java
public class CommonUtils {
    // 读取指定路径文件
    public static String readFile(String pathFile) {
        try {
            return Files.readString(Paths.get(pathFile));
        } catch (Exception e) {
            e.printStackTrace();
            return "";
        }
    }

    // 休眠毫秒数
    public static void sleepMillis(long millis) {
        try {
            TimeUnit.MILLISECONDS.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    // 休眠秒数
    public static void sleepSecond(int seconds) {
        try {
            TimeUnit.SECONDS.sleep(seconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    // 打印输出带线程信息日志
    public static void printThreadLog(String msg) {
        String result = new StringJoiner(" | ")
                .add(String.valueOf(System.currentTimeMillis()))
                .add(String.format("%2d", Thread.currentThread().getId()))
                .add(String.valueOf(Thread.currentThread().getName()))
                .add(msg)
                .toString();

        System.out.println(result);
    }
}
```

测试：

![image-20230311103733468](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230311103733468.png)

## 一、Future 与 CompletableFuture

### 1、Future接口局限性

需求：替换新闻稿（news.txt）中敏感词汇，把敏感词汇替换为*，敏感词存储在filter_words.txt中

```
// filter_words.txt
尼玛,NB,tmd
```

```java
public class FutureDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        // 1.读取敏感词汇 可能是耗时任务  => thread1
        Future<String[]> filterWordsFuture = executorService.submit(()->{
            String content = CommonUtils.readFile("src/main/filter_words.txt");
            String[] filterWords = content.split(",");
            return filterWords;
        });

        // 2.读取新闻稿 可能是耗时任务 => thread2
        Future<String> newsFuture = executorService.submit(()->{
            return CommonUtils.readFile("src/main/news.txt");
        });

        // 3.替换操作 可能是耗时任务 => thread3
        Future<String> newsFutureReplaced = executorService.submit(()->{
            String[] words = filterWordsFuture.get();
            String content = newsFuture.get();

            for (String word : words) {
                if (content.indexOf(word) >= 0) {
                    content = content.replace(word, "**");
                }
            }

            return content;
        });

        // 4.打印输出替换后的新闻稿 => main
        String news = newsFutureReplaced.get();
        System.out.println("news:" + news);
    }
}

news:oh my god!completablefuture真**好用啊
```

这种实现下Thread3 依赖与 Thread1 、Thread2，main线程依赖thread3 的结果，如果不使用多线程，程序耗时较多；不足之处：

- 没有阻塞情况下，无法对future的结果执行进一步操作。Future不会告知完成时间，要得到结果，必须通过get方法，该方法为阻塞方法，直到结果可用为止。它不具备将回调函数附加到Future后并在Future的结果可用时自动调用回调的能力。
- 无法解决任务互相依赖的问题。例如上面的例子，filterWordsFuture和newsFuture的结果不能自动发送给newsFutureReplaced，需要在newsFutureReplaced中手动获取，因此Future不能轻易的创建异步工作流。
- 不能将多个Future合并在一起。假如有多种不同future，想在他们完成之后在运行某个函数，future很难独立完成这个目标。
- 没有异常处理。Future没有提供专门的异常处理api，需要手动处理异常。

### 2.、CompletableFuture的优势

![image-20230311110217923](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230311110217923.png)

相对Future的优势：

- 为快速创建、连接依赖和组合多个Future提供了大量的便利方法
- 提供了适用于各种开发场景的回调函数，提供了非常全面的异常处理支持
- 无缝衔接 lambda表达式和Stream api
- 把异步编程与函数式编程、响应式编程基于一身

### 3.join与get的对比

- join在编译时不做检查型异常 处理，不抛出异常
- get需要抛出异常

## 二、创建异步任务

### 1.runAsync

如果需要异步运行某些耗时的后台任务，并且不想从任务中返回任务内容，则可以使用CompletableFuture.runAsync方法，接受一个Runnable接口的实现类对象，返回CompletableFuture<void>对象：

```java
	public static CompletableFuture<Void> runAsync(Runnable runnable) {
        return asyncRunStage(ASYNC_POOL, runnable);
    }

	// runnable 接口是没有返回值，为void ，所以接口的泛型是void
```

Demo: 创建一个不从任务中返回任务内容的CompletableFuture异步对象

```java
public class RunAsyncDemo {
    public static void main(String[] args) {
        CommonUtils.printThreadLog("main start");

        // 开启一个异步任务读取文件
        CompletableFuture.runAsync(new Runnable() {
            @Override
            public void run() {
                CommonUtils.printThreadLog("读取文件开始");
                CommonUtils.sleepSecond(3);
                CommonUtils.printThreadLog("读取文件结束");
            }
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.sleepSecond(4); // 让异步任务有机会执行
        CommonUtils.printThreadLog("main end");
    }
}

1678504668848 |  1 | main | main start
1678504668864 |  1 | main | main continue
1678504668865 | 22 | ForkJoinPool.commonPool-worker-51 | 读取文件开始
1678504671868 | 22 | ForkJoinPool.commonPool-worker-51 | 读取文件结束
1678504672865 |  1 | main | main end
```

**CompletableFuture 中的异步任务底层提供开启线程方式完成的。**

结合**函数式编程**：

```java
public class RunAsyncLambdaDemo {
    public static void main(String[] args) {
        CommonUtils.printThreadLog("main start");

        // 开启一个异步任务读取文件
        CompletableFuture.runAsync(()->{
            CommonUtils.printThreadLog("读取文件开始");
            CommonUtils.sleepSecond(3);
            CommonUtils.printThreadLog("读取文件结束");
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.sleepSecond(4);
        CommonUtils.printThreadLog("main end");
    }
}

1678505300296 |  1 | main | main start
1678505300315 |  1 | main | main continue
1678505300315 | 22 | ForkJoinPool.commonPool-worker-51 | 读取文件开始
1678505303325 | 22 | ForkJoinPool.commonPool-worker-51 | 读取文件结束
1678505304316 |  1 | main | main end
```

需求： 使用CompletableFuture开启异步任务读取news.txt 文件的新闻稿，并打印输出：

```java
public class RunAsyncNewsPrintDemo {
    public static void main(String[] args) {
        CommonUtils.printThreadLog("main start");

        // 开启一个异步任务读取文件
        CompletableFuture.runAsync(()->{
            System.out.println("read file");
            String content = CommonUtils.readFile("src/main/news.txt");
            System.out.println(content);
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.sleepSecond(4);
        CommonUtils.printThreadLog("main end");
    }
}

1678505490902 |  1 | main | main start
1678505490919 |  1 | main | main continue
read file
oh my god!completablefuture真tmd好用啊
1678505494920 |  1 | main | main end
```

**异步任务是并发执行还是并行执行？** 

**如果是单核CPU，那么异步任务之间就是并发执行，如果是多核CPU或多CPU， 异步任务就是并行执行。**开发者只需要知道如何开启异步任务，CPU硬件会把异步任务合理的分配给CPU上的核运行，即硬件决定。

### 2.supplyAsync

想从异步任务中返回一个结果怎么办？可以使用CompletableFuture.supplyAsync方法：

```java
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier) {
    return asyncSupplyStage(ASYNC_POOL, supplier);
}
```

入参Supplier<U> 供给者，用于供给带返回值的异步任务，并返回CompletableFuture<U>，U是供给者给程序供给值的类型。

需求： 开启异步任务读取news.txt 文件中的新闻稿，返回文件内容并在**主线程中打印输出**：

```java
public class SupplyAsyncNewsPrintDemo {
    public static void main(String[] args) {
        CommonUtils.printThreadLog("main start");

        // 开启一个异步任务读取文件
        CompletableFuture<String> news = CompletableFuture.supplyAsync(new Supplier<String>() {
            @Override
            public String get() {
                return CommonUtils.readFile("src/main/news.txt");
            }
        });

        CommonUtils.printThreadLog("main continue");
        System.out.println(news.get());
        CommonUtils.printThreadLog("main end");
    }
}

1678506612919 |  1 | main | main start
1678506612933 |  1 | main | main continue
oh my god!completablefuture真tmd好用啊
1678506612936 |  1 | main | main end
```

如果想要获取newsFuture结果，可以调用get方法。get方法会阻塞，直到newsFuture完成。

函数式编程：

```java
public class SupplyAsyncNewsPrintDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        // 开启一个异步任务读取文件
        CompletableFuture<String> news = CompletableFuture.supplyAsync(()->{
            return CommonUtils.readFile("src/main/news.txt");
        });

        CommonUtils.printThreadLog("main continue");
        System.out.println(news.get());
        CommonUtils.printThreadLog("main end");
    }
}

1678506612919 |  1 | main | main start
1678506612933 |  1 | main | main continue
oh my god!completablefuture真tmd好用啊
1678506612936 |  1 | main | main end
```

**get方法是阻塞的，会不会影响程序性能？**

**使用回调函数解决**

### 3.异步任务中的线程池

代码中没有显示创建线程，那么CompletableFuture使用的线程从哪里获取的呢？

**CompletableFuture会从全局的ForkJoinPool.commonPool（）线程池获取线程执行任务。**

也可以自己创建线程池，将其传给runSync/suppluAsync方法，让他们从指定线程池中获取线程执行任务：

```java
	public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor) {
        return asyncRunStage(screenExecutor(executor), runnable);
    }
    
	public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor) {
        return asyncSupplyStage(screenExecutor(executor), supplier);
    }
```

CompletableFuture中的所有api都有两种变体，即从默认线程池中获取线程执行，或者从指定线程池中获取线程执行。

需求：指定线程池，开启异步任务读取 news.txt 中的新闻稿，返回文件在内容并在主线程中打印输出：

```java
public class SupplyAsyncNewsPrintWithThreadPoolDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        ExecutorService executor = Executors.newFixedThreadPool(5);
        // 开启一个异步任务读取文件
        CompletableFuture<String> news = CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/news.txt");
        }, executor);

        CommonUtils.printThreadLog("main continue");
        System.out.println(news.get());
        CommonUtils.printThreadLog("main end");
    }
}

1678507252610 |  1 | main | main start
1678507252627 |  1 | main | main continue
1678507252627 | 22 | pool-1-thread-1 | read file
oh my god!completablefuture真tmd好用啊
1678507252630 |  1 | main | main end
```

执行完上面的代码，会发现程序并没有结束，这是为什么呢？

**因为默认线程池是归主线程管理，主线程结束会把默认线程池关闭掉，指定线程池后，指定线程池归开发者管理，主线程不会自动关闭该线程池，所以会一直等待异步任务。**

```java
public class SupplyAsyncNewsPrintWithThreadPoolDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        ExecutorService executor = Executors.newFixedThreadPool(5);
        // 开启一个异步任务读取文件
        CompletableFuture<String> news = CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/news.txt");
        }, executor);

        CommonUtils.printThreadLog("main continue");
        System.out.println(news.get());
        executor.shutdown();	// ***** 需要手动调用该方法关闭线程池
        CommonUtils.printThreadLog("main end");
    }
}
```

***最佳实践：***

***创建属于自己的线程池，如果所有CompletableFuture共享一个线程池，那么一旦有异步任务执行一些很慢的I/O操作，会导致线程池中所有线程都阻塞在I/O操作上，从而导致线程饥饿，影响系统性能。所以，不同业务需要使用不同的线程池，避免相互干扰。***



### 4.异步编程思想

**线程的创建和线程负责的任务进行解耦，好处是线程的创建和启动全部交给线程池负责，具体任务交给开发者。**

异步编程是可以让程序并发/并行的一种手段，可以让程序中的一个工作单元作为异步任务与主线程独立运行，并且在异步任务运行结束后，通知主线程它的运行结果或者失败原因，提高程序的性能和响应。

开发者只需要把耗时操作交给CompletableFuture开启一个异步任务，继续关注主线程业务，当异步任务运行完成时通知主线程它的运行结果。这种思想的开发就是异步编程思想。

## 三、任务异步回调

get方法是阻塞的，调用时它会阻塞等待future完成。对于构建异步系统，应该能够将回调附加到CompletableFuture上，当这个future完成时，该回调应自动被调用，这样就不用等待结果。

thenApply、thenAccept、thenRun方法将回调函数附加到CompletableFuture。

### 1.thenApply

使用thenApply方法可以处理和转换CompletableFuture结果。Function<? super T,? extends U>是一个函数式接口，表示一个转换操作，接收类型T参数并产生类型U的结果。

```java
	public <U> CompletableFuture<U> thenApply(
        Function<? super T,? extends U> fn) {
        return uniApplyStage(null, fn);
    }
```

需求 ： 异步读取filter_words.txt文件内容，读取后，把内容转换为数组，异步任务返回敏感词数组

```java
public class ComplelableFutureThenApplyDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<String> content = CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/filter_words.txt");
        });

        CompletableFuture<String[]> filterWordsFuture = content.thenApply(result -> {
            CommonUtils.printThreadLog("split content");
            return result.split(",");
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(filterWordsFuture.get()));
        CommonUtils.printThreadLog("main end");
    }
}

1678512166927 |  1 | main | main start
1678512166943 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678512166943 |  1 | main | main continue
1678512166945 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678512166953 |  1 | main | filter words:[尼玛, NB, tmd]
1678512166953 |  1 | main | main end
```

可以对异步任务的结果进一步应用function转换，转换后的结果可以在主线程获取，也可以进行下一步转换。

**链式操作**：

```java
public class ComplelableFutureThenApplyLinkDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<String[]> filterWordsFuture = CompletableFuture.supplyAsync(() -> {
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/filter_words.txt");
        }).thenApply(result -> {
            CommonUtils.printThreadLog("split content");
            return result.split(",");
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(filterWordsFuture.get()));
        CommonUtils.printThreadLog("main end");
    }
}

1678512429793 |  1 | main | main start
1678512429811 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678512429811 |  1 | main | main continue
1678512429813 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678512429824 |  1 | main | filter words:[尼玛, NB, tmd]
1678512429824 |  1 | main | main end
```



### 2.thenAccept

不想从回调函数返回结果，执行在Future结束后运行一些代码，则可以使用thenAccept。

入参是Consumer<? super T> ，可以对异步任务的执行结果进行使用，返回 CompletableFuture<Void>

```java
public CompletableFuture<Void> thenAccept(Consumer<? super T> action) {
    return uniAcceptStage(null, action);
}
```

通常作为调用链中最后一个回调。

需求： 异步读取filter_words文件，转换为数组，并打印

```java
public class ComplelableFutureThenAcceptDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/filter_words.txt");
        }).thenApply(result -> {
            CommonUtils.printThreadLog("split content");
            return result.split(",");
        }).thenAccept(result -> {
            CommonUtils.printThreadLog("filter words:" + Arrays.toString(result));
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.sleepSecond(4);
        CommonUtils.printThreadLog("main end");
    }
}

1678512833859 |  1 | main | main start
1678512833876 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678512833876 |  1 | main | main continue
1678512833878 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678512833886 | 22 | ForkJoinPool.commonPool-worker-51 | filter words:[尼玛, NB, tmd]
1678512837882 |  1 | main | main end
```



### 3.thenRun

如果只想从CompletableFuture的链式操作得到一个完成的通知，不使用上一步操作结果，可以使用thenRun方法，返回 CompletableFuture<Void>。

```java
	public CompletableFuture<Void> thenRun(Runnable action) {
        return uniRunStage(null, action);
    }
```

需求： 仅仅想知道 filter_word文件是否读取完成。

```java
public class ComplelableFutureThenRunDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/filter_words.txt");
        }).thenAccept(result -> {
            CommonUtils.printThreadLog("read finish");
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.sleepSecond(4);
        CommonUtils.printThreadLog("main end");
    }
}

1678513431398 |  1 | main | main start
1678513431415 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678513431415 |  1 | main | main continue
1678513431417 | 22 | ForkJoinPool.commonPool-worker-51 | read finish
1678513435418 |  1 | main | main end
```



### 4.进一步提升并行化

CompletableFuture提供的回调方法都有两个变体：

```java
	// 一般回调方法
	public <U> CompletableFuture<U> thenApply(
        Function<? super T,? extends U> fn) {
        return uniApplyStage(null, fn);
    }

	// 异步回调方法
    public <U> CompletableFuture<U> thenApplyAsync(
        Function<? super T,? extends U> fn) {
        return uniApplyStage(defaultExecutor(), fn);
    }

    // 异步指定线程池回调方法
    public <U> CompletableFuture<U> thenApplyAsync(
        Function<? super T,? extends U> fn, Executor executor) {
        return uniApplyStage(screenExecutor(executor), fn);
    }
```

带了Async的异步回调 通过在单独的线程中执行回调任务，进一步提升并行化。

**回顾需求： 异步读取filter_words文件，转换为数组，主线程获取结果并打印**

一般而言，commonPool为了提供性能，不会立马回收线程，thenApply中回调任务和SupplyAsync异步任务使用的同一个线程。特殊情况，如果SupplyAsync的任务是立马返回结果的，没有耗时操作，则后续回调任务都可能是在主线程中执行。

```java
public class ComplelableFutureThenApplyDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<String[]> filterWordsFuture = CompletableFuture.supplyAsync(()->{
            return "ttt,wwww";
        }).thenApply(result -> {
            CommonUtils.printThreadLog("split content");
            return result.split(",");
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(filterWordsFuture.get()));
        CommonUtils.printThreadLog("main end");
    }
}

// 返回结果1：内部优化导致，与当前电脑状态有关
1678514175164 |  1 | main | main start
1678514175179 |  1 | main | main continue
1678514175179 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678514175186 |  1 | main | filter words:[ttt, wwww]
1678514175186 |  1 | main | main end
    
// 返回结果2
1678514228529 |  1 | main | main start
1678514228546 |  1 | main | split content
1678514228546 |  1 | main | main continue
1678514228554 |  1 | main | filter words:[ttt, wwww]
1678514228554 |  1 | main | main end
```

要更好的控制回调任务的线程，可以使用异步回调，thenApplyAsync回调，将在从线程池中获取一个线程执行。

```java
public class ComplelableFutureThenApplyAsyncDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<String[]> filterWordsFuture = CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/filter_words.txt");
        }).thenApplyAsync(result -> {
            CommonUtils.printThreadLog("split content");
            return result.split(",");
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(filterWordsFuture.get()));
        CommonUtils.printThreadLog("main end");
    }
}

// 运行结果1
1678514502184 |  1 | main | main start
1678514502199 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678514502199 |  1 | main | main continue
1678514502202 | 23 | ForkJoinPool.commonPool-worker-37 | split content
1678514502209 |  1 | main | filter words:[尼玛, NB, tmd]
1678514502209 |  1 | main | main end

// 运行结果2  内部优化导致，与当前电脑状态有关
1678514564687 |  1 | main | main start
1678514564703 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678514564703 |  1 | main | main continue
1678514564706 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678514564714 |  1 | main | filter words:[尼玛, NB, tmd]
1678514564714 |  1 | main | main end
```



## 四、异步任务编排

### 1.编排2个依赖关系的异步任务 thenCompose（）

需求回顾： 异步读取filter_words 文件，转换为数组，让主线程使用

```java
public class ComplelableFutureThenComposeDemo {

    public static CompletableFuture<String> readFileFuture(String fileName) {
        return CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile(fileName);
        });
    }

    public static CompletableFuture<String[]> splitFileFuture(String content) {
        return CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("split content");
            return content.split(",");
        });
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<CompletableFuture<String[]>> completableFutureCompletableFuture = readFileFuture("src/main/filter_words.txt")
                .thenApply((content) -> {
                    return splitFileFuture(content);
                });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(completableFutureCompletableFuture.get().get()));
        CommonUtils.printThreadLog("main end");
    }
}


1678515318158 |  1 | main | main start
1678515318174 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678515318175 |  1 | main | main continue
1678515318177 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678515318185 |  1 | main | filter words:[尼玛, NB, tmd]
1678515318186 |  1 | main | main end
```

在之前的案例中，thenAppy中的function会对上一步任务结果转换后得到一个值，这种情况下，最终结果是嵌套的CompletableFuture，不符合预期，怎么办？

想要的是：把上一步任务的结果，转换一个CompletableFuture对象。这个对象包含本次异步任务处理结果。即想组合上一步异步任务的结果到下一个异步任务中，结果有这个新的异步任务返回。

这时可以使用thenCompose方法，即异步任务组合，用来连接两个有**依赖关系**的异步任务，结果由第二任务返回。

```java
	public <U> CompletableFuture<U> thenCompose(
        Function<? super T, ? extends CompletionStage<U>> fn) {
        return uniComposeStage(null, fn);
    }

    public <U> CompletableFuture<U> thenComposeAsync(
        Function<? super T, ? extends CompletionStage<U>> fn) {
        return uniComposeStage(defaultExecutor(), fn);
    }

    public <U> CompletableFuture<U> thenComposeAsync(
        Function<? super T, ? extends CompletionStage<U>> fn,
        Executor executor) {
        return uniComposeStage(screenExecutor(executor), fn);
    }
```

优化后：

```java
public class ComplelableFutureThenComposeDemo {

    public static CompletableFuture<String> readFileFuture(String fileName) {
        return CompletableFuture.supplyAsync(() -> {
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile(fileName);
        });
    }

    public static CompletableFuture<String[]> splitFileFuture(String content) {
        return CompletableFuture.supplyAsync(() -> {
            CommonUtils.printThreadLog("split content");
            return content.split(",");
        });
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<String[]> future = readFileFuture("src/main/filter_words.txt")
                .thenCompose((content) -> {
                    return splitFileFuture(content);
                });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(future.get()));
        CommonUtils.printThreadLog("main end");
    }
    // 或者
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<String[]> completableFuture = CompletableFuture.supplyAsync(() -> {
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/filter_words.txt");
        }).thenCompose(content -> CompletableFuture.supplyAsync(() -> {
            CommonUtils.printThreadLog("split content");
            return content.split(",");
        }));

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(completableFuture.get()));
        CommonUtils.printThreadLog("main end");
    }
}

// 结果1
1678515626622 |  1 | main | main start
1678515626637 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678515626638 |  1 | main | main continue
1678515626641 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678515626650 |  1 | main | filter words:[尼玛, NB, tmd]
1678515626650 |  1 | main | main end
    
// 结果2
1678516179454 |  1 | main | main start
1678516179470 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678516179470 |  1 | main | main continue
1678516179473 | 23 | ForkJoinPool.commonPool-worker-37 | split content
1678516179481 |  1 | main | filter words:[尼玛, NB, tmd]
1678516179481 |  1 | main | main end
```

### 2.编排两个非依赖关系的异步任务 thenCombine

如果两个future之间没有依赖关系，但是希望两个future独立运行，并且在两个都完成之后执行回调操作，则使用thenCombine方法。

```java
	public <U,V> CompletableFuture<V> thenCombine(
        CompletionStage<? extends U> other,
        BiFunction<? super T,? super U,? extends V> fn) {
        return biApplyStage(null, other, fn);
    }

    public <U,V> CompletableFuture<V> thenCombineAsync(
        CompletionStage<? extends U> other,
        BiFunction<? super T,? super U,? extends V> fn) {
        return biApplyStage(defaultExecutor(), other, fn);
    }

    public <U,V> CompletableFuture<V> thenCombineAsync(
        CompletionStage<? extends U> other,
        BiFunction<? super T,? super U,? extends V> fn, Executor executor) {
        return biApplyStage(screenExecutor(executor), other, fn);
    }
```

T是第一个任务的结果，U是第二个任务的结果，V是经BiFunction应用转换后的结果。

需求： 替换新闻稿news.txt文件敏感词为*，敏感词在filter_words文件中

```java
public class ComplelableFutureThenCombineDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        // 1。读取敏感词。解析为数组
        CompletableFuture<String[]> filterFileFuture = CompletableFuture.supplyAsync(() -> {
            CommonUtils.printThreadLog("read filter file");
            return CommonUtils.readFile("src/main/filter_words.txt").split(",");
        });

        // 2.读取news
        CompletableFuture<String> newsFileFuture = CompletableFuture.supplyAsync(() -> {
            CommonUtils.printThreadLog("read news file");
            return CommonUtils.readFile("src/main/news.txt");
        });

        // 3.替换敏感词
        CompletableFuture<String> future = filterFileFuture.thenCombine(newsFileFuture, (filterWords, news) -> {
            for (String word : filterWords) {
                if (news.indexOf(word) >= 0) {
                    news = news.replace(word, "**");
                }
            }
            CommonUtils.printThreadLog("replace word");
            return news;
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + future.get());
        CommonUtils.printThreadLog("main end");
    }
}

1678539843074 |  1 | main | main start
1678539843099 | 22 | ForkJoinPool.commonPool-worker-51 | read filter file
1678539843100 | 23 | ForkJoinPool.commonPool-worker-37 | read news file
1678539843100 |  1 | main | main continue
1678539843103 | 22 | ForkJoinPool.commonPool-worker-51 | replace word
1678539843114 |  1 | main | filter words:oh my god!completablefuture真**好用啊
1678539843114 |  1 | main | main end
```

### 3.合并多个异步任务 allOf/anyOf

如果需要编排任意数量的CompletableFuture怎么办？可以使用下面的方法：

```java
    public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs)
```

**allOf适合场景**：有多个需要独立运行的Future，并且所有这些Future完成后执行一些操作。

需求 ： 统计news1.txt、news2.txt、news3.txt 这3个文件中包含CompletableFuture关键字文件的个数

```java
public class ComplelableFutureAllOfDemo {
    public static CompletableFuture<String> readFileFuture(String fileName) {
        return CompletableFuture.supplyAsync(() -> {
            CommonUtils.printThreadLog("read txt file");
            return CommonUtils.readFile(fileName);
        });
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        List<String> fileNames = Arrays.asList("src/main/news1.txt", "src/main/news2.txt", "src/main/news3.txt");
        List<CompletableFuture<String>> futures = fileNames.stream().map(fileName -> {
            return readFileFuture(fileName);
        }).collect(Collectors.toList());

        int len = futures.size();
        CompletableFuture[] filesArr = futures.toArray(new CompletableFuture[len]);
        CompletableFuture<Void> allOf = CompletableFuture.allOf(filesArr);
        CompletableFuture<Long> longCompletableFuture = allOf.thenApply(v -> {
            return futures.stream().map(future -> future.join()).filter(content -> content.contains("completablefuture"))
                    .count();
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.sleepSecond(4);
        CommonUtils.printThreadLog("count:" + longCompletableFuture.join());
        CommonUtils.printThreadLog("main end");
    }
}

1678541311616 |  1 | main | main start
1678541311635 | 22 | ForkJoinPool.commonPool-worker-51 | read txt file
1678541311635 | 23 | ForkJoinPool.commonPool-worker-37 | read txt file
1678541311635 | 24 | ForkJoinPool.commonPool-worker-9 | read txt file
1678541311636 |  1 | main | main continue
1678541315648 |  1 | main | count:3
1678541315648 |  1 | main | main end
```



anyOff适合场景：当给定的多个异步任务有一个future完成，需要执行操作的时候。返回值与已完成的那个future返回值一致。

```java
    public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)
```

```java
public class ComplelableFutureAnyOfDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
            CommonUtils.sleepSecond(2);
            return "future1";
        });

        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
            CommonUtils.sleepSecond(3);
            return "future2";
        });

        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> {
            CommonUtils.sleepSecond(1);
            return "future3";
        });

        CompletableFuture<Object> future = CompletableFuture.anyOf(future1, future2, future3);

        CommonUtils.printThreadLog("main continue");
        Object ret = future.get();
        System.out.println("ret =" + ret);
        CommonUtils.printThreadLog("main end");
    }
}

1678542066107 |  1 | main | main start
1678542066126 |  1 | main | main continue
ret =future3
1678542067145 |  1 | main | main end
```

anyof方法返回类型必须是CompletableFuture<Object>;  缺点在于多个future返回值不一致时，不知道最后返回的是什么。

## 五、异步任务的异常处理

异常如何在回调链中传播？

```java
public class ExceptionChainDemo {
    public static void main(String[] args) {
        CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {
            int r = 1 / 0;
            return "result1";
        }).thenApply(result -> {
            return result + " result2";
        }).thenApply(result -> {
            return result + " result3";
        }).thenAccept(ret -> {
            CommonUtils.printThreadLog(ret);
        });
    }
}



Process finished with exit code 0
```

如果回调链中出现异常，则回调不会往下继续执行，立即转入异常处理。

### 1.exceptionally

用于处理回调链上的任何异常，回调链出现异常，不会继续往下执行，都在exceptionally中处理。

```java
public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> fn)
```

```java
public class ExceptionChainDemo {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            int r = 1 / 0;
            return "result1";
        }).thenApply(result -> {
            return result + " result2";
        }).thenApply(result -> {
            return result + " result3";
        }).exceptionally(ex -> {
            System.out.println("出现异常 " + ex.getMessage());
            return "exception";
        });
    }
}

出现异常 java.lang.ArithmeticException: / by zero

Process finished with exit code 0
```

### 2.handle

表示从异常中恢复。常常用来恢复回调链中的一次特定异常，回调链恢复后可以继续向下传递。

```java
public <U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ? extends U> fn)
```

```java
public class HandleChainDemo {
    public static void main(String[] args) {
        CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {
            int r = 1 / 0;
            return "result1";
        }).handle((result, ex) -> {
            CommonUtils.printThreadLog("上一步异常的恢复");
            if (ex != null) {
                CommonUtils.printThreadLog("出现异常 " + ex.getMessage());
                return "unknown";
            }
            return result;
        }).thenApply(result -> {
            return result + " result2";
        }).thenApply(result -> {
            return result + " result3";
        }).thenAccept(ret -> {
            CommonUtils.printThreadLog(ret);
        });
    }
}

1678543466046 |  1 | main | 上一步异常的恢复
1678543466071 |  1 | main | 出现异常 java.lang.ArithmeticException: / by zero
1678543466076 |  1 | main | unknown result2 result3
```

**即使没有出现异常，handle也会执行。**发生异常，ex参数不为空，result没有值；正常时ex没有值，而result有值。

## 六、异步任务交互

**异步任务交互指将异步任务获取结果的速度相比较，按一定的规则（先到先得）进行下一步处理。**

### 1.applyToEither

将两个异步任务作比较，异步任务先到结果的，就对先到的结果进行下一步操作。

```java
public class ApplyToEitherDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {
            int x = new Random().nextInt(3);
            CommonUtils.sleepSecond(x);
            CommonUtils.printThreadLog("耗时 " + x);
            return x;
        });

        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> {
            int x = new Random().nextInt(5);
            CommonUtils.sleepSecond(x);
            CommonUtils.printThreadLog("耗时 " + x);
            return x;
        });

        CompletableFuture<Integer> future = future1.applyToEither(future2, result -> {
            CommonUtils.printThreadLog("最先到达的结果 " + result);
            return result;
        });

        CommonUtils.sleepSecond(5);
        int ret = future.get();
        CommonUtils.printThreadLog("ret = " + ret);
    }
}

1678545175933 | 23 | ForkJoinPool.commonPool-worker-37 | 耗时 1
1678545175945 | 23 | ForkJoinPool.commonPool-worker-37 | 最先到达的结果 1
1678545176921 | 22 | ForkJoinPool.commonPool-worker-51 | 耗时 2
1678545179921 |  1 | main | ret = 1
```



### 2.acceptToEither

**两个异步任务相比较，先获取到执行结果的，就对该结果执行下一步操作。**



### 3.runAfterEither

**不关心最先到达的结果，只想在有一个异步任务先完成时得到完成的通知，可以使用runAfterEither。**



## 七、get 与 join 区别

都是CompletableFuture提供的以阻塞式获取结果的方法。怎么选用呢？

**get抛出检查时异常，需要程序必须处理；join方法抛出运行时异常，可以不处理，所以join更适合用在流式编程中。**



## 八、ParallelStream   VS  CompletableFuture

**CompletableFuture提高了并行处理的能力。与Stream API结合，能否进一步提高多任务并行能力呢？且与Stream API提供的并行流ParalleStream有什么区别呢？**

需求： 创建10个Mytask耗时任务，统计他们总耗时

```java
public class MyTask {
    private int duration;

    public MyTask(int duration) {
        this.duration = duration;
    }

    // 模拟耗时的长任务
    public int doWork() {
        CommonUtils.printThreadLog("do work");
        CommonUtils.sleepSecond(duration);
        return duration;
    }
}

public class SequenceDemo {
    public static void main(String[] args) {
        // 1.创建10个MyTeak对象，每个任务1s，存入list
        IntStream intStream = IntStream.range(0, 10);
        List<MyTask> tasks = intStream.mapToObj(item -> {
            return new MyTask(1);
        }).collect(Collectors.toList());

        // 2.执行10个任务
        long start = System.currentTimeMillis();
        List<Integer> results = tasks.stream().map(myTask -> {
            return myTask.doWork();
        }).collect(Collectors.toList());
        long end = System.currentTimeMillis();
        double costTime = (end - start) / 1000.0;
        System.out.printf("processed %d tasks %.2f second", tasks.size(), costTime);
    }
}


1678587763426 |  1 | main | do work
1678587764443 |  1 | main | do work
1678587765456 |  1 | main | do work
1678587766467 |  1 | main | do work
1678587767476 |  1 | main | do work
1678587768488 |  1 | main | do work
1678587769496 |  1 | main | do work
1678587770507 |  1 | main | do work
1678587771516 |  1 | main | do work
1678587772527 |  1 | main | do work
processed 10 tasks 10.11 second
Process finished with exit code 0
```

花费10s，每个任务都在主线程中依次执行。

既然使用了Stream API，每个任务都是耗时任务，可以使用ParallelStream。

```java
public class ParallelStreamDemo {
    public static void main(String[] args) {
        // 1.创建10个MyTeak对象，每个任务1s，存入list
        IntStream intStream = IntStream.range(0, 10);
        List<MyTask> tasks = intStream.mapToObj(item -> {
            return new MyTask(1);
        }).collect(Collectors.toList());

        // 2.执行10个任务
        long start = System.currentTimeMillis();
        List<Integer> results = tasks.parallelStream().map(myTask -> {
            return myTask.doWork();
        }).collect(Collectors.toList());
        long end = System.currentTimeMillis();
        double costTime = (end - start) / 1000.0;
        System.out.printf("processed %d tasks %.2f second", tasks.size(), costTime);
    }
}

1678587914774 | 29 | ForkJoinPool.commonPool-worker-17 | do work
1678587914774 | 26 | ForkJoinPool.commonPool-worker-59 | do work
1678587914773 | 23 | ForkJoinPool.commonPool-worker-37 | do work
1678587914774 | 27 | ForkJoinPool.commonPool-worker-45 | do work
1678587914774 | 22 | ForkJoinPool.commonPool-worker-51 | do work
1678587914773 | 24 | ForkJoinPool.commonPool-worker-23 | do work
1678587914773 | 25 | ForkJoinPool.commonPool-worker-9 | do work
1678587914774 | 31 | ForkJoinPool.commonPool-worker-53 | do work
1678587914774 | 28 | ForkJoinPool.commonPool-worker-31 | do work
1678587914773 |  1 | main | do work
processed 10 tasks 1.04 second
```

电脑配置不同，上面跑出的时间就不同，取决于电脑的内核数。我的电脑有14个内核，逻辑处理器20个，可以理解为可以同时执行20个线程；将任务数改为21，执行如下：

```java
1678588162118 | 30 | ForkJoinPool.commonPool-worker-3 | do work
1678588162118 | 33 | ForkJoinPool.commonPool-worker-25 | do work
1678588162118 | 34 | ForkJoinPool.commonPool-worker-11 | do work
1678588162118 | 24 | ForkJoinPool.commonPool-worker-23 | do work
1678588162118 | 36 | ForkJoinPool.commonPool-worker-47 | do work
1678588162118 | 32 | ForkJoinPool.commonPool-worker-39 | do work
1678588162117 |  1 | main | do work
1678588162118 | 37 | ForkJoinPool.commonPool-worker-33 | do work
1678588162118 | 27 | ForkJoinPool.commonPool-worker-45 | do work
1678588162119 | 35 | ForkJoinPool.commonPool-worker-61 | do work
1678588162118 | 22 | ForkJoinPool.commonPool-worker-51 | do work
1678588162118 | 40 | ForkJoinPool.commonPool-worker-55 | do work
1678588162118 | 25 | ForkJoinPool.commonPool-worker-9 | do work
1678588162118 | 31 | ForkJoinPool.commonPool-worker-53 | do work
1678588162118 | 39 | ForkJoinPool.commonPool-worker-5 | do work
1678588162118 | 28 | ForkJoinPool.commonPool-worker-31 | do work
1678588162118 | 26 | ForkJoinPool.commonPool-worker-59 | do work
1678588162118 | 23 | ForkJoinPool.commonPool-worker-37 | do work
1678588162118 | 29 | ForkJoinPool.commonPool-worker-17 | do work
1678588162118 | 38 | ForkJoinPool.commonPool-worker-19 | do work
1678588163157 | 37 | ForkJoinPool.commonPool-worker-33 | do work
processed 21 tasks 2.06 second
```

并行流默认的线程池也是ForkJoinPool.commonPool。

继续使用CompletableFuture实现：

```java
public class CompletableFutureTasksDemo {
    public static void main(String[] args) {
        // 1.创建10 Mytask对象，每个任务持续 1 s，存入list
        IntStream intStream = IntStream.range(0, 10);
        List<MyTask> myTasks = intStream.mapToObj(item -> {
            return new MyTask(1);
        }).collect(Collectors.toList());

        // 2.构建10个异步任务
        List<CompletableFuture<Integer>> futureList = myTasks.stream().map(myTask -> {
            return CompletableFuture.supplyAsync(() -> {
                return myTask.doWork();
            });
        }).collect(Collectors.toList());

        // 3.执行异步任务。完成后，获取异步任务结果存入list，统计总耗时
        // join方法不需要处理异常
        long start = System.currentTimeMillis();
        List<Integer> list = futureList.stream().map(CompletableFuture::join).collect(Collectors.toList());
        long end = System.currentTimeMillis();
        double costTime = (end - start) / 1000.0;
        System.out.printf("processed %d tasks %.2f second", futureList.size(), costTime);
    }
}

1678588860977 | 30 | ForkJoinPool.commonPool-worker-3 | do work
1678588860977 | 22 | ForkJoinPool.commonPool-worker-51 | do work
1678588860977 | 28 | ForkJoinPool.commonPool-worker-31 | do work
1678588860977 | 23 | ForkJoinPool.commonPool-worker-37 | do work
1678588860977 | 25 | ForkJoinPool.commonPool-worker-9 | do work
1678588860977 | 27 | ForkJoinPool.commonPool-worker-45 | do work
1678588860977 | 29 | ForkJoinPool.commonPool-worker-17 | do work
1678588860977 | 24 | ForkJoinPool.commonPool-worker-23 | do work
1678588860977 | 26 | ForkJoinPool.commonPool-worker-59 | do work
1678588860977 | 31 | ForkJoinPool.commonPool-worker-53 | do work
processed 10 tasks 1.05 second
```

使用CompletableFuture的时间与ParallelStream时间大致一致，当任务数改为21时，耗时是2s。是否可以进一步优化呢？

**CompletableFuture比ParallelStream的优势之一是可以指定线程池去执行任务，可以选择更合适的线程数量**，可以选择大于Runtime.getRuntime().availableProcessors()数量的线程。

```java
public class CompletableFutureTasksWithExcutorDemo {
    public static void main(String[] args) {
        // 1.创建10 Mytask对象，每个任务持续 1 s，存入list
        IntStream intStream = IntStream.range(0, 10);
        List<MyTask> myTasks = intStream.mapToObj(item -> {
            return new MyTask(1);
        }).collect(Collectors.toList());

        // 准备线程池
        int N_CPU = Runtime.getRuntime().availableProcessors();
        ExecutorService pool = Executors.newFixedThreadPool(Math.min(myTasks.size(), N_CPU * 2));

        // 2.构建10个异步任务
        List<CompletableFuture<Integer>> futureList = myTasks.stream().map(myTask -> {
            return CompletableFuture.supplyAsync(() -> {
                return myTask.doWork();
            }, pool);
        }).collect(Collectors.toList());

        // 3.执行异步任务。完成后，获取异步任务结果存入list，统计总耗时
        // join方法不需要处理异常
        long start = System.currentTimeMillis();
        List<Integer> list = futureList.stream().map(CompletableFuture::join).collect(Collectors.toList());
        long end = System.currentTimeMillis();
        double costTime = (end - start) / 1000.0;
        System.out.printf("processed %d tasks %.2f second", futureList.size(), costTime);
        
        pool.shutdown();
    }
}

1678589359446 | 30 | pool-1-thread-9 | do work
1678589359446 | 23 | pool-1-thread-2 | do work
1678589359446 | 22 | pool-1-thread-1 | do work
1678589359446 | 24 | pool-1-thread-3 | do work
1678589359447 | 31 | pool-1-thread-10 | do work
1678589359446 | 27 | pool-1-thread-6 | do work
1678589359446 | 29 | pool-1-thread-8 | do work
1678589359446 | 26 | pool-1-thread-5 | do work
1678589359446 | 25 | pool-1-thread-4 | do work
1678589359447 | 28 | pool-1-thread-7 | do work
processed 10 tasks 1.04 second
```

当任务数改为21时，耗时也是1s。



## 九、示例：大数据商品比价

### 1.需求

需求描述： 实现一个大数据比价服务，价格数据可以从京东、天猫、拼多多等平台获取指定商品价格、优惠金额，然后计算出实际付款金额（商品价格 - 优惠金额），最终返回价格最优的平台与价格信息。

### 2.工具类

实体类：

```java
public class PriceResult {
    private int price;
    private int discount;
    private int realPrice;
    private String platform;

    public PriceResult(int price, int discount, int realPrice, String platform) {
        this.price = price;
        this.discount = discount;
        this.realPrice = realPrice;
        this.platform = platform;
    }

    public PriceResult() {
    }

    public PriceResult(String platform) {
        this.platform = platform;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public int getDiscount() {
        return discount;
    }

    public void setDiscount(int discount) {
        this.discount = discount;
    }

    public int getRealPrice() {
        return realPrice;
    }

    public void setRealPrice(int realPrice) {
        this.realPrice = realPrice;
    }

    public String getPlatform() {
        return platform;
    }

    public void setPlatform(String platform) {
        this.platform = platform;
    }

    @Override
    public String toString() {
        return "PriceResult{" +
                "平台='" + platform +
                "平台价=" + price +
                ", 优惠价=" + discount +
                ", 最终价=" + realPrice +
                '}';
    }
}
```

工具类：改造CommonUtils类。

```java
    public static void printThreadLog(String msg) {
        String result = new StringJoiner(" | ")
                .add(getCurrentTime())
                .add(String.format("%2d", Thread.currentThread().getId()))
                .add(String.valueOf(Thread.currentThread().getName()))
                .add(msg)
                .toString();

        System.out.println(result);
    }

    private static String getCurrentTime() {
        LocalTime now = LocalTime.now();
        return now.format(DateTimeFormatter.ofPattern("[HH:mm:ss.SSS]"));
    }
```

### 3.构建HttpRequest

```java
public class HttpRequest {
    private static void mockCostTimeOpt() {
        CommonUtils.sleepSecond(1);
    }

    // 获取淘宝平台的商品价
    public static PriceResult getTaoBaoPrice(String productName) {
        CommonUtils.printThreadLog("获取淘宝上" + productName + "价格");
        mockCostTimeOpt();

        PriceResult priceResult = new PriceResult("淘宝");
        priceResult.setPrice(5199);
        CommonUtils.printThreadLog("获取淘宝上" + productName + "价格完成：5199");
        return priceResult;
    }

    // 获取淘宝平台的优惠
    public static int getTaoBaoDiscount(String productName) {
        CommonUtils.printThreadLog("获取淘宝上" + productName + "优惠");
        mockCostTimeOpt();

        CommonUtils.printThreadLog("获取淘宝上" + productName + "优惠完成：-200");
        return 200;
    }

    // 获取京东平台的商品价
    public static PriceResult getJingDongPrice(String productName) {
        CommonUtils.printThreadLog("获取京东上" + productName + "价格");
        mockCostTimeOpt();

        PriceResult priceResult = new PriceResult("淘宝");
        priceResult.setPrice(5199);
        CommonUtils.printThreadLog("获取京东上" + productName + "价格完成：5299");
        return priceResult;
    }

    // 获取京东平台的优惠
    public static int getJingDongDiscount(String productName) {
        CommonUtils.printThreadLog("获取京东上" + productName + "优惠");
        mockCostTimeOpt();

        CommonUtils.printThreadLog("获取京东上" + productName + "优惠完成：-150");
        return 150;
    }

    // 获取pdd平台的商品价
    public static PriceResult getPddPrice(String productName) {
        CommonUtils.printThreadLog("获取pdd上" + productName + "价格");
        mockCostTimeOpt();

        PriceResult priceResult = new PriceResult("淘宝");
        priceResult.setPrice(5399);
        CommonUtils.printThreadLog("获取pdd上" + productName + "价格完成：5399");
        return priceResult;
    }

    // 获取pdd平台的优惠
    public static int getJPddDiscount(String productName) {
        CommonUtils.printThreadLog("获取pdd上" + productName + "优惠");
        mockCostTimeOpt();

        CommonUtils.printThreadLog("获取pdd上" + productName + "优惠完成：-5300");
        return 5300;
    }
}
```

### 4.使用串行方式操作商品比价

```java
public class ComparePriceService {
    public PriceResult computeRealPrice(PriceResult priceResult, int discount) {
        priceResult.setRealPrice(priceResult.getPrice() - discount);
        priceResult.setDiscount(discount);
        CommonUtils.printThreadLog(priceResult.getPlatform() + "最终价格" + priceResult.getRealPrice());
        return priceResult;
    }

    public PriceResult getCheapestPlatFormPrice(String productName) {
        // 获取各个平台的价格、优惠
        PriceResult priceResult;
        int discount;

        priceResult = HttpRequest.getTaoBaoPrice(productName);
        discount = HttpRequest.getTaoBaoDiscount(productName);
        PriceResult taoBao = this.computeRealPrice(priceResult, discount);

        priceResult = HttpRequest.getJingDongPrice(productName);
        discount = HttpRequest.getJingDongDiscount(productName);
        PriceResult jingDong = this.computeRealPrice(priceResult, discount);

        priceResult = HttpRequest.getPddPrice(productName);
        discount = HttpRequest.getJPddDiscount(productName);
        PriceResult pdd = this.computeRealPrice(priceResult, discount);

        // 计算最优平台价
        PriceResult result = Stream.of(taoBao, jingDong, pdd)
                .min(Comparator.comparing(PriceResult::getRealPrice))
                .get();

        return result;
    }
}
```

```java
		// 1.串行方式
        ComparePriceService comparePriceService = new ComparePriceService();
        long start = System.currentTimeMillis();
        PriceResult priceResult = comparePriceService.getCheapestPlatFormPrice("iphone14");
        long end = System.currentTimeMillis();
        double costTime = (end - start) / 1000.0;
        System.out.printf("costs %.2f second \n", costTime);
        System.out.println(priceResult);

11:42:28.248 |  1 | main | 获取淘宝上iphone14价格
11:42:29.269 |  1 | main | 获取淘宝上iphone14价格完成：5199
11:42:29.269 |  1 | main | 获取淘宝上iphone14优惠
11:42:30.277 |  1 | main | 获取淘宝上iphone14优惠完成：-200
11:42:30.283 |  1 | main | 淘宝最终价格4999
11:42:30.283 |  1 | main | 获取京东上iphone14价格
11:42:31.300 |  1 | main | 获取京东上iphone14价格完成：5299
11:42:31.301 |  1 | main | 获取京东上iphone14优惠
11:42:32.311 |  1 | main | 获取京东上iphone14优惠完成：-150
11:42:32.311 |  1 | main | 淘宝最终价格5049
11:42:32.312 |  1 | main | 获取pdd上iphone14价格
11:42:33.323 |  1 | main | 获取pdd上iphone14价格完成：5399
11:42:33.323 |  1 | main | 获取pdd上iphone14优惠
11:42:34.324 |  1 | main | 获取pdd上iphone14优惠完成：-5300
11:42:34.324 |  1 | main | 淘宝最终价格99
costs 6.11 second 
PriceResult{平台='淘宝平台价=5399, 优惠价=5300, 最终价=99}
```

### 5.使用Future + 线程池增强并行

```java
	public PriceResult getCheapestPlatFormPriceWithFuture(String productName) {
        // 获取各个平台的价格、优惠
        ExecutorService pool = Executors.newFixedThreadPool(4);

        Future<PriceResult> taoBaoFuture = pool.submit(() -> {
            PriceResult priceResult = HttpRequest.getTaoBaoPrice(productName);
            int discount = HttpRequest.getTaoBaoDiscount(productName);
            return this.computeRealPrice(priceResult, discount);
        });

        Future<PriceResult> jingDongFuture = pool.submit(() -> {
            PriceResult priceResult = HttpRequest.getJingDongPrice(productName);
            int discount = HttpRequest.getJingDongDiscount(productName);
            return this.computeRealPrice(priceResult, discount);
        });

        Future<PriceResult> pddFuture = pool.submit(() -> {
            PriceResult priceResult = HttpRequest.getPddPrice(productName);
            int discount = HttpRequest.getJPddDiscount(productName);
            return this.computeRealPrice(priceResult, discount);
        });

        // 计算最优平台价
        return Stream.of(taoBaoFuture, jingDongFuture, pddFuture)
                .map(future -> {
                    try {
                        return future.get(5, TimeUnit.SECONDS);
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    } finally {
                        pool.shutdown();
                    }
                }).filter(Objects::nonNull)
                .min(Comparator.comparing(PriceResult::getRealPrice))
                .get();
    }
```

```java
		// 2.future + 线程池方式
        ComparePriceService comparePriceService = new ComparePriceService();
        long start = System.currentTimeMillis();
        PriceResult priceResult = comparePriceService.getCheapestPlatFormPriceWithFuture("iphone14");
        long end = System.currentTimeMillis();
        double costTime = (end - start) / 1000.0;
        System.out.printf("costs %.2f second \n", costTime);
        System.out.println(priceResult);

11:55:40.996 | 23 | pool-1-thread-2 | 获取京东上iphone14价格
11:55:40.996 | 22 | pool-1-thread-1 | 获取淘宝上iphone14价格
11:55:40.996 | 24 | pool-1-thread-3 | 获取pdd上iphone14价格
11:55:42.023 | 23 | pool-1-thread-2 | 获取京东上iphone14价格完成：5299
11:55:42.023 | 22 | pool-1-thread-1 | 获取淘宝上iphone14价格完成：5199
11:55:42.023 | 24 | pool-1-thread-3 | 获取pdd上iphone14价格完成：5399
11:55:42.023 | 23 | pool-1-thread-2 | 获取京东上iphone14优惠
11:55:42.024 | 24 | pool-1-thread-3 | 获取pdd上iphone14优惠
11:55:42.024 | 22 | pool-1-thread-1 | 获取淘宝上iphone14优惠
11:55:43.030 | 23 | pool-1-thread-2 | 获取京东上iphone14优惠完成：-150
11:55:43.030 | 22 | pool-1-thread-1 | 获取淘宝上iphone14优惠完成：-200
11:55:43.031 | 24 | pool-1-thread-3 | 获取pdd上iphone14优惠完成：-5300
11:55:43.040 | 22 | pool-1-thread-1 | 淘宝最终价格4999
11:55:43.040 | 24 | pool-1-thread-3 | 淘宝最终价格99
11:55:43.040 | 23 | pool-1-thread-2 | 淘宝最终价格5049
costs 2.08 second 
PriceResult{平台='淘宝平台价=5399, 优惠价=5300, 最终价=99}
```

使用Future + 线程池提高了任务处理的并行型。

### 6.使用CompletableFuture进一步增强并行

```java
	public PriceResult getCheapestPlatFormPriceWithCompletableFuture(String productName) {
        // 获取各个平台的价格、优惠
        ExecutorService pool = Executors.newFixedThreadPool(4);

        CompletableFuture<PriceResult> taobaoCF = CompletableFuture
                .supplyAsync(() -> HttpRequest.getTaoBaoPrice(productName))
                .thenCombine(CompletableFuture.supplyAsync(() -> HttpRequest.getTaoBaoDiscount(productName)),
                        (priceResult, discount) -> this.computeRealPrice(priceResult, discount));

        CompletableFuture<PriceResult> jingdongCF = CompletableFuture
                .supplyAsync(() -> HttpRequest.getJingDongPrice(productName))
                .thenCombine(CompletableFuture.supplyAsync(() -> HttpRequest.getJingDongDiscount(productName)),
                        (priceResult, discount) -> this.computeRealPrice(priceResult, discount));

        CompletableFuture<PriceResult> pddCF = CompletableFuture
                .supplyAsync(() -> HttpRequest.getPddPrice(productName))
                .thenCombine(CompletableFuture.supplyAsync(() -> HttpRequest.getJPddDiscount(productName)),
                        (priceResult, discount) -> this.computeRealPrice(priceResult, discount));

        // 计算最优平台价
        return Stream.of(taobaoCF, jingdongCF, pddCF)
                .map(CompletableFuture::join)
                .min(Comparator.comparing(PriceResult::getRealPrice))
                .get();
    }
```

```java
		// 3.CompletableFuture方式
        ComparePriceService comparePriceService = new ComparePriceService();
        long start = System.currentTimeMillis();
        PriceResult priceResult = comparePriceService.getCheapestPlatFormPriceWithCompletableFuture("iphone14");
        long end = System.currentTimeMillis();
        double costTime = (end - start) / 1000.0;
        System.out.printf("costs %.2f second \n", costTime);
        System.out.println(priceResult);

12:06:28.010 | 22 | ForkJoinPool.commonPool-worker-51 | 获取淘宝上iphone14价格
12:06:28.010 | 23 | ForkJoinPool.commonPool-worker-37 | 获取淘宝上iphone14优惠
12:06:28.010 | 26 | ForkJoinPool.commonPool-worker-59 | 获取pdd上iphone14价格
12:06:28.010 | 27 | ForkJoinPool.commonPool-worker-45 | 获取pdd上iphone14优惠
12:06:28.010 | 25 | ForkJoinPool.commonPool-worker-9 | 获取京东上iphone14优惠
12:06:28.010 | 24 | ForkJoinPool.commonPool-worker-23 | 获取京东上iphone14价格
12:06:29.043 | 26 | ForkJoinPool.commonPool-worker-59 | 获取pdd上iphone14价格完成：5399
12:06:29.043 | 25 | ForkJoinPool.commonPool-worker-9 | 获取京东上iphone14优惠完成：-150
12:06:29.043 | 24 | ForkJoinPool.commonPool-worker-23 | 获取京东上iphone14价格完成：5299
12:06:29.043 | 23 | ForkJoinPool.commonPool-worker-37 | 获取淘宝上iphone14优惠完成：-200
12:06:29.043 | 27 | ForkJoinPool.commonPool-worker-45 | 获取pdd上iphone14优惠完成：-5300
12:06:29.043 | 22 | ForkJoinPool.commonPool-worker-51 | 获取淘宝上iphone14价格完成：5199
12:06:29.052 | 22 | ForkJoinPool.commonPool-worker-51 | 淘宝最终价格4999
12:06:29.052 | 24 | ForkJoinPool.commonPool-worker-23 | 淘宝最终价格5049
12:06:29.052 | 27 | ForkJoinPool.commonPool-worker-45 | 淘宝最终价格99
costs 1.08 second 
PriceResult{平台='淘宝平台价=5399, 优惠价=5300, 最终价=99}
```

### 7.结合Stream API批量商品比价

测试在一个平台比价同款产品不同色系的价格

```java
	public PriceResult batchComparePrice(List<String> nameList) {
        // 1.便利每个商品名字。根据商品名称开启异步任务获取最终价， 最终价归集到list
        List<CompletableFuture<PriceResult>> list = nameList.stream().map(productName -> {
            return CompletableFuture
                    .supplyAsync(() -> HttpRequest.getTaoBaoPrice(productName))
                    .thenCombine(CompletableFuture.supplyAsync(() -> HttpRequest.getTaoBaoDiscount(productName)),
                            (((priceResult, discount) -> this.computeRealPrice(priceResult, discount))));
        }).collect(Collectors.toList());

        // 2.把多个商品最终价进行排序获取最小值
        return list.stream().map(CompletableFuture::join)
                .sorted(Comparator.comparing(PriceResult::getRealPrice))
                .findFirst()
                .get();
    }
```

```java
		// 4.CompletableFuture方式
        List<String> products = Arrays.asList("iphone14黑", "iphone14白", "iphone14红");
        ComparePriceService comparePriceService = new ComparePriceService();
        long start = System.currentTimeMillis();
        PriceResult priceResult = comparePriceService.batchComparePrice(products);
        long end = System.currentTimeMillis();
        double costTime = (end - start) / 1000.0;
        System.out.printf("costs %.2f second \n", costTime);
        System.out.println(priceResult);

12:22:17.922 | 24 | ForkJoinPool.commonPool-worker-23 | 获取淘宝上iphone14白价格
12:22:17.922 | 22 | ForkJoinPool.commonPool-worker-51 | 获取淘宝上iphone14黑价格
12:22:17.922 | 23 | ForkJoinPool.commonPool-worker-37 | 获取淘宝上iphone14黑优惠
12:22:17.922 | 27 | ForkJoinPool.commonPool-worker-45 | 获取淘宝上iphone14红优惠
12:22:17.922 | 26 | ForkJoinPool.commonPool-worker-59 | 获取淘宝上iphone14白优惠
12:22:17.922 | 25 | ForkJoinPool.commonPool-worker-9 | 获取淘宝上iphone14红价格
12:22:18.956 | 24 | ForkJoinPool.commonPool-worker-23 | 获取淘宝上iphone14白价格完成：5199
12:22:18.956 | 25 | ForkJoinPool.commonPool-worker-9 | 获取淘宝上iphone14红价格完成：5199
12:22:18.956 | 22 | ForkJoinPool.commonPool-worker-51 | 获取淘宝上iphone14黑价格完成：5199
12:22:18.956 | 27 | ForkJoinPool.commonPool-worker-45 | 获取淘宝上iphone14红优惠完成：-200
12:22:18.956 | 26 | ForkJoinPool.commonPool-worker-59 | 获取淘宝上iphone14白优惠完成：-200
12:22:18.956 | 23 | ForkJoinPool.commonPool-worker-37 | 获取淘宝上iphone14黑优惠完成：-200
12:22:18.963 | 23 | ForkJoinPool.commonPool-worker-37 | 淘宝最终价格4999
12:22:18.963 | 27 | ForkJoinPool.commonPool-worker-45 | 淘宝最终价格4999
12:22:18.963 | 26 | ForkJoinPool.commonPool-worker-59 | 淘宝最终价格4999
costs 1.09 second 
PriceResult{平台='淘宝平台价=5199, 优惠价=200, 最终价=4999}
```

