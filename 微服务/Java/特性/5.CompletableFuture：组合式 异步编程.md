分支/合并框架以及并行流是实现并行处理的工具；它们将一个操作分为多个子操作，在多个不同的核、 CPU甚至是机器上并行地执行这些子操作。  

实现并发，而非并行，或者你的主要目标是在同一个CPU上执行几个松耦合的任务，充分利用CPU的核，让其足够忙碌，从而最大化程序的吞吐量，那么你其实真正想做的是避免因为等待远程服务的返回，或者对数据库的查询，而阻塞线程的执行，浪费计算资源，因为这种等待的时间很可能相当长。  Future接口，尤其是它的新版实现CompletableFuture，是处理这种情况的利器。  

![image-20230311095307633](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230311095307633.png)

##  

Future接口在Java 5中被引入，设计初ᛱ是对将来某个时刻发生的结果进行建模。它建模了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。在Future中触发那些潜在耗时的操作把调用线程解放出来，让它能继续执行其他有价值的工作，不再需要等待耗时的操作完成。  

Future的另一个优点是它比更底层的Thread更易用。要使用Future，通常你只需要将耗时的操作封装在一个Callable对象中，再将它提交给ExecutorService。

![image-20230311095655369](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230311095655369.png)

如果该长时间运行的操作永远不返回了会怎样？为了处理这种可能性，推荐使用重载版本的get方法，它接受一个超时的参数，可以定义线程等待Future结果的最长时间 。



**异步任务工具类**：

```java
public class CommonUtils {
    // 读取指定路径文件
    public static String readFile(String pathFile) {
        try {
            return Files.readString(Paths.get(pathFile));
        } catch (Exception e) {
            e.printStackTrace();
            return "";
        }
    }

    // 休眠毫秒数
    public static void sleepMillis(long millis) {
        try {
            TimeUnit.MILLISECONDS.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    // 休眠秒数
    public static void sleepSecond(int seconds) {
        try {
            TimeUnit.SECONDS.sleep(seconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    // 打印输出带线程信息日志
    public static void printThreadLog(String msg) {
        String result = new StringJoiner(" | ")
                .add(String.valueOf(System.currentTimeMillis()))
                .add(String.format("%2d", Thread.currentThread().getId()))
                .add(String.valueOf(Thread.currentThread().getName()))
                .add(msg)
                .toString();

        System.out.println(result);
    }
}
```

测试：

![image-20230311103733468](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230311103733468.png)

## 一、Future 与 CompletableFuture

### 1、Future接口局限性

需求：替换新闻稿（news.txt）中敏感词汇，把敏感词汇替换为*，敏感词存储在filter_words.txt中

```
// filter_words.txt
尼玛,NB,tmd
```

```java
public class FutureDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        // 1.读取敏感词汇 可能是耗时任务  => thread1
        Future<String[]> filterWordsFuture = executorService.submit(()->{
            String content = CommonUtils.readFile("src/main/filter_words.txt");
            String[] filterWords = content.split(",");
            return filterWords;
        });

        // 2.读取新闻稿 可能是耗时任务 => thread2
        Future<String> newsFuture = executorService.submit(()->{
            return CommonUtils.readFile("src/main/news.txt");
        });

        // 3.替换操作 可能是耗时任务 => thread3
        Future<String> newsFutureReplaced = executorService.submit(()->{
            String[] words = filterWordsFuture.get();
            String content = newsFuture.get();

            for (String word : words) {
                if (content.indexOf(word) >= 0) {
                    content = content.replace(word, "**");
                }
            }

            return content;
        });

        // 4.打印输出替换后的新闻稿 => main
        String news = newsFutureReplaced.get();
        System.out.println("news:" + news);
    }
}

news:oh my god!completablefuture真**好用啊
```

这种实现下Thread3 依赖与 Thread1 、Thread2，main线程依赖thread3 的结果，如果不使用多线程，程序耗时较多；不足之处：

- 没有阻塞情况下，无法对future的结果执行进一步操作。Future不会告知完成时间，要得到结果，必须通过get方法，该方法为阻塞方法，直到结果可用为止。它不具备将回调函数附加到Future后并在Future的结果可用时自动调用回调的能力。
- 无法解决任务互相依赖的问题。例如上面的例子，filterWordsFuture和newsFuture的结果不能自动发送给newsFutureReplaced，需要在newsFutureReplaced中手动获取，因此Future不能轻易的创建异步工作流。
- 不能将多个Future合并在一起。假如有多种不同future，想在他们完成之后在运行某个函数，future很难独立完成这个目标。
- 没有异常处理。Future没有提供专门的异常处理api，需要手动处理异常。

### 2.、CompletableFuture的优势

![image-20230311110217923](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230311110217923.png)

相对Future的优势：

- 为快速创建、连接依赖和组合多个Future提供了大量的便利方法
- 提供了适用于各种开发场景的回调函数，提供了非常全面的异常处理支持
- 无缝衔接 lambda表达式和Stream api
- 把异步编程与函数式编程、响应式编程基于一身



## 二、创建异步任务

### 1.runAsync

如果需要异步运行某些耗时的后台任务，并且不想从任务中返回任务内容，则可以使用CompletableFuture.runAsync方法，接受一个Runnable接口的实现类对象，返回CompletableFuture<void>对象：

```java
	public static CompletableFuture<Void> runAsync(Runnable runnable) {
        return asyncRunStage(ASYNC_POOL, runnable);
    }

	// runnable 接口是没有返回值，为void ，所以接口的泛型是void
```

Demo: 创建一个不从任务中返回任务内容的CompletableFuture异步对象

```java
public class RunAsyncDemo {
    public static void main(String[] args) {
        CommonUtils.printThreadLog("main start");

        // 开启一个异步任务读取文件
        CompletableFuture.runAsync(new Runnable() {
            @Override
            public void run() {
                CommonUtils.printThreadLog("读取文件开始");
                CommonUtils.sleepSecond(3);
                CommonUtils.printThreadLog("读取文件结束");
            }
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.sleepSecond(4); // 让异步任务有机会执行
        CommonUtils.printThreadLog("main end");
    }
}

1678504668848 |  1 | main | main start
1678504668864 |  1 | main | main continue
1678504668865 | 22 | ForkJoinPool.commonPool-worker-51 | 读取文件开始
1678504671868 | 22 | ForkJoinPool.commonPool-worker-51 | 读取文件结束
1678504672865 |  1 | main | main end
```

**CompletableFuture 中的异步任务底层提供开启线程方式完成的。**

结合**函数式编程**：

```java
public class RunAsyncLambdaDemo {
    public static void main(String[] args) {
        CommonUtils.printThreadLog("main start");

        // 开启一个异步任务读取文件
        CompletableFuture.runAsync(()->{
            CommonUtils.printThreadLog("读取文件开始");
            CommonUtils.sleepSecond(3);
            CommonUtils.printThreadLog("读取文件结束");
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.sleepSecond(4);
        CommonUtils.printThreadLog("main end");
    }
}

1678505300296 |  1 | main | main start
1678505300315 |  1 | main | main continue
1678505300315 | 22 | ForkJoinPool.commonPool-worker-51 | 读取文件开始
1678505303325 | 22 | ForkJoinPool.commonPool-worker-51 | 读取文件结束
1678505304316 |  1 | main | main end
```

需求： 使用CompletableFuture开启异步任务读取news.txt 文件的新闻稿，并打印输出：

```java
public class RunAsyncNewsPrintDemo {
    public static void main(String[] args) {
        CommonUtils.printThreadLog("main start");

        // 开启一个异步任务读取文件
        CompletableFuture.runAsync(()->{
            System.out.println("read file");
            String content = CommonUtils.readFile("src/main/news.txt");
            System.out.println(content);
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.sleepSecond(4);
        CommonUtils.printThreadLog("main end");
    }
}

1678505490902 |  1 | main | main start
1678505490919 |  1 | main | main continue
read file
oh my god!completablefuture真tmd好用啊
1678505494920 |  1 | main | main end
```

**异步任务是并发执行还是并行执行？** 

**如果是单核CPU，那么异步任务之间就是并发执行，如果是多核CPU或多CPU， 异步任务就是并行执行。**开发者只需要知道如何开启异步任务，CPU硬件会把异步任务合理的分配给CPU上的核运行，即硬件决定。

### 2.supplyAsync

想从异步任务中返回一个结果怎么办？可以使用CompletableFuture.supplyAsync方法：

```java
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier) {
    return asyncSupplyStage(ASYNC_POOL, supplier);
}
```

入参Supplier<U> 供给者，用于供给带返回值的异步任务，并返回CompletableFuture<U>，U是供给者给程序供给值的类型。

需求： 开启异步任务读取news.txt 文件中的新闻稿，返回文件内容并在**主线程中打印输出**：

```java
public class SupplyAsyncNewsPrintDemo {
    public static void main(String[] args) {
        CommonUtils.printThreadLog("main start");

        // 开启一个异步任务读取文件
        CompletableFuture<String> news = CompletableFuture.supplyAsync(new Supplier<String>() {
            @Override
            public String get() {
                return CommonUtils.readFile("src/main/news.txt");
            }
        });

        CommonUtils.printThreadLog("main continue");
        System.out.println(news.get());
        CommonUtils.printThreadLog("main end");
    }
}

1678506612919 |  1 | main | main start
1678506612933 |  1 | main | main continue
oh my god!completablefuture真tmd好用啊
1678506612936 |  1 | main | main end
```

如果想要获取newsFuture结果，可以调用get方法。get方法会阻塞，直到newsFuture完成。

函数式编程：

```java
public class SupplyAsyncNewsPrintDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        // 开启一个异步任务读取文件
        CompletableFuture<String> news = CompletableFuture.supplyAsync(()->{
            return CommonUtils.readFile("src/main/news.txt");
        });

        CommonUtils.printThreadLog("main continue");
        System.out.println(news.get());
        CommonUtils.printThreadLog("main end");
    }
}

1678506612919 |  1 | main | main start
1678506612933 |  1 | main | main continue
oh my god!completablefuture真tmd好用啊
1678506612936 |  1 | main | main end
```

**get方法是阻塞的，会不会影响程序性能？**

**使用回调函数解决**

### 3.异步任务中的线程池

代码中没有显示创建线程，那么CompletableFuture使用的线程从哪里获取的呢？

**CompletableFuture会从全局的ForkJoinPool.commonPool（）线程池获取线程执行任务。**

也可以自己创建线程池，将其传给runSync/suppluAsync方法，让他们从指定线程池中获取线程执行任务：

```java
	public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor) {
        return asyncRunStage(screenExecutor(executor), runnable);
    }
    
	public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor) {
        return asyncSupplyStage(screenExecutor(executor), supplier);
    }
```

CompletableFuture中的所有api都有两种变体，即从默认线程池中获取线程执行，或者从指定线程池中获取线程执行。

需求：指定线程池，开启异步任务读取 news.txt 中的新闻稿，返回文件在内容并在主线程中打印输出：

```java
public class SupplyAsyncNewsPrintWithThreadPoolDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        ExecutorService executor = Executors.newFixedThreadPool(5);
        // 开启一个异步任务读取文件
        CompletableFuture<String> news = CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/news.txt");
        }, executor);

        CommonUtils.printThreadLog("main continue");
        System.out.println(news.get());
        CommonUtils.printThreadLog("main end");
    }
}

1678507252610 |  1 | main | main start
1678507252627 |  1 | main | main continue
1678507252627 | 22 | pool-1-thread-1 | read file
oh my god!completablefuture真tmd好用啊
1678507252630 |  1 | main | main end
```

执行完上面的代码，会发现程序并没有结束，这是为什么呢？

**因为默认线程池是归主线程管理，主线程结束会把默认线程池关闭掉，指定线程池后，指定线程池归开发者管理，主线程不会自动关闭该线程池，所以会一直等待异步任务。**

```java
public class SupplyAsyncNewsPrintWithThreadPoolDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        ExecutorService executor = Executors.newFixedThreadPool(5);
        // 开启一个异步任务读取文件
        CompletableFuture<String> news = CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/news.txt");
        }, executor);

        CommonUtils.printThreadLog("main continue");
        System.out.println(news.get());
        executor.shutdown();	// ***** 需要手动调用该方法关闭线程池
        CommonUtils.printThreadLog("main end");
    }
}
```

***最佳实践：***

***创建属于自己的线程池，如果所有CompletableFuture共享一个线程池，那么一旦有异步任务执行一些很慢的I/O操作，会导致线程池中所有线程都阻塞在I/O操作上，从而导致线程饥饿，影响系统性能。所以，不同业务需要使用不同的线程池，避免相互干扰。***



### 4.异步编程思想

**线程的创建和线程负责的任务进行解耦，好处是线程的创建和启动全部交给线程池负责，具体任务交给开发者。**

异步编程是可以让程序并发/并行的一种手段，可以让程序中的一个工作单元作为异步任务与主线程独立运行，并且在异步任务运行结束后，通知主线程它的运行结果或者失败原因，提高程序的性能和响应。

开发者只需要把耗时操作交给CompletableFuture开启一个异步任务，继续关注主线程业务，当异步任务运行完成时通知主线程它的运行结果。这种思想的开发就是异步编程思想。

## 三、任务异步回调

get方法是阻塞的，调用时它会阻塞等待future完成。对于构建异步系统，应该能够将回调附加到CompletableFuture上，当这个future完成时，该回调应自动被调用，这样就不用等待结果。

thenApply、thenAccept、thenRun方法将回调函数附加到CompletableFuture。

### 1.thenApply

使用thenApply方法可以处理和转换CompletableFuture结果。Function<? super T,? extends U>是一个函数式接口，表示一个转换操作，接收类型T参数并产生类型U的结果。

```java
	public <U> CompletableFuture<U> thenApply(
        Function<? super T,? extends U> fn) {
        return uniApplyStage(null, fn);
    }
```

需求 ： 异步读取filter_words.txt文件内容，读取后，把内容转换为数组，异步任务返回敏感词数组

```java
public class ComplelableFutureThenApplyDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<String> content = CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/filter_words.txt");
        });

        CompletableFuture<String[]> filterWordsFuture = content.thenApply(result -> {
            CommonUtils.printThreadLog("split content");
            return result.split(",");
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(filterWordsFuture.get()));
        CommonUtils.printThreadLog("main end");
    }
}

1678512166927 |  1 | main | main start
1678512166943 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678512166943 |  1 | main | main continue
1678512166945 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678512166953 |  1 | main | filter words:[尼玛, NB, tmd]
1678512166953 |  1 | main | main end
```

可以对异步任务的结果进一步应用function转换，转换后的结果可以在主线程获取，也可以进行下一步转换。

**链式操作**：

```java
public class ComplelableFutureThenApplyLinkDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<String[]> filterWordsFuture = CompletableFuture.supplyAsync(() -> {
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/filter_words.txt");
        }).thenApply(result -> {
            CommonUtils.printThreadLog("split content");
            return result.split(",");
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(filterWordsFuture.get()));
        CommonUtils.printThreadLog("main end");
    }
}

1678512429793 |  1 | main | main start
1678512429811 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678512429811 |  1 | main | main continue
1678512429813 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678512429824 |  1 | main | filter words:[尼玛, NB, tmd]
1678512429824 |  1 | main | main end
```



### 2.thenAccept

不想从回调函数返回结果，执行在Future结束后运行一些代码，则可以使用thenAccept。

入参是Consumer<? super T> ，可以对异步任务的执行结果进行使用，返回 CompletableFuture<Void>

```java
public CompletableFuture<Void> thenAccept(Consumer<? super T> action) {
    return uniAcceptStage(null, action);
}
```

通常作为调用链中最后一个回调。

需求： 异步读取filter_words文件，转换为数组，并打印

```java
public class ComplelableFutureThenAcceptDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/filter_words.txt");
        }).thenApply(result -> {
            CommonUtils.printThreadLog("split content");
            return result.split(",");
        }).thenAccept(result -> {
            CommonUtils.printThreadLog("filter words:" + Arrays.toString(result));
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.sleepSecond(4);
        CommonUtils.printThreadLog("main end");
    }
}

1678512833859 |  1 | main | main start
1678512833876 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678512833876 |  1 | main | main continue
1678512833878 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678512833886 | 22 | ForkJoinPool.commonPool-worker-51 | filter words:[尼玛, NB, tmd]
1678512837882 |  1 | main | main end
```



### 3.thenRun

如果只想从CompletableFuture的链式操作得到一个完成的通知，不使用上一步操作结果，可以使用thenRun方法，返回 CompletableFuture<Void>。

```java
	public CompletableFuture<Void> thenRun(Runnable action) {
        return uniRunStage(null, action);
    }
```

需求： 仅仅想知道 filter_word文件是否读取完成。

```java
public class ComplelableFutureThenRunDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/filter_words.txt");
        }).thenAccept(result -> {
            CommonUtils.printThreadLog("read finish");
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.sleepSecond(4);
        CommonUtils.printThreadLog("main end");
    }
}

1678513431398 |  1 | main | main start
1678513431415 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678513431415 |  1 | main | main continue
1678513431417 | 22 | ForkJoinPool.commonPool-worker-51 | read finish
1678513435418 |  1 | main | main end
```



### 4.进一步提升并行化

CompletableFuture提供的回调方法都有两个变体：

```java
	// 一般回调方法
	public <U> CompletableFuture<U> thenApply(
        Function<? super T,? extends U> fn) {
        return uniApplyStage(null, fn);
    }

	// 异步回调方法
    public <U> CompletableFuture<U> thenApplyAsync(
        Function<? super T,? extends U> fn) {
        return uniApplyStage(defaultExecutor(), fn);
    }

    // 异步指定线程池回调方法
    public <U> CompletableFuture<U> thenApplyAsync(
        Function<? super T,? extends U> fn, Executor executor) {
        return uniApplyStage(screenExecutor(executor), fn);
    }
```

带了Async的异步回调 通过在单独的线程中执行回调任务，进一步提升并行化。

**回顾需求： 异步读取filter_words文件，转换为数组，主线程获取结果并打印**

一般而言，commonPool为了提供性能，不会立马回收线程，thenApply中回调任务和SupplyAsync异步任务使用的同一个线程。特殊情况，如果SupplyAsync的任务是立马返回结果的，没有耗时操作，则后续回调任务都可能是在主线程中执行。

```java
public class ComplelableFutureThenApplyDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<String[]> filterWordsFuture = CompletableFuture.supplyAsync(()->{
            return "ttt,wwww";
        }).thenApply(result -> {
            CommonUtils.printThreadLog("split content");
            return result.split(",");
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(filterWordsFuture.get()));
        CommonUtils.printThreadLog("main end");
    }
}

// 返回结果1：内部优化导致，与当前电脑状态有关
1678514175164 |  1 | main | main start
1678514175179 |  1 | main | main continue
1678514175179 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678514175186 |  1 | main | filter words:[ttt, wwww]
1678514175186 |  1 | main | main end
    
// 返回结果2
1678514228529 |  1 | main | main start
1678514228546 |  1 | main | split content
1678514228546 |  1 | main | main continue
1678514228554 |  1 | main | filter words:[ttt, wwww]
1678514228554 |  1 | main | main end
```

要更好的控制回调任务的线程，可以使用异步回调，thenApplyAsync回调，将在从线程池中获取一个线程执行。

```java
public class ComplelableFutureThenApplyAsyncDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<String[]> filterWordsFuture = CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/filter_words.txt");
        }).thenApplyAsync(result -> {
            CommonUtils.printThreadLog("split content");
            return result.split(",");
        });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(filterWordsFuture.get()));
        CommonUtils.printThreadLog("main end");
    }
}

// 运行结果1
1678514502184 |  1 | main | main start
1678514502199 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678514502199 |  1 | main | main continue
1678514502202 | 23 | ForkJoinPool.commonPool-worker-37 | split content
1678514502209 |  1 | main | filter words:[尼玛, NB, tmd]
1678514502209 |  1 | main | main end

// 运行结果2  内部优化导致，与当前电脑状态有关
1678514564687 |  1 | main | main start
1678514564703 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678514564703 |  1 | main | main continue
1678514564706 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678514564714 |  1 | main | filter words:[尼玛, NB, tmd]
1678514564714 |  1 | main | main end
```



## 四、异步任务编排

### 1.编排2个依赖关系的异步任务 thenCompose（）

需求回顾： 异步读取filter_words 文件，转换为数组，让主线程使用

```java
public class ComplelableFutureThenComposeDemo {

    public static CompletableFuture<String> readFileFuture(String fileName) {
        return CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile(fileName);
        });
    }

    public static CompletableFuture<String[]> splitFileFuture(String content) {
        return CompletableFuture.supplyAsync(()->{
            CommonUtils.printThreadLog("split content");
            return content.split(",");
        });
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<CompletableFuture<String[]>> completableFutureCompletableFuture = readFileFuture("src/main/filter_words.txt")
                .thenApply((content) -> {
                    return splitFileFuture(content);
                });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(completableFutureCompletableFuture.get().get()));
        CommonUtils.printThreadLog("main end");
    }
}


1678515318158 |  1 | main | main start
1678515318174 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678515318175 |  1 | main | main continue
1678515318177 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678515318185 |  1 | main | filter words:[尼玛, NB, tmd]
1678515318186 |  1 | main | main end
```

在之前的案例中，thenAppy中的function会对上一步任务结果转换后得到一个值，这种情况下，最终结果是嵌套的CompletableFuture，不符合预期，怎么办？

想要的是：把上一步任务的结果，转换一个CompletableFuture对象。这个对象包含本次异步任务处理结果。即想组合上一步异步任务的结果到下一个异步任务中，结果有这个新的异步任务返回。

这时可以使用thenCompose方法，即异步任务组合，用来连接两个有**依赖关系**的异步任务，结果由第二任务返回。

```java
	public <U> CompletableFuture<U> thenCompose(
        Function<? super T, ? extends CompletionStage<U>> fn) {
        return uniComposeStage(null, fn);
    }

    public <U> CompletableFuture<U> thenComposeAsync(
        Function<? super T, ? extends CompletionStage<U>> fn) {
        return uniComposeStage(defaultExecutor(), fn);
    }

    public <U> CompletableFuture<U> thenComposeAsync(
        Function<? super T, ? extends CompletionStage<U>> fn,
        Executor executor) {
        return uniComposeStage(screenExecutor(executor), fn);
    }
```

优化后：

```java
public class ComplelableFutureThenComposeDemo {

    public static CompletableFuture<String> readFileFuture(String fileName) {
        return CompletableFuture.supplyAsync(() -> {
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile(fileName);
        });
    }

    public static CompletableFuture<String[]> splitFileFuture(String content) {
        return CompletableFuture.supplyAsync(() -> {
            CommonUtils.printThreadLog("split content");
            return content.split(",");
        });
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<String[]> future = readFileFuture("src/main/filter_words.txt")
                .thenCompose((content) -> {
                    return splitFileFuture(content);
                });

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(future.get()));
        CommonUtils.printThreadLog("main end");
    }
    // 或者
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CommonUtils.printThreadLog("main start");

        CompletableFuture<String[]> completableFuture = CompletableFuture.supplyAsync(() -> {
            CommonUtils.printThreadLog("read file");
            return CommonUtils.readFile("src/main/filter_words.txt");
        }).thenCompose(content -> CompletableFuture.supplyAsync(() -> {
            CommonUtils.printThreadLog("split content");
            return content.split(",");
        }));

        CommonUtils.printThreadLog("main continue");
        CommonUtils.printThreadLog("filter words:" + Arrays.toString(completableFuture.get()));
        CommonUtils.printThreadLog("main end");
    }
}

// 结果1
1678515626622 |  1 | main | main start
1678515626637 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678515626638 |  1 | main | main continue
1678515626641 | 22 | ForkJoinPool.commonPool-worker-51 | split content
1678515626650 |  1 | main | filter words:[尼玛, NB, tmd]
1678515626650 |  1 | main | main end
    
// 结果2
1678516179454 |  1 | main | main start
1678516179470 | 22 | ForkJoinPool.commonPool-worker-51 | read file
1678516179470 |  1 | main | main continue
1678516179473 | 23 | ForkJoinPool.commonPool-worker-37 | split content
1678516179481 |  1 | main | filter words:[尼玛, NB, tmd]
1678516179481 |  1 | main | main end
```

### 2.编排两个非依赖关系的异步任务 thenCombine

如果两个future之间没有依赖关系，但是希望两个future独立运行，并且在两个都完成之后执行回调操作，则使用thenCombine方法。

```java

```

T是第一个任务的结果，U是第二个任务的结果，V是经BiFunction应用转换后的结果。

需求： 替换新闻稿news.txt文件敏感词为*，敏感词在filter_words文件中

```

```

