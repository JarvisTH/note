## 一、运行时数据区域

### 1.程序计数器

程序计数器（Program Counter Register） 是一块较小的内存空间， 它可以看作是当前线程所执行的字节码的行号指示器。  字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令， 它是程序控制流的指示器， 分支、 循环、 跳转、 异常处理、 线程恢复等基础功能都需要依赖这个计数器来完成。  

由于Java虚拟机的多线程是通过线程轮流切换、 分配处理器执行时间的方式来实现的， 在任何一个确定的时刻， 一个处理器（对于多核处理器来说是一个内核） 都只会执行一条线程中的指令。 因此， 为了线程切换后能恢复到正确的执行位置， 每条线程都需要有一个独立的程序计数器， 各条线程之间计数器互不影响， 独立存储， 我们称这类内存区域为“**线程私有**”的内存。  

如果线程正在执行的是一个Java方法， 这个计数器记录的是正在执行的虚拟机字节码指令的地址； 如果正在执行的是本地（Native） 方法， 这个计数器值则应为空（Undefined） 。 此内存区域是唯一一个在《Java虚拟机规范》 中没有规定任何OutOfMemoryError情况的区域。  

### 2.Java虚拟机栈

Java虚拟机栈（Java Virtual Machine Stack） 也是**线程私有**的， 它的生命周期与线程相同。  

虚拟机栈描述的是Java方法执行的线程内存模型： 每个方法被执行的时候， Java虚拟机都会同步创建一个栈帧（Stack Frame） 用于存储局部变量表、 操作数栈、 动态连接、 方法出口等信息。 每一个方法被调用直至执行完毕的过程， 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。  

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、 byte、 char、 short、 int、float、 long、 double） 、 对象引用（reference类型， 它并不等同于对象本身， 可能是一个指向对象起始地址的引用指针， 也可能是指向一个代表对象的句柄或者其他与此对象相关的位置） 和returnAddress类型（指向了一条字节码指令的地址） 。  

这些数据类型在局部变量表中的存储空间以局部变量槽（Slot） 来表示， 其中64位长度的long和double类型的数据会占用两个变量槽， 其余的数据类型只占用一个。 局部变量表所需的内存空间在编译期间完成分配， 当进入一个方法时， 这个方法需要在栈帧中分配多大的局部变量空间是完全确定的， 在方法运行期间不会改变局部变量表的大小（变量槽的数量）。   

对这个内存区域规定了两类异常状况：

-  如果线程请求的栈深度大于虚拟机所允许的深度， 将抛出**StackOverflowError异常**； 
- 如果Java虚拟机栈容量可以动态扩展， 当栈扩展时无法申请到足够的内存会抛出**OutOfMemoryError异常**。（HotSpot虚拟机的栈容量是不可以动态扩展的， 以前的Classic虚拟机倒是可以。 所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不会有OOM， 但是如果申请时就失败， 仍然是会出现OOM异常的。）  

### 3.本地方法栈

本地方法栈是为虚拟机使用到的本地（Native）方法服务。  与虚拟机栈一样， 本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出**StackOverflowError和OutOfMemoryError异常**。  

### 4.**Java堆**

Java堆是被**所有线程共享**的一块内存区域， 在虚拟机**启动时创建**。  此内存区域的唯一目的就是存放对象实例， Java世界里“几乎”所有的对象实例都在这里分配内存。   

Java堆是垃圾收集器管理的内存区域，也被称作“GC堆”。

如果从分配内存的角度看， 所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer， TLAB）， 以提升对象分配时的效率。   将Java堆细分的目的只是为了更好地回收内存， 或者更快地分配内存。  

Java堆可以处于物理上不连续的内存空间中， 但在逻辑上它应该被视为连续的。

Java堆既可以被实现成固定大小的， 也可以是可扩展的， 不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定） 。 如果在Java堆中没有内存完成实例分配， 并且堆也无法再扩展时， Java虚拟机将会抛出**OutOfMemoryError异常**。  

### 5.方法区

方法区（Method Area） 是各个**线程共享**的内存区域， 它用于存储已被虚拟机加载的类型信息、 常量、 静态变量、 即时编译器编译后的代码缓存等数据。   

在JDK 8以前 ，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），到了JDK 7的HotSpot， 已经把原本放在永久代的字符串常量池、 静态变量等移出， 而到了JDK 8， 终于完全废弃了永久代的概念， 改用与JRockit、 J9一样在本地内存中实现的元空间（Metaspace） 来代替， 把JDK 7中永久代还剩余的内容（主要是类型信息） 全部移到元空间中。  

这区域的内存回收目标主要是针对常量池的回收和对类型的卸载， 一般来说这个区域的回收效果比较难令人满意。

 如果方法区无法满足新的内存分配需求时， 将抛出**OutOfMemoryError异常**。  

### 6.运行时常量池

运行时常量池（Runtime Constant Pool） 是方法区的一部分。 Class文件中除了有类的版本、 字段、 方法、 接口等描述信息外， 还有一项信息是常量池表（Constant Pool Table） ， 用于存放编译期生成的各种字面量与符号引用， 这部分内容将在类加载后存放到方法区的运行时常量池中。  

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性， Java语言并不要求常量一定只有编译期才能产生， 也就是说， 并非预置入Class文件中常量池的内容才能进入方法区运行时常量池， 运行期间也可以将新的常量放入池中， 这种特性被开发人员利用得比较多的便是**String类的intern()方法**。  

既然运行时常量池是方法区的一部分， 自然受到方法区内存的限制， 当常量池无法再申请到内存时会抛出**OutOfMemoryError异常**。  

### 7.直接内存

直接内存（Direct Memory） 并**不是虚拟机运行时数据区的一部分**， 也不是《Java虚拟机规范》 中定义的内存区域，也可能导致OutOfMemoryError异常出现 。  

在JDK 1.4中新加入了NIO（New Input/Output） 类， 引入了一种基于通道（Channel） 与缓冲区（Buffer） 的I/O方式， 它可以使用Native函数库直接分配堆外内存， 然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。 这样能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据。  

本机直接内存的分配不会受到Java堆大小的限制， 但是， 既然是内存， 则肯定还是会受到本机总内存（包括物理内存、 SWAP分区或者分页文件） 大小以及处理器寻址空间的限制， 一般服务器管理员配置虚拟机参数时， 会根据实际内存去设置-Xmx等参数信息， 但经常忽略掉直接内存， 使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制） ， 从而导致动态扩展时出现**OutOfMemoryError异常**。  

## 二、hotspot虚拟机中的对象

### 1.对象的创建

当Java虚拟机遇到一条字节码new指令时， 首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用， 并且检查这个符号引用代表的类是否已被加载、 解析和初始化过。 如果没有， 那必须先执行相应的类加载过程。

在类加载检查通过后， 接下来虚拟机将为新生对象分配内存。 对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。   

假设Java堆中内存是绝对规整的， 所有被使用过的内存都被放在一边， 空闲的内存被放在另一边， 中间放着一个指针作为分界点的指示器， 那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离， 这种分配方式称为**“指针碰撞”**（Bump The Pointer）。

如果Java堆中的内存并不是规整的， 已被使用的内存和空闲的内存相互交错在一起， 那就没有办法简单地进行指针碰撞了， 虚拟机就必须维护一个列表， 记录上哪些内存块是可用的， 在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录， 这种分配方式称为**“空闲列表”**（Free List） 。   

选择哪种分配方式由Java堆是否规整决定， 而Java堆是否规整又由所采用的垃圾收集器是否带有**空间压缩整理（Compact）** 的能力决定。 因此， 当使用Serial、 ParNew等带压缩整理过程的收集器时， 系统采用的分配算法是指针碰撞， 既简单又高效； 而当使用CMS这种基于清除（Sweep） 算法的收集器时， 理论上[1就只能采用较为复杂的空闲列表来分配内存。  

对象创建在虚拟机中是非常频繁的行为， 即使仅仅修改一个指针所指向的位置， 在并发情况下也并不是线程安全的， 可能出现正在给对象A分配内存， 指针还没来得及修改， 对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：

- 对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；
- 把内存分配的动作按照线程划分在不同的空间之中进行， 即每个线程在Java堆中预先分配一小块内存， 称为本地线程分配缓冲（Thread Local Allocation Buffer， TLAB） ， 哪个线程要分配内存， 就在哪个线程的本地缓冲区中分配， 只有本地缓冲区用完
  了， 分配新的缓存区时才需要同步锁定。 虚拟机是否使用TLAB， 可以通过-XX： +/-UseTLAB参数来设定。  

内存分配完成之后， 虚拟机必须将分配到的内存空间（但不包括对象头） 都初始化为零值， 如果使用了TLAB的话， 这一项工作也可以提前至TLAB分配时顺便进行。 这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用， 使程序能访问到这些字段的数据类型所对应的零值。  

接下来， Java虚拟机还要对对象进行必要的设置 ，主要是设置对象头信息。

在上面工作都完成之后， 从虚拟机的视角来看， 一个新的对象已经产生了。  

从Java程序的视角看来， 对象创建才刚刚开始——构造函数， 即Class文件中的<init>()方法还没有执行， 所有的字段都为默认的零值， 对象需要的其他资源和状态信息也还没有按照预定的意图构造好。   一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定， Java编译器会在遇到new关键字的地方同时生成这两条字节码指令， 但如果直接通过其他方式产生的则不一定如此） ， new指令之后会接着执行<init>()方法， 按照程序员的意愿对对象进行初始化， 这样一个真正可用的对象才算完全被构造出来。  

### 2.对象的内存布局

在HotSpot虚拟机里， 对象在堆内存中的存储布局可以划分为三个部分： 对象头（Header） 、 实例数据（Instance Data） 和对齐填充（Padding） 。  

HotSpot虚拟机对象的**对象头部分包括两类信息**。   第一类是用于存储对象自身的运行时数据， 如哈希码（HashCode） 、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等， 这部分数据的长度在32位和64位的虚拟机（未开启压缩指针） 中分别为32个比特和64个比特， 官方称它为**“Mark Word”**。 对象需要存储的运行时数据很多， 其实已经超出了32、 64位Bitmap结构所能记录的最大限度， 但对象头里的信息是与对象自身定义的数据无关的额外存储成本， 考虑到虚拟机的空间效率， Mark Word被设计成一个有着动态定义的数据结构， 以便在极小的空间内存储尽量多的数据， 根据对象的状态复用自己的存储空间。   

对象头的另外一部分是类型指针， 即对象指向它的类型元数据的指针， Java虚拟机通过这个指针来确定该对象是哪个类的实例。   

接下来实例数据部分是对象真正存储的有效信息， 即我们在程序代码里面所定义的各种类型的字段内容， 无论是从父类继承下来的， 还是在子类中定义的字段都必须记录起来。 这部分的存储顺序会受到虚拟机分配策略参数（-XX： FieldsAllocationStyle参数） 和字段在Java源码中定义顺序的影响。  

HotSpot虚拟机默认的分配顺序为longs/doubles、 ints、 shorts/chars、 bytes/booleans、 oops（Ordinary Object Pointers， OOPs） ， 从以上默认的分配策略中可以看到， 相同宽度的字段总是被分配到一起存放， 在满足这个前提条件的情况下， 在父类中定义的变量会出现在子类之前。 如果HotSpot虚拟机的+XX： CompactFields参数值为true（默认就为true） ， 那子类之中较窄的变量也允许插入父类变量的空隙之中， 以节省出一点点空间。  

对象的第三部分是对齐填充， 这并不是必然存在的， 也没有特别的含义， 它仅仅起着占位符的作用。  HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍， 换句话说就是任何对象的大小都必须是8字节的整数倍。 对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍） ， 因此， 如果对象实例数据部分没有对齐的话， 就需要通过对齐填充来补全。  

### 3.对象的访问定位

主流的访问方式主要有使用句柄和直接指针两种：  

- 使用句柄访问的话， Java堆中将可能会划分出一块内存来作为句柄池， reference中存储的就是对象的句柄地址， 而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

![image-20230320204003118](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230320204003118.png)

- 使用直接指针访问的话， Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息， reference中存储的直接就是对象地址， 如果只是访问对象本身的话， 就不需要多一次间接访问的开销。

![image-20230320204036525](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230320204036525.png)

## 三、垃圾收集器

### 1.对象是否死亡

垃圾收集器在对堆进行回收前， 第一件事情就是要确定这些对象之中哪些还“存活”着， 哪些已经“死去”。

#### 1.引用计数器

在对象中添加一个引用计数器， 每当有一个地方引用它时， 计数器值就加一； 当引用失效时， 计数器值就减一； 任何时刻计数器为零的对象就是不可能再被使用的。   

主流的Java虚拟机里面都没有选用引用计数算法来管理内存， 主要原因是， 这个看似简单的算法有很多例外情况要考虑， 必须要配合大量额外处理才能保证正确地工作， 譬如单纯的引用计数就**很难解决对象之间相互循环引用**的问题 ——对象objA和objB都有字段instance， 赋值令objA.instance=objB及objB.instance=objA， 除此之外， 这两个对象再无任何引用， 实际上这两个对象已经不可能再被访问， 但是它们因为互相引用着对方， 导致它们的引用计数都不为零， 引用计数算法也就无法回收它们。  

#### 2.可达性分析

当前主流的商用程序语言（Java、 C#， 上溯至前面提到的古老的Lisp） 的内存管理子系统， 都是通过**可达性分析（Reachability Analysis） 算法**来判定对象是否存活的。  

基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集， 从这些节点开始， 根据引用关系向下搜索， 搜索过程所走过的路径称为“引用链”（Reference Chain） ， 如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时， 则证明此对象是不可能再被使用的。  

![image-20230320204707507](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230320204707507.png)



在Java技术体系里面， 固定**可作为GC Roots的对象**包括以下几种：  

- 在虚拟机栈（栈帧中的本地变量表） 中引用的对象， 譬如各个线程被调用的方法堆栈中使用到的
  参数、 局部变量、 临时变量等。
- 在方法区中类静态属性引用的对象， 譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象， 譬如字符串常量池（String Table） 里的引用。  
- 在本地方法栈中JNI（即通常所说的Native方法） 引用的对象。
- Java虚拟机内部的引用， 如基本数据类型对应的Class对象， 一些常驻的异常对象（比如NullPointExcepiton、 OutOfMemoryError） 等， 还有系统类加载器。
- 所有被同步锁（synchronized关键字） 持有的对象。
- 反映Java虚拟机内部情况的JMXBean、 JVMTI中注册的回调、 本地代码缓存等。  

根据用户所选用的垃圾收集器以及当前回收的内存区域不同， 还可以有其他对象“临时性”地加入， 共同构成完整GC Roots集合。   譬如后文将会提到的分代收集和局部回收（Partial GC） ， 如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集） ， 必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的） ， 更不是孤立封闭的， 所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用， 这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去， 才能保证可达性分析的正确性。  

#### 3.引用

在JDK 1.2版之前， 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址， 就称该reference数据是代表某块内存、 某个对象的引用。   

JDK 1.2版之后， Java对引用的概念进行了扩充， 将引用分为强引用（Strongly Re-ference） 、 软引用（Soft Reference） 、 弱引用（Weak Reference） 和虚引用（Phantom Reference） 4种， 这4种引用强度依次逐渐减弱。  

- 强引用是最传统的“引用”的定义， 是指在程序代码之中普遍存在的引用赋值， 即类似“Object obj=new Object()”这种引用关系。 无论任何情况下， 只要强引用关系还存在， 垃圾收集器就永远不会回收掉被引用的对象。
- 软引用是用来描述一些还有用， 但非必须的对象。 只被软引用关联着的对象， 在系统将要发生内存溢出异常前， 会把这些对象列进回收范围之中进行第二次回收， 如果这次回收还没有足够的内存，才会抛出内存溢出异常。 在JDK 1.2版之后提供了SoftReference类来实现软引用。
- 弱引用也是用来描述那些非必须对象， 但是它的强度比软引用更弱一些， 被弱引用关联的对象只能生存到下一次垃圾收集发生为止。 当垃圾收集器开始工作， 无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。 在JDK 1.2版之后提供了WeakReference类来实现弱引用。
- 虚引用也称为“幽灵引用”或者“幻影引用”， 它是最弱的一种引用关系。 一个对象是否有虚引用的存在， 完全不会对其生存时间构成影响， 也无法通过虚引用来取得一个对象实例。 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。 在JDK 1.2版之后提供了PhantomReference类来实现虚引用。  

#### 4.是否死亡

即使在可达性分析算法中判定为不可达的对象， 也不是“非死不可”的， 这时候它们暂时还处于“缓刑”阶段， 要真正宣告一个对象死亡， 至少要经历两次标记过程： 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链， 那它将会被第一次标记， 随后进行一次筛选， 筛选的条件是此对象是否有必要执行finalize()方法。 假如对象没有覆盖finalize()方法， 或者finalize()方法已经被虚拟机调用
过， 那么虚拟机将这两种情况都视为“没有必要执行”。  

如果这个对象被判定为确有必要执行finalize()方法， 那么该对象将会被放置在一个名为F-Queue的队列之中， 并在稍后由一条由虚拟机自动建立的、 低调度优先级的Finalizer线程去执行它们的finalize()方法。 这里所说的“执行”是指虚拟机会触发这个方法开始运行， 但并不承诺一定会等待它运行结束。  

这样做的原因是， 如果某个对象的finalize()方法执行缓慢， 或者更极端地发生了死循环， 将很可能导致F-Queue队列中的其他对象永久处于等待， 甚至导致整个内存回收子系统的崩溃。 finalize()方法是对象逃脱死亡命运的最后一次机会， 稍后收集器将对F-Queue中的对象进行第二次小规模的标记， 如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可， 譬如把自己（this关键字） 赋值给某个类变量或者对象的成员变量， 那在第二次标记时它将被移出“即将回收”的集合； 如果对象这时候还没有逃脱， 那基本上它就真的要被回收了。   

```java
/**
* 此代码演示了两点：
* 1.对象可以在被GC时自我拯救。
* 2.这种自救的机会只有一次， 因为一个对象的finalize()方法最多只会被系统自动调用一次
* @author zzm
*/
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;
    public void isAlive() {
   		System.out.println("yes, i am still alive :)");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    } 
    
    public static void main(String[] args) throws Throwable {
        SAVE_HOOK = new FinalizeEscapeGC();
        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低， 暂停0.5秒， 以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
        	SAVE_HOOK.isAlive();
        } else {
        	System.out.println("no, i am dead :(");
        } 
        // 下面这段代码与上面的完全相同， 但是这次自救却失败了
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低， 暂停0.5秒， 以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
        	SAVE_HOOK.isAlive();
        } else {
        	System.out.println("no, i am dead :(");
        }
    }
}

finalize method executed!
yes, i am still alive :)
no, i am dead :(
```

任何一个对象的finalize()方法都只会被系统自动调用一次， 如果对象面临下一次回收， 它的finalize()方法不会被再次执行， 因此第二段代码的自救行动失败了。  建议大家尽量避免使用它， 因为它并不能等同于C和C++语言中的析构函数。

#### 5.回收方法区

在Java堆中， 尤其是在新生代中， 对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间， 相比之下， 方法区回收囿于苛刻的判定条件， 其区域垃圾收集的回收成果往往远低于此。  

方法区的垃圾收集主要回收两部分内容： 废弃的常量和不再使用的类型。   

判定一个常量是否“废弃”还是相对简单， 而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。 需要同时满足下面三个条件：

- 该类所有的实例都已经被回收， 也就是Java堆中不存在该类及其任何派生子类的实例。
- 加载该类的类加载器已经被回收， 这个条件除非是经过精心设计的可替换类加载器的场景， 如OSGi、 JSP的重加载等， 否则通常是很难达成的。
- 该类对应的java.lang.Class对象没有在任何地方被引用， 无法在任何地方通过反射访问该类的方
  法。  

Java虚拟机被允许对满足上述三个条件的无用类进行回收， 这里说的仅仅是“**被允许**”， 而并不是和对象一样， 没有引用了就必然会回收。 关于是否要对类型进行回收， HotSpot虚拟机提供了-Xnoclassgc参数进行控制， 还可以使用-verbose： class以及-XX： +TraceClass-Loading、 -XX：+TraceClassUnLoading查看类加载和卸载信息， 其中-verbose： class和-XX： +TraceClassLoading可以在Product版的虚拟机中使用， -XX： +TraceClassUnLoading参数需要FastDebug版[1]的虚拟机支持。  

在大量使用反射、 动态代理、 CGLib等字节码框架， 动态生成JSP以及OSGi这类频繁自定义类加载器的场景中， 通常都需要Java虚拟机具备类型卸载的能力， 以保证不会对方法区造成过大的内存压力。

### 2.垃圾收集算法

从如何判定对象消亡的角度出发， 垃圾收集算法可以划分为“引用计数式垃圾收集”（ReferenceCounting GC） 和“追踪式垃圾收集”（Tracing GC） 两大类， 这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。  

#### 1.分代收集理论

建立在两个分代假说之上：  

- 弱分代假说（Weak Generational Hypothesis） ： 绝大多数对象都是朝生夕灭的。
- 强分代假说（Strong Generational Hypothesis） ： 熬过越多次垃圾收集过程的对象就越难以消亡  。

收集器应该将Java堆划分出不同的区域， 然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数） 分配到不同的区域之中存储。如果一个区域中大多数对象都是朝生夕灭， 难以熬过垃圾收集过程的话， 那么把它们集中放在一起， 每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象， 就能以较低代价回收到大量的空间； 如果剩下的都是难以消亡的对象， 那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域， 这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。  

在Java堆划分出不同的区域之后， 垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分 。

一般至少会把Java堆划分为新生代（Young Generation） 和老年代（Old Generation） 两个区域。 顾名思义， 在新生代中， 每次垃圾收集时都发现有大批对象死去， 而每次回收后存活的少量对象， 将会逐步晋升到老年代中存放。  

假如要现在进行一次只局限于新生代区域内的收集（Minor GC） ， 但新生代中的对象是完全有可能被老年代所引用的， 为了找出该区域中的存活对象， 不得不在固定的GC Roots之外， 再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性， 反过来也是一样[3]。 遍历整个老年代所有对象的方案虽然理论上可行， 但无疑会为内存回收带来很大的性能负担。 为了解决这个问题， 就需要对分代收集理论添加第三条经验法则：  

- 跨代引用假说（ Intergenerational Reference Hypothesis） ： 跨代引用相对于同代引用来说仅占极少数。

根据前两条假说逻辑推理得出的隐含推论： 存在互相引用关系的两个对象， 是应该倾向于同时生存或者同时消亡的。   

依据这条假说， 我们就不应再为了少量的跨代引用去扫描整个老年代， 也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用， 只需在新生代上建立一个全局的数据结构（ 该结构被称为“记忆集”， Remembered Set） ， 这个结构把老年代划分成若干小块， 标识出老年代的哪一块内存会存在跨代引用。 此后当发生Minor GC时， 只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。 虽然这种方法需要在对象改变引用关系（ 如将自己或者某个属性赋值） 时维护记录数据的正确性， 会增加一些运行时的开销， 但比起收集时扫描整个老年代来说仍然是划算的。  

**部分收集（ Partial GC）** ： 指目标不是完整收集整个Java堆的垃圾收集， 其中又分为 ：

- 新生代收集（ Minor GC/Young GC） ： 指目标只是新生代的垃圾收集。
- 老年代收集（ Major GC/Old GC） ： 指目标只是老年代的垃圾收集。 目前只有CMS收集器会有单独收集老年代的行为。 另外请注意“Major GC”这个说法现在有点混淆， 在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。
- 混合收集（ Mixed GC） ： 指目标是收集整个新生代以及部分老年代的垃圾收集。 目前只有G1收集器会有这种行为。  

**整堆收集（ Full GC）** ： 收集整个Java堆和方法区的垃圾收集。  

#### 2.标记-清除算法

算法分为“标记”和“清除”两个阶段： 首先标记出所有需要回收的对象， 在标记完成后， 统一回收掉所有被标记的对象， 也可以反过来， 标记存活的对象， 统一回收所有未被标记的对象。 标记过程就是对象是否属于垃圾的判定过程。

后续的收集算法大多都是以标记-清除算法为基础， 对其缺点进行改进而得到的。 它的主要缺点有两个：

-  第一个是**执行效率不稳定**， 如果Java堆中包含大量对象， 而且其中大部分是需要被回收的， 这时必须进行大量标记和清除的动作， 导致标记和清除两个过程的执行效率都随对象数量增长而降低；
- 第二个是**内存空间的碎片化问题**， 标记、 清除之后会产生大量不连续的内存碎片， 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。   

#### 3.标记-复制算法

为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，提出了一种称为“半区复制”（Semispace Copying） 的垃圾收集算法， 它将可用内存按容量划分为大小相等的两块， 每次只使用其中的一块。 当这一块的内存用完了， 就将还存活着的对象复制到另外一块上面， 然后再把已使用过的内存空间一次清理掉。 如果内存中多数对象都是存活的， 这种算法将会产生大量的内存间复制的开销， 但对于多数对象都是可回收的情况， 算法需要复制的就是占少数的存活对象， 而且每次都是针对整个半区进行内存回收， 分配内存时也就不用考虑有空间碎片的复杂情况， 只要移动堆顶指针， 按顺序分配即可。 这样实现简单， 运行高效， 不过其缺陷也显而易见， 这种复制回收算法的代价是将可用内存缩小为了原来的一半， 空间浪费较多。

![image-20230320211015467](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230320211015467.png)

现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，新生代中的对象有98%熬不过第一轮收集。 并不需要按照1∶ 1的比例来划分新生代的内存空间。  一种更优化的半区复制分代策略， 现在称为**“Appel式回收”**。 HotSpot虚拟机的Serial、 ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间， 每次分配内存只使用Eden和其中一块Survivor。 发生垃圾搜集时， 将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上， 然后直接清理掉Eden和已用过的那块Survivor空间。 HotSpot虚拟机默认Eden和Survivor的大小比例是8∶ 1， 也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%） ， 只有一个Survivor空间， 即10%的新生代是会被“浪费”的。  

Appel式回收还有一个充当罕见情况的“逃生门”的安全设计， 当Survivor空间不足以容纳一次Minor GC之后存活的对象时， 就需要依赖其他内存区域（实际上大多就是老年代） 进行**分配担保（Handle Promotion）** 。  

内存的分配担保好比我们去银行借款， 如果我们信誉很好， 在98%的情况下都能按时偿还， 于是银行可能会默认我们下一次也能按时按量地偿还贷款， 只需要有一个担保人能保证如果我不能还款时， 可以从他的账户扣钱， 那银行就认为没有什么风险了。 内存的分配担保也一样， 如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象， 这些对象便将通过分配担保机制直接进入老年代， 这对虚拟机来说就是安全的。   

#### 4.标记-整理算法（Mark-Compact）

标记-复制算法在对象存活率较高时就要进行较多的复制操作， 效率将会降低。 更关键的是， 如果不想浪费50%的空间， 就需要有额外的空间进行分配担保， 以应对被使用的内存中所有对象都100%存活的极端情况， 所以在老年代一般不能直接选用这种算法。  

标记过程仍然与“标记-清除”算法一样， 但后续步骤不是直接对可回收对象进行清理， 而是让所有存活的对象都向内存空间一端移动， 然后直接清理掉边界以外的内存。标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法， 而后者是移动
式的。 是否移动回收后的存活对象是一项优缺点并存的风险决策：  

![image-20230320211500367](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230320211500367.png)

如果移动存活对象， 尤其是在老年代这种每次回收都有大量对象存活区域， 移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作， 而且这种对象移动操作必须**全程暂停用户应用程序**才能进行， 这就更加让使用者不得不小心翼翼地权衡其弊端了， 像这样的停顿被最初的虚拟机设计者形象地描述为**“Stop The World”**。  

如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话， 弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。  内存的访问是用户程序最频繁的操作， 假如在这个环节上增加了额外的负担， 势必会直接影响应用程序的吞吐量。  

基于以上两点， 是否移动对象都存在弊端， 移动则内存回收时会更复杂， 不移动则内存分配时会更复杂。 从垃圾收集的停顿时间来看， 不移动对象停顿时间会更短， 甚至可以不需要停顿， 但是从整个程序的吞吐量来看， 移动对象会更划算。   

HotSpot虚拟机里面关注吞吐量的**Parallel Scavenge收集器是基于标记-整理算法的**， 而**关注延迟的CMS收集器则是基于标记-清除算法**的 。还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担， 做法是让虚拟机平时多数时间都采用标记-清除算法， 暂时容忍内存碎片的存在， 直到内存空间的碎片化程度已经大到影响对象分配时， 再采用标记-整理算法收集一次， 以获得规整的内存空间。 前面提到的**基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法**。  

### 3.Hotspot算法实现细节

#### 1.根节点枚举

固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性） 与执行上下文（例如栈帧中的本地变量表） 中 。所有收集器在根节点枚举这一步骤时都是**必须暂停用户线程**的， 因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。  

现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发， 但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行——这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上， 不会出现分析过程中， 根节点集合的对象引用关系还在不断变化的情况， 若这点不能满足的话， 分析结果准确性也就无法保证。 这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因， 即使是号称停顿时间可控， 或者（几乎） 不会发生停顿的CMS、 G1、ZGC等收集器， **枚举根节点时也是必须要停顿的。**  

主流Java虚拟机使用的都是准确式垃圾收集 ，当用户线程停顿下来之后， 其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置， 虚拟机应当是有办法直接得到哪些地方存放着对象引用的。 在HotSpot的解决方案里， 是使用一组称为OopMap的数据结构来达到这个目的。 一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来， 在即时编译过程中， 也会在**特定的位置记录**下栈里和寄存器里哪些位置是引用。 这样收集器在扫描时就可以直接得知这些信息了， 并不需要真正一个不漏地从方法区等GC Roots开始查找。  

#### 2.安全点

可能导致引用关系变化， 或者说导致OopMap内容变化的指令非常多， 如果为每一条指令都生成对应的OopMap， 那将会需要大量的额外存储空间， 这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。  

只是在“特定的位置”记录了这些信息， 这些位置被称为**安全点（Safepoint）** 。 有了安全点的设定， 也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集， 而是强制要求必须执行到达安全点后才能够暂停。   

安全点的选定既不能太少以至于让收集器等待时间过长， 也不能太过频繁以至于过分增大运行时的内存负荷。 安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的， 因为每条指令执行的时间都非常短暂， 程序不太可能因为指令流长度太长这样的原因而长时间执行， “长时间执行”的最明显特征就是指令序列的复用， 例如方法调用、 循环跳转、 异常跳转等都属于指令序列复用， 所以只有具有这些功能的指令才会产生安全点。  

如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程） 都跑到最近的安全点， 然后停顿下来。 这里有两种方案可供选择： 抢先式中断（Preemptive Suspension） 和主动式中断（Voluntary Suspension）：

- 抢先式中断不需要线程的执行代码主动去配合， 在垃圾收集发生时， 系统首先把所有用户线程全部中断， 如果发现有用户线程中断的地方不在安全点上， 就恢复这条线程执行， 让它一会再重新中断， 直到跑到安全点上。 现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。  
- 主动式中断的思想是当垃圾收集需要中断线程的时候， 不直接对线程操作， 仅仅简单地设置一个标志位， 各个线程执行过程时会不停地主动去轮询这个标志， 一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。 轮询标志的地方和安全点是重合的， 另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方， 这是为了检查是否即将要发生垃圾收集， 避免没有足够内存分配新对象。  

#### 3.安全区域

程序“不执行”的时候呢？ 所谓的程序不执行就是没有分配处理器时间， 典型的场景便是用户线程处于Sleep状态或者Blocked状态， 这时候线程无法响应虚拟机的中断请求， 不能再走到安全的地方去中断挂起自己， 虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。 对于这种情况， 就必须引入安全区域（Safe Region） 来解决。  

安全区域是指能够确保在某一段代码片段之中， 引用关系不会发生变化， 因此， 在这个区域中任意地方开始垃圾收集都是安全的。   

当用户线程执行到安全区域里面的代码时， 首先会标识自己已经进入了安全区域， 那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。 当线程要离开安全区域时， 它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段） ， 如果完成了， 那线程就当作没事发生过， 继续执行； 否则它就必须一直等待， 直到收到可以离开安全区域的信号为止。  

#### 4.记忆集与卡表

为解决对象跨代引用所带来的问题， 垃圾收集器在新生代中建立了名为记忆集（Remembered Set） 的数据结构， 用以避免把整个老年代加进GC Roots扫描范围。 事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集（Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。  最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构，这种记录全部含跨代引用对象的实现方案， 无论是空间占用还是维护成本都相当高昂。 而在垃圾收集的场景中， 收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了， 并不需要了解这些跨代指针的全部细节。 可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本：

- 字长精度： 每个记录精确到一个机器字长（就是处理器的寻址位数， 如常见的32位或64位， 这个精度决定了机器访问物理内存地址的指针长度） ， 该字包含跨代指针。
- 对象精度： 每个记录精确到一个对象， 该对象里有字段含有跨代指针。
- 卡精度： 每个记录精确到一块内存区域， 该区域内有对象含有跨代指针。  

第三种“卡精度”所指的是用一种称为“卡表”（Card Table） 的方式去实现记忆集， 这也是目前最常用的一种记忆集实现形式。卡表就是记忆集的一种具体实现， 它定义了记忆集的记录精度、 与堆内存的映射关系等。  卡表最简单的形式可以只是一个字节数组[2]， 而HotSpot虚拟机确实也是这样做的。  字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块， 这个内存块被称作“卡页”（Card Page） 。 一般来说， 卡页大小都是以2的N次幂的字节数， 通过上面代码可以看出HotSpot中使用的卡页是2的9次幂， 即512字节（地址右移9位， 相当于用地址除以512） 。 那如果卡表标识内存区域的起始地址是0x0000的话， 数组CARD_TABLE的第0、 1、 2号元素， 分别对应了地址范围为0x0000～0x01FF、 0x0200～0x03FF、 0x0400～0x05FF的卡页内存块。

一个卡页的内存中通常包含不止一个对象， 只要卡页内有一个（或更多） 对象的字段存在着跨代指针， 那就将对应卡表的数组元素的值标识为1， 称为这个元素变脏（Dirty） ， 没有则标识为0。 在垃圾收集发生时， 只要筛选出卡表中变脏的元素， 就能轻易得出哪些卡页内存块中包含跨代指针， 把它们加入GC Roots中一并扫描。

#### 5.写屏障

已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题， 但还没有解决卡表元素如何维护的问题， 例如它们何时变脏、 谁来把它们变脏等。  

卡表元素何时变脏的答案是很明确的——有其他分代区域中对象引用了本区域对象时， 其对应的卡表元素就应该变脏， 变脏时间点原则上应该发生在引用类型字段赋值的那一刻。 但问题是如何变脏， 即如何在对象赋值的那一刻去更新维护卡表呢？ 假如是解释执行的字节码， 那相对好处理， 虚拟机负责每条字节码指令的执行， 有充分的介入空间； 但在编译执行的场景中呢？ 经过即时编译后的代码已经是纯粹的机器指令流了， 这就必须找到一个在机器码层面的手段， 把维护卡表的动作放到每一个赋值操作之中。   

在HotSpot虚拟机里是通过**写屏障（Write Barrier）** 技术维护卡表状态的。写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面， 在引用对象赋值时会产生一个环形（Around） 通知， 供程序执行额外的动作， 也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier） ， 在赋值后的则叫作写后屏障（Post-Write Barrier） 。 HotSpot虚拟机的许多收集器中都有使用到写屏障， 但直至G1收集器出现之前， 其他收集器都只用到了写后屏障。   

```java
void oop_field_store(oop* field, oop new_value) {
    // 引用字段赋值操作
    *field = new_value;
    // 写后屏障， 在这里完成卡表状态更新
    post_write_barrier(field, new_value);
}
```

应用写屏障后， 虚拟机就会为所有赋值操作生成相应的指令， 一旦收集器在写屏障中增加了更新卡表操作， 无论更新的是不是老年代对新生代对象的引用， 每次只要对引用进行更新， 就会产生额外的开销， 不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。  

卡表在高并发场景下还面临着**“伪共享”（False Sharing）** 问题。 伪共享是处理并发底层细节时一种经常需要考虑的问题， 现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的， 当多线程修改互相独立的变量时， 如果这些变量恰好共享同一个缓存行， 就会彼此影响（写回、 无效化或者同步） 而导致性能降低， 这就是伪共享问题。  

假设处理器的缓存行大小为64字节， 由于一个卡表元素占1个字节， 64个卡表元素将共享同一个缓存行。 这64个卡表元素对应的卡页总的内存为32KB（64×512字节） ， 也就是说如果不同线程更新的对象正好处于这32KB的内存区域内， 就会导致更新卡表时正好写入同一个缓存行而影响性能。   

为了避免伪共享问题， 一种简单的解决方案是不采用无条件的写屏障， 而是先检查卡表标记， 只有当该卡表元素未被标记过时才将其标记为变脏， 即将卡表更新的逻辑变为以下代码所示：

```java
if (CARD_TABLE [this address >> 9] != 0)
	CARD_TABLE [this address >> 9] = 0;
```

在JDK 7之后， HotSpot虚拟机增加了一个新的参数-XX： +UseCondCardMark， 用来决定是否开启卡表更新的条件判断。 开启会增加一次额外判断的开销， 但能够避免伪共享问题， 两者各有性能损耗， 是否打开要根据应用实际运行情况来进行测试权衡。  

#### 6.并发的可达性分析

可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的运行。   

在根节点枚举（见3.4.1节） 这个步骤中， 由于GC Roots相比起整个Java堆中全部的对象毕竟还算是极少数， 且在各种优化技巧（如OopMap） 的加持下， 它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长） 的了。 可从GC Roots再继续往下遍历对象图， 这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了： 堆越大， 存储的对象越多， 对象图结构越复杂， 要标记更多对象而产生的停顿时间自然就更长。

包含“标记”阶段是所有追踪式垃圾收集算法的共同特征， 如果这个阶段会随着堆变大而等比例增加停顿时间， 其影响就会波及几乎所有的垃圾收集器， 同理可知， 如果能够削减这部分停顿时间的话， 那收益也将会是系统性的。

想解决或者降低用户线程的停顿， 就要先搞清楚为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？   

引入三色标记（Tri-color Marking）作为工具来辅助推导， 把遍历对象图过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色： 

- 白色： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。
- 黑色： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。
- 灰色： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。  

看作对象图上一股以灰色为波峰的波纹从黑向白推进的过程， 如果用户线程此时是冻结的， 只有收集器线程在工作， 那不会有任何问
题。 但如果用户线程与收集器是并发工作呢？ 收集器在对象图上标记颜色， 同时用户线程在修改引用关系——即修改对象图的结构， 这样可能出现两种后果。 一种是把原本消亡的对象错误标记为存活，产生了一点逃过本次收集的浮动垃圾而已， 下次收集清理掉就好。另一种是把原本存活的对象错误标记为已消亡，程序肯定会因此发生错误。

当且仅当以下两个条件同时满足时， 会产生“对象消失”的问题， 即原本应该是黑色的对象被误标为白色：

- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。  

要解决并发扫描时的对象消失问题， 只需破坏这两个条件的任意一个即可。 由此分别产生了两种解决方案： **增量更新**（Incremental Update） 和**原始快照**（Snapshot At The Beginning，SATB） 。  

增量更新要破坏的是第一个条件， 当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。  

原始快照要破坏的是第二个条件， 当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次。 这也可以简化理解为， 无论引用关系删除与否， 都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。  

CMS是基于增量更新来做并发标记的， G1、 Shenandoah则是用原始快照来实现。  

### 4.垃圾收集器

![image-20230321204150212](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321204150212.png)



#### 1.Serial收集器

一个单线程工作的收集器， 但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作， 更重要的是强调在它进行垃圾收集时， 必须暂停其他所有工作线程， 直到它收集结束。  

![image-20230321204317193](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321204317193.png)

依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器， 有着优于其他收集器的地方， 那就是简单而高效（与其他收集器的单线程相比） ， 对于内存资源受限的环境， 它是所有收集器里额外内存消耗（Memory Footprint）最小的； 对于单核处理器或处理器核心数较少的环境来说， Serial收集器由于没有线程交互的开销， 专心做垃圾收集自然可以获得最高的单线程收集效率。   



#### 2.ParNew收集器  

实质上是Serial收集器的多线程并行版本， 除了同时使用多条线程进行垃圾收集之外， 其余的行为包括Serial收集器可用的所有控制参数（例如： -XX： SurvivorRatio、 -XX：PretenureSizeThreshold、 -XX： HandlePromotionFailure等） 、 收集算法、 Stop The World、 对象分配规则、 回收策略等都与Serial收集器完全一致。

![image-20230321204534711](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321204534711.png)

不少运行在服务端模式下的HotSpot虚拟机， 尤其是JDK 7之前的遗留系统中首选的新生代收集器， 其中有一个与功能、 性能无关但其实很重要的原因是： 除了Serial收集器外， 目前只有它能与CMS收集器配合工作。  

ParNew收集器是激活CMS后（使用-XX： +UseConcMarkSweepGC选项） 的默认新生代收集器， 也可以使用-XX： +/-UseParNewGC选项来强制指定或者禁用它。  

自JDK 9开始， ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。  

在谈论垃圾收集器的上下文语境中：  

- 并行（Parallel） ： 并行描述的是多条垃圾收集器线程之间的关系， 说明同一时间有多条这样的线程在协同工作， 通常默认此时用户线程是处于等待状态。
- 并发（Concurrent） ： 并发描述的是垃圾收集器线程与用户线程之间的关系， 说明同一时间垃圾收集器线程与用户线程都在运行。 由于用户线程并未被冻结， 所以程序仍然能响应服务请求， 但由于垃圾收集器线程占用了一部分系统资源， 此时应用程序的处理的吞吐量将受到一定影响。  



#### 3.Parallel Scavenge收集器  

一款新生代收集器， 它同样是基于标记-复制算法实现的收集器， 也是能够并行收集的多线程收集器，经常被称作“吞吐量优先收集器”  。特点是它的关注点与其他收集器不同， CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间， 而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput） 。 所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值：

![image-20230321204909478](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321204909478.png)



提供了两个参数用于精确控制吞吐量， 分别是控制最大垃圾收集停顿时间的-XX： MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX： GCTimeRatio参数：

-XX： MaxGCPauseMillis参数允许的值是一个大于0的毫秒数， 收集器将尽力保证内存回收花费的时间不超过用户设定值。 垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的：系统把新生代调得小一些， 收集300MB新生代肯定比收集500MB快， 但这也直接导致垃圾收集发生得更频繁， 原来10秒收集一次、 每次停顿100毫秒， 现在变成5秒收集一次、 每次停顿70毫秒。 停顿时间的确在下降， 但吞吐量也降下来了。  

-XX： GCTimeRatio参数的值则应当是一个大于0小于100的整数， 也就是垃圾收集时间占总时间的比率， 相当于吞吐量的倒数。 譬如把此参数设置为19， 那允许的最大垃圾收集时间就占总时间的5%（即1/(1+19)） ， 默认值为99， 即允许最大1%（即1/(1+99)） 的垃圾收集时间。  

还有一个参数-XX： +UseAdaptiveSizePolicy ，当这个参数被激活之后， 就不需要人工指定新生代的大小（-Xmn） 、 Eden与Survivor区的比例（-XX： SurvivorRatio） 、 晋升老年代对象大小（-XX： PretenureSizeThreshold） 等细节参数了， 虚拟机会根据当前系统的运行情况收集性能监控信息， 动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）。  

只需要把基本的内存数据设置好（如-Xmx设置最大堆） ， 然后使用-XX： MaxGCPauseMillis参数（更关注最大停顿时间） 或-XX： GCTimeRatio（更关注吞吐量） 参数给虚拟机设立一个优化目标， 那具体细节参数的调节工作就由虚拟机完成了。 自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。  

#### 4.Serial Old收集器  

Serial收集器的老年代版本， 它同样是一个单线程收集器， 使用标记-整理算法。 这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。 如果在服务端模式下， 它也可能有两种用途： 一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用， 另外一种就是作为CMS收集器发生失败时的后备预案， 在并发收集发生Concurrent Mode Failure时使用。  

![image-20230321205233304](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321205233304.png)

#### 5.Parallel Old收集器  

Parallel Scavenge收集器的老年代版本， 支持多线程并发收集， 基于标记-整理算法实现。  在注重吞吐量或者处理器资源较为稀缺的场合， 都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。   

 ![image-20230321205418448](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321205418448.png)



#### 6.CMS收集器  

CMS（Concurrent Mark Sweep） 收集器是一种以获取最短回收停顿时间为目标的收集器。 目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上， 这类应用通常都会较为关注服务的响应速度， 希望系统停顿时间尽可能短， 以给用户带来良好的交互体验。   

基于标记-清除算法实现的 ：

1） 初始标记（CMS initial mark）
2） 并发标记（CMS concurrent mark）
3） 重新标记（CMS remark）
4） 并发清除（CMS concurrent sweep）  

初始标记、 重新标记这两个步骤仍然需要“Stop The World”。 初始标记仅仅只是标记一下GCRoots能直接关联到的对象， 速度很快； 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行； 而重新标记阶段则是为了修正并发标记期间， 因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（关于增量更新的讲解） ， 这个阶段的停顿时间通常会比初始标记阶段稍长一些， 但也远比并发标记阶段的时间短； 最后是并发清除阶段， 清理删除掉标记阶段判断的已经死亡的对象， 由于不需要移动存活对象， 所以这个阶段也是可以与用户线程同时并发的。  

在整个过程中耗时最长的并发标记和并发清除阶段中， 垃圾收集器线程都可以与用户线程一起工作， 所以从总体上来说， CMS收集器的内存回收过程是与用户线程一起并发执行的。   

![image-20230321205559268](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321205559268.png)

优点在： 并发收集、 低停顿 。

至少有以下三个明显的缺点：  

- CMS收集器对处理器资源非常敏感：在并发阶段， 它虽然不会导致用户线程停顿， 但却会因为占用了一部分线程（或者说处理器的计算能力） 而导致应用程序变慢， 降低总吞吐量。  为了缓解这种情况， 虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS） 的CMS收集器变种，JDK 9发布后iCMS模式被完全废弃。  
- CMS收集器无法处理“浮动垃圾”（Floating Garbage） ， 有可能出现“Con-current ModeFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生。   在JDK5的默认设置下， CMS收集器当老年代使用了68%的空间后就会被激活， 这是一个偏保守的设置， 如果在实际应用中老年代增长并不是太快， 可以适当调高参数-XX： CMSInitiatingOccu-pancyFraction的值来提高CMS的触发百分比， 降低内存回收频率， 获取更好的性能。   参数-XX： CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量的并发失败产生， 性能反而降低， 用户应在生产环境中根据实际应用情况来权衡设置。  
- 基于“标记-清除”算法实现的收集器 ，收集结束时会有大量空间碎片产生 ，将会给大对象分配带来很大麻烦， 往往会出现老年代还有很多剩余空间， 但就是无法找到足够大的连续空间来分配当前对象， 而不得不提前触发一次Full GC的情况。  CMS收集器提供了一个-XX： +UseCMS-CompactAtFullCollection开关参数（默认是开启的， 此参数从JDK 9开始废弃） ， 用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程， 由于这个内存整理必须移动存活对象， （在Shenandoah和ZGC出现前） 是无法并发的。 这样空间碎片问题是解决了， 但停顿时间又会变长， 因此虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction（此参数从JDK 9开始废弃） ， 这个参数的作用是要求CMS收集器在执行过若干次（数量由参数值决定） 不整理空间的Full GC之后， 下一次进入Full GC前会先进行碎片整理（默认值为0， 表示每次进入Full GC时都进行碎片整理） 。  

#### 7.Garbage First收集器  

开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。  G1是一款主要面向服务端应用的垃圾收集器。JDK 9发布之
日， G1宣告取代Parallel Scavenge加Parallel Old组合， 成为服务端模式下的默认垃圾收集器， 而CMS则沦落至被声明为不推荐使用（Deprecate） 的收集器。对JDK 9及以上版本的HotSpot虚拟机使用参数-XX： +UseConcMarkSweepGC来开启CMS收集器的话， 用户会收到一个警告信息， 提示CMS未来将会被废弃。

“停顿时间模型”（PausePrediction Model），能够支持指定在一个长度为M毫秒的时间片段内， 消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。怎么做才能实现这个目标呢？   

G1可以面向堆内存任何部分来组成回收集（Collection Set， 一般简称CSet） 进行回收， 衡量标准不再是它属于哪个分代， 而是哪块内存中存放的垃圾数量最多， 回收收益最大， 这就是G1收集器的Mixed GC模式。  基于Region的堆内存布局是它能够实现这个目标的关键  ，G1不再坚持固定大小以及固定数量的分代区域划分， 而是把连续的Java堆划分为多个大小相等的独立区域（Region） ， 每一个Region都可以根据需要， 扮演新生代的Eden空间、 Survivor空间， 或者老年代空间。 收集器能够对扮演不同角色的Region采用不同的策略去处理， 这样无论是新创建的对象还是已经存活了一段时间、 熬过多次收集的旧对象都能获取很好的收集效果。  

Region中还有一类特殊的Humongous区域， 专门用来存储大对象。 G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。 每个Region的大小可以通过参数-XX： G1HeapRegionSize设定， 取值范围为1MB～32MB， 且应为2的N次幂。 而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中， G1的大多数行为都把Humongous Region作为老年代
的一部分来进行看待。

G1收集器之所以能建立可预测的停顿时间模型， 是因为它将Region作为单次回收的最小单元， 即每次收集到的内存空间都是Region大小的整数倍， 这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。 更具体的处理思路是让G1收集器去跟踪各个Region里面的垃
圾堆积的“价值”大小， 价值即回收所获得的空间大小以及回收所需时间的经验值， 然后在后台维护一个优先级列表， 每次根据用户设定允许的收集停顿时间（使用参数-XX： MaxGCPauseMillis指定， 默认值是200毫秒） ， 优先处理回收价值收益最大的那些Region， 这也就是“Garbage First”名字的由来。  

**Region里面存在的跨Region引用对象如何解决？**  

使用记忆集避免全堆作为GC Roots扫描， 但在G1收集器上记忆集的应用其实要复杂很多， 它的每个Region都维护有自己的记忆集， 这些记忆集会记录下别的Region指向自己的指针， 并标记这些指针分别在哪些卡页的范围之内。 G1的记忆集在存储结构的本质上是一
种哈希表， Key是别的Region的起始地址， Value是一个集合， 里面存储的元素是卡表的索引号。 这种“双向”的卡表结构（卡表是“我指向谁”， 这种结构还记录了“谁指向我”） 比原来的卡表实现起来更复杂， 同时由于Region数量比传统收集器的分代数量明显要多得多， 因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。 根据经验， G1至少要耗费大约相当于Java堆容量10%至20%的额
外内存来维持收集器工作。  

**在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？**   

首先要解决的是用户线程改变对象引用关系时， 必须保证其不能打破原本的对象图结构， 导致标记结果出现错误，G1收集器则是通过原始快照（SATB） 算法来实现的。  垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上， 程序要继续运行就肯定会持续有新对象被创建， G1为每一个Region设计了两个名为TAMS（Top at Mark Start） 的指针， 把Region中的一部分空间划分出来用于并发回收过程中的新对象分配， 并发回收时新分配的对象地址都必须要在这两个指针位置以上。 G1收集器默认在这个地址以上的对象是被隐式标记过的， 即默认它们是存活的， 不纳入回收范围。  

如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行， 导致Full GC而产生长时间“Stop The World”。 

**怎样建立起可靠的停顿预测模型？**  

通过-XX： MaxGCPauseMillis参数指定的停顿时间
只意味着垃圾收集发生之前的期望值， 但G1收集器要怎么做才能满足用户的期望呢？ G1收集器的停顿预测模型是以衰减均值（Decaying Average） 为理论基础来实现的， 在垃圾收集过程中， G1收集器会记录每个Region的回收耗时、 每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本， 并分析得出平均值、 标准偏差、 置信度等统计信息。 这里强调的“衰减平均值”是指它会比普通的平均值更容易受到新数据的影响， 平均值代表整体平均状态， 但衰减平均值更准确地代表“最近的”平均状态。 换句话说， Region的统计状态越新越能决定其回收的价值。 然后通过这些信息预测现在开始回收的话， 由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。  

G1收集器的运作过程大致可划分为以下四个步骤：  

- **初始标记（Initial Marking）** ： 仅仅只是标记一下GC Roots能直接关联到的对象， 并且修改TAMS指针的值， 让下一阶段用户线程并发运行时， 能正确地在可用的Region中分配新对象。 这个阶段需要停顿线程， 但耗时很短， 而且是借用进行Minor GC的时候同步完成的， 所以G1收集器在这个阶段实际并没有额外的停顿。
- **并发标记（Concurrent Marking）** ： 从GC Root开始对堆中对象进行可达性分析， 递归扫描整个堆里的对象图， 找出要回收的对象， 这阶段耗时较长， 但可与用户程序并发执行。 当对象图扫描完成以后， 还要重新处理SATB记录下的在并发时有引用变动的对象。
- **最终标记（Final Marking）** ： 对用户线程做另一个短暂的暂停， 用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
- **筛选回收（Live Data Counting and Evacuation）** ： 负责更新Region的统计数据， 对各个Region的回收价值和成本进行排序， 根据用户所期望的停顿时间来制定回收计划， 可以自由选择任意多个Region构成回收集， 然后把决定回收的那一部分Region的存活对象复制到空的Region中， 再清理掉整个旧Region的全部空间。 这里的操作涉及存活对象的移动， 是必须暂停用户线程， 由多条收集器线程并行完成的。  

G1收集器除了并发标记外， 其余阶段也是要完全暂停用户线程的，换言之， 它并非纯粹地追求低延迟， 官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量。

 ![image-20230321211203742](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321211203742.png)

由用户指定期望的停顿时间是G1收集器很强大的一个功能，默认的停顿目标为两百毫秒， 一般来说， 回收阶段占到几十到一百甚至接近两百毫秒都很正常， 但如果我们把停顿时间调得非常低， 譬如设置为二十毫秒， 很可能出现的结果就是由于停顿目标时间太短， 导致每次选出来的回收集只占堆内存很小的一部分， 收集器收集的速度逐渐跟不上分配器分配的速度， 导致垃圾慢慢堆积。通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。

G1从整体来看是基于“标记-整理”算法实现的收集器， 但从局部（两个Region之间） 上看又是基于“标记-复制”算法实现， 无论如何， 这两种算法都意味着G1运作期间不会产生内存空间碎片， 垃圾收集完成之后能提供规整的可用内存。 这种特性有利于程序长时间运行， 在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。  

就内存占用来说， 虽然G1和CMS都使用卡表来处理跨代指针， 但G1的卡表实现更为复杂。

在执行负载的角度上， 同样由于两个收集器各自的细节实现特点导致了用户程序运行时的负载会有不同。CMS用写后屏障来更新维护卡表； 而G1除了使用写后屏障来进行同样的（由于G1的卡表结构复杂， 其实是更烦琐的） 卡表维护操作外， 为了实现原始快照搜索（SATB） 算法， 还需要使用写前屏障来跟踪并发时的指针变化情况。比起增量更新算法， 原始快照搜索能够减少并发标记和重新标记阶段的消耗， 避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。 由于G1对写屏障的复杂操作要比CMS消耗更多的运算资源， 所以CMS的写屏障实现是直接的同步操作， 而G1就不得不将其实现为类似于消息队列的结构， 把写前屏障和写后屏障中要做的事情都放到队列里， 然后再异步处理。  

目前在小内存应用上CMS的表现大概率仍然要会优于G1， 而在大内存应用上G1则大多能发挥其优势， 这个优劣势的Java堆容量平衡点通常在6GB至8GB之间， 当然， 以上这些也仅是经验之谈  

### 5.低延迟收集器

衡量垃圾收集器的三项最重要的指标是： 内存占用（Footprint） 、 吞吐量（Throughput） 和延迟（Latency），延迟的重要性日益凸显。

浅色阶段表示必须挂起用户线程， 深色表示收集器线程与用户线程是并发工作的。  

![image-20230321211913876](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321211913876.png)

#### 1.Shenandoah收集器  

Shenandoah是一款只有OpenJDK才会包含， 而OracleJDK里反而不存在的收集器 。这个项目的目标是实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器。

比起G1又有什么改进呢？  

Shenandoah也是使用基于Region的堆内存布局， 同样有着用于存放大对象的Humongous Region， 默认的回收策略也同样是优先处理回收价值最大的Region，但在管理堆内存方面， 它与G1至少有三个明显的不同之处， 最重要的当然是支持并发的整理算法， G1的回收阶段是可以多线程并行的， 但却不能与用户线程并发。

Shenandoah（目前） 是默认不使用分代收集的， 换言之， 不会有专门的新生代Region或者老年代Region的存在。

摒弃了在G1中耗费大量内存和计算资源去维护的记忆集， 改用名为“连接矩阵”（ConnectionMatrix） 的全局数据结构来记录跨Region的引用关系， 降低了处理跨代指针时的记忆集维护消耗， 也降低了**伪共享问题**的发生概率。   连接矩阵可以简单理解为一张二维表格， 如果Region N有对象指向Region M， 就在表格的N行M列中打上一个标记， 如图3-15所示， 如果Region 5中的对象Baz引用了Region 3的Foo， Foo又引用了Region 1的Bar， 那连接矩阵中的5行3列、 3行1列就应该被打上标记。 在回收时通过这张表格就可以得出哪些Region之间产生了跨代引用。  

更详细的实现细节参考JVM书籍。

#### 2.ZGC收集器  

在尽可能对吞吐量影响不太大的前提下 ，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。 主要特征： ZGC收集器是一款基于Region内存布局的， （暂时）不设分代的， 使用了读屏障、 染色指针和内存多重映射等技术来实现可并发的标记-整理算法的， 以低延迟为首要目标的一款垃圾收集器。    

ZGC的Region（在一些官方资料中将它称为Page或者ZPage， 本章为行文一致继续称为Region） 具有动态性——动态创建和销毁， 以及动态的区域容量大小。 在x64硬件平台下， ZGC的Region可以具有大、 中、 小三类容量：  

- 小型Region（Small Region） ： 容量固定为2MB， 用于放置小于256KB的小对象。
- 中型Region（Medium Region） ： 容量固定为32MB， 用于放置大于等于256KB但小于4MB的对象。
- 大型Region（Large Region） ： 容量不固定， 可以动态变化， 但必须为2MB的整数倍， 用于放置4MB或以上的大对象。 每个大型Region中只会存放一个大对象， 这也预示着虽然名字叫作“大型Region”， 但它的实际容量完全有可能小于中型Region， 最小容量可低至4MB。 大型Region在ZGC的实现中是不会被重分配（重分配是ZGC的一种处理动作， 用于复制对象的收集器阶段）的， 因为复制一个大对象的代价非常高昂。  

ZGC的核心问题——并发整理算法的实现，ZGC收集器有一个标志性的设计是它采用的染色指针技术（Colored Pointer）。HotSpot虚拟机的几种收集器有不同的标记实现方案， 有的把标记直接记录在对象头上（如Serial收集器） ， 有的把标记记录在与对象相互独立的数据结构上（如G1、 Shenandoah使用了一种相当于堆内存的1/64大小的， 称为BitMap的结构来记录标记信息） ， 而ZGC的染色指针是最直接的、 最纯粹的， 它直接把标记信息记在引用对象的指针上 。

详细实现参考JVM书籍。

### 6.选择合适的垃圾收集器  

#### 1.收集器的权衡

如何选择一款适合自己应用的收集器呢？ 这个问题的答案主要受以下三个因素影响：  

- 应用程序的主要关注点是什么？ 如果是数据分析、 科学计算类的任务， 目标是能尽快算出结果，那吞吐量就是主要关注点； 如果是SLA应用， 那停顿时间直接影响服务质量， 严重的甚至会导致事务超时， 这样延迟就是主要关注点； 而如果是客户端应用或者嵌入式应用， 那垃圾收集的内存占用则是不可忽视的。
- 运行应用的基础设施如何？ 譬如硬件规格， 要涉及的系统架构是x86-32/64、 SPARC还是ARM/Aarch64； 处理器的数量多少， 分配内存的大小； 选择的操作系统是Linux、 Solaris还是Windows等。
- 使用JDK的发行商是什么？ 版本号是多少？ 是ZingJDK/Zulu、 OracleJDK、 Open-JDK、 OpenJ9抑或是其他公司的发行版？ 该JDK对应了《Java虚拟机规范》 的哪个版本？  

假设某个直接面向用户提供服务的B/S系统准备选择垃圾收集器， 一般来说延迟时间是这类应用的主要关注点， 那么：  

- 如果你有充足的预算但没有太多调优经验， 那么一套带商业技术支持的专有硬件或者软件解决方案是不错的选择， Azul公司以前主推的Vega系统和现在主推的Zing VM是这方面的代表， 这样你就可以使用传说中的C4收集器了。
- 如果你虽然没有足够预算去使用商业解决方案， 但能够掌控软硬件型号， 使用较新的版本， 同时又特别注重延迟， 那ZGC很值得尝试。
- 如果你对还处于实验状态的收集器的稳定性有所顾虑， 或者应用必须运行在Win-dows操作系统下， 那ZGC就无缘了， 试试Shenandoah吧。
- 如果你接手的是遗留系统， 软硬件基础设施和JDK版本都比较落后， 那就根据内存规模衡量一下， 对于大概4GB到6GB以下的堆内存， CMS一般能处理得比较好， 而对于更大的堆内存， 可重点考察一下G1。  

根据系统实际情况去测试才是选择收集器的最终依据。

#### 2.虚拟机及垃圾收集器日志  

每个收集器的日志格式都可能不一样。  在JDK 9以前， HotSpot并没有提供统一的日志处理框架， 虚拟机各个功能模块的日志开关分布在不同的参数上， 日志级别、 循环日志大小、 输出格式、 重定向等设置在不同功能上都要单独解决。 直到JDK 9， 这种混乱不堪的局面才终于消失， HotSpot所有功能的日志都收归到了“-Xlog”参数上。

```java
-Xlog[:[selector][:[output][:[decorators][:output-options]]]]
```

命令行中最关键的参数是选择器（Selector） ， 它由标签（Tag） 和日志级别（Level） 共同组成。标签可理解为虚拟机中某个功能模块的名字， 它告诉日志框架用户希望得到虚拟机哪些功能的日志输出。 垃圾收集器的标签名称为“gc”， 由此可见， 垃圾收集器日志只是HotSpot众多功能日志的其中一项， 全部支持的功能模块标签名如下所示：  

```
add， age， alloc， annotation， aot， arguments， attach， barrier， biasedlocking， blocks， bot， breakpoin...
```

日志级别从低到高， 共有Trace， Debug， Info， Warning， Error， Off六种级别， 日志级别决定了输出信息的详细程度， 默认级别为Info， HotSpot的日志规则与Log4j、 SLF4j这类Java日志框架大体上是一致的。 另外， 还可以使用修饰器（Decorator） 来要求每行日志输出都附加上额外的内容， 支持附加在日志行上的信息包括：  

- time： 当前日期和时间。
- uptime： 虚拟机启动到现在经过的时间， 以秒为单位。
- timemillis： 当前时间的毫秒数， 相当于System.currentTimeMillis()的输出。
- uptimemillis： 虚拟机启动到现在经过的毫秒数。
- timenanos： 当前时间的纳秒数， 相当于System.nanoTime()的输出。
- uptimenanos： 虚拟机启动到现在经过的纳秒数。
- pid： 进程ID。
- tid： 线程ID。
- level： 日志级别。  
- tags： 日志输出的标签集  

如果不指定， 默认值是uptime、 level、 tags这三个， 此时日志输出类似于以下形式：

```
[3.080s][info][gc,cpu] GC(5) User=0.03s Sys=0.00s Real=0.01s
```

以JDK 9的G1收集器（ JDK 9下默认收集器就是G1， 所以命令行中没有指定收集器） 为例 ：

1） 查看GC基本信息， 在JDK 9之前使用-XX： +PrintGC， JDK 9后使用-Xlog： gc：  

```java
bash-3.2$ java -Xlog:gc GCTest
[0.222s][info][gc] Using G1
[2.825s][info][gc] GC(0) Pause Young (G1 Evacuation Pause) 26M->5M(256M) 355.623ms
[3.096s][info][gc] GC(1) Pause Young (G1 Evacuation Pause) 14M->7M(256M) 50.030ms
[3.385s][info][gc] GC(2) Pause Young (G1 Evacuation Pause) 17M->10M(256M) 40.576ms
```

2） 查看GC详细信息， 在JDK 9之前使用-XX： +PrintGCDetails， 在JDK 9之后使用-X-log： g*，用通配符*将GC标签下所有细分过程都打印出来， 如果把日志级别调整到Debug或者Trace（ 基于版面篇幅考虑， 例子中并没有） ， 还将获得更多细节信息：  

```java
bash-3.2$ java -Xlog:gc* GCTest
[0.233s][info][gc,heap] Heap region size: 1M
[0.383s][info][gc ] Using G1
[0.383s][info][gc,heap,coops] Heap address: 0xfffffffe50400000, size: 4064 MB, Compressed Oops mode: Non-zero ba
0xfffffffe50000000, Oop shift amount: 3
[3.064s][info][gc,start ] GC(0) Pause Young (G1 Evacuation Pause)
gc,task ] GC(0) Using 23 workers of 23 for evacuation
[3.420s][info][gc,phases ] GC(0) Pre Evacuate Collection Set: 0.2ms
[3.421s][info][gc,phases ] GC(0) Evacuate Collection Set: 348.0ms
gc,phases ] GC(0) Post Evacuate Collection Set: 6.2ms
[3.421s][info][gc,phases ] GC(0) Other: 2.8ms
gc,heap ] GC(0) Eden regions: 24->0(9)
[3.421s][info][gc,heap ] GC(0) Survivor regions: 0->3(3)
[3.421s][info][gc,heap ] GC(0) Old regions: 0->2
[3.421s][info][gc,heap ] GC(0) Humongous regions: 2->1
[3.421s][info][gc,metaspace ] GC(0) Metaspace: 4719K->4719K(1056768K)
[3.421s][info][gc ] GC(0) Pause Young (G1 Evacuation Pause) 26M->5M(256M) 357.743ms
[3.422s][info][gc,cpu ] GC(0) User=0.70s Sys=5.13s Real=0.36s
[3.648s][info][gc,start ] GC(1) Pause Young (G1 Evacuation Pause)
[3.648s][info][gc,task ] GC(1) Using 23 workers of 23 for evacuation
[3.699s][info][gc,phases ] GC(1) Pre Evacuate Collection Set: 0.3ms
gc,phases ] GC(1) Evacuate Collection Set: 45.6ms
gc,phases ] GC(1) Post Evacuate Collection Set: 3.4ms
gc,phases ] GC(1) Other: 1.7ms
gc,heap ] GC(1) Eden regions: 9->0(10)
[3.699s][info][gc,heap ] GC(1) Survivor regions: 3->2(2)
[3.699s][info][gc,heap ] GC(1) Old regions: 2->5
[3.700s][info][gc,heap ] GC(1) Humongous regions: 1->1
[3.700s][info][gc,metaspace ] GC(1) Metaspace: 4726K->4726K(1056768K)
[3.700s][info][gc ] GC(1) Pause Young (G1 Evacuation Pause) 14M->7M(256M) 51.872ms
[3.700s][info][gc,cpu ] GC(1) User=0.56s Sys=0.46s Real=0.05s
```

3） 查看GC前后的堆、 方法区可用容量变化， 在JDK 9之前使用-XX： +PrintHeapAtGC， JDK 9之后使用-Xlog： gc+heap=debug：  

```java
bash-3.2$ java -Xlog:gc+heap=debug GCTest
[0.113s][info][gc,heap] Heap region size: 1M
[0.113s][debug][gc,heap] Minimum heap 8388608 Initial heap 268435456 Maximum heap 4261412864
[2.529s][debug][gc,heap] GC(0) Heap before GC invocations=0 (full 0):
[2.529s][debug][gc,heap] GC(0) garbage-first heap total 262144K, used 26624K [0xfffffffe50400000, 0xfffffffe5050
0xffffffff4e400000)
[2.529s][debug][gc,heap] GC(0) region size 1024K, 24 young (24576K), 0 survivors (0K)
[2.530s][debug][gc,heap] GC(0) Metaspace used 4719K, capacity 4844K, committed 5120K, reserved 1056768K
[2.530s][debug][gc,heap] GC(0) class space used 413K, capacity 464K, committed 512K, reserved 1048576K
[2.892s][info ][gc,heap] GC(0) Eden regions: 24->0(9)
[2.892s][info ][gc,heap] GC(0) Survivor regions: 0->3(3)
[2.892s][info ][gc,heap] GC(0) Old regions: 0->2
[2.892s][info ][gc,heap] GC(0) Humongous regions: 2->1
[2.893s][debug][gc,heap] GC(0) Heap after GC invocations=1 (full 0):
[2.893s][debug][gc,heap] GC(0) garbage-first heap total 262144K, used 5850K [0xfffffffe50400000, 0xfffffffe50500
[2.893s][debug][gc,heap] GC(0) region size 1024K, 3 young (3072K), 3 survivors (3072K)
[2.893s][debug][gc,heap] GC(0) Metaspace used 4719K, capacity 4844K, committed 5120K, reserved 1056768K
[2.893s][debug][gc,heap] GC(0) class space used 413K, capacity 464K, committed 512K, reserved 1048576
```

4） 查看GC过程中用户线程并发时间以及停顿的时间， 在JDK 9之前使用-XX： +PrintGCApplicationConcurrentTime以及-XX：+PrintGCApplicationStoppedTime， JDK 9之后使用-Xlog：safepoint：  

```java
bash-3.2$ java -Xlog:safepoint GCTest
[1.376s][info][safepoint] Application time: 0.3091519 seconds
[1.377s][info][safepoint] Total time for which application threads were stopped: 0.0004600 seconds, Stopping thr
0.0002648 seconds
[2.386s][info][safepoint] Application time: 1.0091637 seconds
[2.387s][info][safepoint] Total time for which application threads were stopped: 0.0005217 seconds, Stopping thr
0.0002297 seconds
```

5） 查看收集器Ergonomics机制（ 自动设置堆空间各分代区域大小、 收集目标等内容， 从Parallel收集器开始支持） 自动调节的相关信息。 在JDK 9之前使用-XX： +PrintAdaptive-SizePolicy， JDK 9之后使用-Xlog： gc+ergo*=trace：  

```java
bash-3.2$ java -Xlog:gc+ergo*=trace GCTest [0.122s][debug][gc,ergo,refine] Initial Refinement Zones: green: 23,
69, red: 115, min yellow size: 46
[0.142s][debug][gc,ergo,heap ] Expand the heap. requested expansion amount:268435456B expansion amount:268435456
[2.475s][trace][gc,ergo,cset ] GC(0) Start choosing CSet. pending cards: 0 predicted base time: 10.00ms remainin
190.00ms target pause time: 200.00ms
[2.476s][trace][gc,ergo,cset ] GC(0) Add young regions to CSet. eden: 24 regions, survivors: 0 regions, predicte
region time: 367.19ms, target pause time: 200.00ms
[2.476s][debug][gc,ergo,cset ] GC(0) Finish choosing CSet. old: 0 regions, predicted old region time: 0.00ms, ti
remaining: 0.00
[2.826s][debug][gc,ergo ] GC(0) Running G1 Clear Card Table Task using 1 workers for 1 units of work for 24 regi
[2.827s][debug][gc,ergo ] GC(0) Running G1 Free Collection Set using 1 workers for collection set length 24
[2.828s][trace][gc,ergo,refine] GC(0) Updating Refinement Zones: update_rs time: 0.004ms, update_rs buffers: 0,
goal time: 19.999ms
```

6） 查看熬过收集后剩余对象的年龄分布信息， 在JDK 9前使用-XX： +PrintTenuring-Distribution，JDK 9之后使用-Xlog： gc+age=trace：  

```java
bash-3.2$ java -Xlog:gc+age=trace GCTest
[2.406s][debug][gc,age] GC(0) Desired survivor size 1572864 bytes, new threshold 15 (max threshold 15)
[2.745s][trace][gc,age] GC(0) Age table with threshold 15 (max threshold 15)
[2.745s][trace][gc,age] GC(0) - age 1: 3100640 bytes, 3100640 total
[4.700s][debug][gc,age] GC(5) Desired survivor size 2097152 bytes, new threshold 15 (max threshold 15)
[4.810s][trace][gc,age] GC(5) Age table with threshold 15 (max threshold 15)
[4.810s][trace][gc,age] GC(5) - age 1: 2658280 bytes, 2658280 total
[4.810s][trace][gc,age] GC(5) - age 2: 1527360 bytes, 4185640 total
```

![image-20230321214238875](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321214238875.png)

<img src="../../../../../picbed/store/picbed/img/image-20230321214255264.png" alt="image-20230321214255264" style="zoom:150%;" />

#### 3.垃圾收集器参数总结  

<img src="https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321214354689.png" alt="image-20230321214354689" style="zoom:150%;" />

<img src="https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321214438512.png" alt="image-20230321214438512" style="zoom:150%;" />



## 四、虚拟机性能监控、故障处理工具

给一个系统定位问题的时候， 知识、 经验是关键基础， 数据是依据， 工具是运用知识处理数据的手段。 这里说的数据包括但不限于异常堆栈、 虚拟机运行日志、 垃圾收集器日志、 线程快照（threaddump/javacore文件） 、 堆转储快照（heapdump/hprof文件） 等。  

### 1.基础故障处理工具

根据软件可用性和授权的不同， 可以把它们划分成三类：  

- 商业授权工具： 主要是JMC（Java Mission Control） 及它要使用到的JFR（Java Flight Recorder） ， JMC这个原本来自于JRockit的运维监控套件从JDK 7 Update 40开始就被集成到OracleJDK中， JDK 11之前都无须独立下载， 但是在商业环境中使用它则是要付费的 。
- 正式支持工具： 这一类工具属于被长期支持的工具， 不同平台、 不同版本的JDK之间， 这类工具可能会略有差异， 但是不会出现某一个工具突然消失的情况。
- 实验性工具： 这一类工具在它们的使用说明中被声明为“没有技术支持， 并且是实验性质的”（Unsupported and Experimental） 产品， 日后可能会转正， 也可能会在某个JDK版本中无声无息地消失。 但事实上它们通常都非常稳定而且功能强大， 也能在处理应用程序性能问题、 定位故障时发挥很大的作用。  

#### 1.jps：虚拟机进程状况工具

jps（ JVM Process Status Tool），功能也和ps命令类似： 可以列出正在运行的虚拟机进程， 并显示虚拟机执行主类（ Main Class， main()函数所在的类） 名称以及这些进程的本地虚拟机唯一ID（ LVMID， Local Virtual Machine Identifier） 。 虽然功能比较单一， 但它绝对是使用频率最高的JDK命令行工具， 因为其他的JDK工具大多需要输入它查询到的LVMID来确定要监控的是哪一个虚拟机进程。 对于本地虚拟机进程来说， LVMID与操作系统的进程ID（ PID， Process Identifier） 是一致的， 使用Windows的任务管理器或者UNIX的ps命令也可以查询到虚拟机进程的LVMID， 但如果同时启动了多个虚拟机进程， 无法根据进程名称定位时， 那就必须依赖jps命令显示主类的功能才能区分了。  

```java
jps [ options ] [ hostid ]
```

```java
jps -l
2388 D:\Develop\glassfish\bin\..\modules\admin-cli.jar
2764 com.sun.enterprise.glassfish.bootstrap.ASMain
3788 sun.tools.jps.Jps
```

jps还可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态， 参数hostid为RMI注册表中注册的主机名。  

![image-20230321215416777](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321215416777.png)



#### 2.jstat：虚拟机统计信息监视工具

jstat（ JVM Statistics Monitoring Tool） 是用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程虚拟机进程中的类加载、 内存、 垃圾收集、 即时编译等运行时数据， 在没有GUI图形界面、 只提供了纯文本控制台环境的服务器上， 它将是运行期定位虚拟机性能问题的常用工具。  

```
jstat [ option vmid [interval[s|ms] [count]] ]
```

对于命令格式中的VMID与LVMID需要特别说明一下： 如果是本地虚拟机进程， VMID与LVMID是一致的； 如果是远程虚拟机进程， 那VMID的格式应当是：

```
[protocol:][//]lvmid[@hostname[:port]/servername]
```

参数interval和count代表查询间隔和次数， 如果省略这2个参数， 说明只查询一次。 假设需要每250毫秒查询一次进程2764垃圾收集状况， 一共查询20次， 那命令应当是：  

```java
jstat -gc 2764 250 20
```

选项option代表用户希望查询的虚拟机信息， 主要分为三类： 类加载、 垃圾收集、 运行期编译状况。   

![image-20230321215602564](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321215602564.png)



jstat执行样例 ：

![image-20230321215629502](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321215629502.png)

这台服务器的新生代Eden区（E， 表示Eden） 使用了6.2%的空间， 2个Survivor区（S0、 S1， 表示Survivor0、 Survivor1） 里面都是空的， 老年代（O， 表示Old） 和永久代（P， 表示Permanent） 则分别使用了41.42%和47.20%的空间。 程序运行以来共发生Minor GC（YGC， 表示YoungGC） 16次， 总耗时0.105秒； 发生Full GC（FGC， 表示Full GC） 3次， 总耗时（FGCT， 表示Full GC Time） 为0.472秒； 所有GC总耗时（GCT， 表示GC Time） 为0.577秒。  



#### 3.jinfo：Java配置信息工具  

jinfo（ Configuration Info for Java） 的作用是实时查看和调整虚拟机各项参数。使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表， 但如果想知道未被显式指定的参数的系统默认值，只能使用jinfo的-flag选项进行查询了（ 如果只限于JDK 6或以上版本的话，使用javaXX： +PrintFlagsFinal查看参数默认值也是一个很好的选择） 。  

jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来。   

```
jinfo [ option ] pid
```

执行样例： 查询CMSInitiatingOccupancyFraction参数值  

```java
jinfo -flag CMSInitiatingOccupancyFraction 1444
-XX:CMSInitiatingOccupancyFraction=85
```



#### 4.jmap：Java内存映像工具

jmap（ Memory Map for Java） 命令用于生成堆转储快照（ 一般称为heapdump或dump文件） 。   

-XX： +HeapDumpOnOutOfMemoryError参数， 可以让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件， 通过-XX： +HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成堆转储快照文件， 又或者在Linux系统下通过Kill-3命令发送进程退出信号“恐吓”一下虚拟机， 也能顺利拿到堆转储快照。  

jmap的作用并不仅仅是为了获取堆转储快照， 它还可以查询finalize执行队列、 Java堆和方法区的详细信息， 如空间使用率、 当前用的是哪种收集器等。

jmap有部分功能在Windows平台下是受限的， 除了生成堆转储快照的-dump选项和用于查看每个类的实例、 空间占用统计的-histo选项在所有操作系统中都可以使用之外， 其余选项都只能在Linux/Solaris中使用。  

```
jmap [ option ] vmid
```

![image-20230321220106138](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321220106138.png)

使用jmap生成dump文件 ：

```java
jmap -dump:format=b,file=eclipse.bin 3500
Dumping heap to C:\Users\IcyFenix\eclipse.bin ...
Heap dump file created
```



#### 5.jhat：虚拟机堆转储快照分析工具

jhat（ JVM Heap Analysis Tool） 命令与jmap搭配使用， 来分析jmap生成的堆转储快照。  

多数人是不会直接使用jhat命令来分析堆转储快照文件的， 主要原因有两个方面。 一是一般不会在部署应用程序的服务器上直接分析堆转储快照， 即使可以这样做， 也会尽量将堆转储快照文件复制到其他机器[1]上进行分析， 因为分析工作是一个耗时而且极为耗费硬件资源的过程， 既然都要在其他机器上进行， 就没有必要再受命令行工具的限制了。 另外一个原因是jhat的分析功能相对来说比较简陋， 后文将会介绍到的VisualVM， 以及专业用于分析堆转储快照文件的Eclipse Memory Analyzer、 IBM HeapAnalyzer[等工具， 都能实现比jhat更强大专业的分析功能。   



#### 6.jstack：Java堆栈跟踪工具

jstack（ Stack Trace for Java） 命令用于生成虚拟机当前时刻的线程快照（ 一般称为threaddump或者javacore文件） 。 线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合， 生成线程快照的目的通常是定位线程出现长时间停顿的原因， 如线程间死锁、 死循环、 请求外部资源导致的长时间挂起等， 都是导致线程长时间停顿的常见原因。 线程出现停顿时通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做些什么事情， 或者等待着什么资源。  

```
jstack [ option ] vmid
```

![image-20230321220318361](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321220318361.png)

使用jstack查看线程堆栈（ 部分结果） ：

![image-20230321220348443](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321220348443.png)

从JDK 5起， java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。 使用这个方法可以通过简单的几行代码完成jstack的大部分功能， 在实际项目中不妨调用这个方法做个管理员页面， 可以随时使用浏览器来查看线程堆栈。

![image-20230321220453425](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230321220453425.png)

#### 7.基础工具总结

参考JVM书籍。

### 2.可视化故障处理工具  

主要包括JConsole、JHSDB、 VisualVM和JMC四个。   

#### 1.





## 实战

### 1.Java堆溢出

### 2.虚拟机栈和本地方法栈溢出

### 3.方法区和运行时常量池溢出

### 4.本机直接内存溢出

### 5.对象优先在Eden分配

### 6.大对象直接进入老年代

### 7.长期存活对象进入老年代

### 8.动态对象年龄判定

### 9.空间分配担保