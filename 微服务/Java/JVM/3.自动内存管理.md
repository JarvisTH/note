## 一、运行时数据区域

### 1.程序计数器

程序计数器（Program Counter Register） 是一块较小的内存空间， 它可以看作是当前线程所执行的字节码的行号指示器。  字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令， 它是程序控制流的指示器， 分支、 循环、 跳转、 异常处理、 线程恢复等基础功能都需要依赖这个计数器来完成。  

由于Java虚拟机的多线程是通过线程轮流切换、 分配处理器执行时间的方式来实现的， 在任何一个确定的时刻， 一个处理器（对于多核处理器来说是一个内核） 都只会执行一条线程中的指令。 因此， 为了线程切换后能恢复到正确的执行位置， 每条线程都需要有一个独立的程序计数器， 各条线程之间计数器互不影响， 独立存储， 我们称这类内存区域为“**线程私有**”的内存。  

如果线程正在执行的是一个Java方法， 这个计数器记录的是正在执行的虚拟机字节码指令的地址； 如果正在执行的是本地（Native） 方法， 这个计数器值则应为空（Undefined） 。 此内存区域是唯一一个在《Java虚拟机规范》 中没有规定任何OutOfMemoryError情况的区域。  

### 2.Java虚拟机栈

Java虚拟机栈（Java Virtual Machine Stack） 也是**线程私有**的， 它的生命周期与线程相同。  

虚拟机栈描述的是Java方法执行的线程内存模型： 每个方法被执行的时候， Java虚拟机都会同步创建一个栈帧（Stack Frame） 用于存储局部变量表、 操作数栈、 动态连接、 方法出口等信息。 每一个方法被调用直至执行完毕的过程， 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。  

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、 byte、 char、 short、 int、float、 long、 double） 、 对象引用（reference类型， 它并不等同于对象本身， 可能是一个指向对象起始地址的引用指针， 也可能是指向一个代表对象的句柄或者其他与此对象相关的位置） 和returnAddress类型（指向了一条字节码指令的地址） 。  

这些数据类型在局部变量表中的存储空间以局部变量槽（Slot） 来表示， 其中64位长度的long和double类型的数据会占用两个变量槽， 其余的数据类型只占用一个。 局部变量表所需的内存空间在编译期间完成分配， 当进入一个方法时， 这个方法需要在栈帧中分配多大的局部变量空间是完全确定的， 在方法运行期间不会改变局部变量表的大小（变量槽的数量）。   

对这个内存区域规定了两类异常状况：

-  如果线程请求的栈深度大于虚拟机所允许的深度， 将抛出**StackOverflowError异常**； 
- 如果Java虚拟机栈容量可以动态扩展， 当栈扩展时无法申请到足够的内存会抛出**OutOfMemoryError异常**。（HotSpot虚拟机的栈容量是不可以动态扩展的， 以前的Classic虚拟机倒是可以。 所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不会有OOM， 但是如果申请时就失败， 仍然是会出现OOM异常的。）  

### 3.本地方法栈

本地方法栈是为虚拟机使用到的本地（Native）方法服务。  与虚拟机栈一样， 本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出**StackOverflowError和OutOfMemoryError异常**。  

### 4.**Java堆**

Java堆是被**所有线程共享**的一块内存区域， 在虚拟机**启动时创建**。  此内存区域的唯一目的就是存放对象实例， Java世界里“几乎”所有的对象实例都在这里分配内存。   

Java堆是垃圾收集器管理的内存区域，也被称作“GC堆”。

如果从分配内存的角度看， 所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer， TLAB）， 以提升对象分配时的效率。   将Java堆细分的目的只是为了更好地回收内存， 或者更快地分配内存。  

Java堆可以处于物理上不连续的内存空间中， 但在逻辑上它应该被视为连续的。

Java堆既可以被实现成固定大小的， 也可以是可扩展的， 不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定） 。 如果在Java堆中没有内存完成实例分配， 并且堆也无法再扩展时， Java虚拟机将会抛出**OutOfMemoryError异常**。  

### 5.方法区

方法区（Method Area） 是各个**线程共享**的内存区域， 它用于存储已被虚拟机加载的类型信息、 常量、 静态变量、 即时编译器编译后的代码缓存等数据。   

在JDK 8以前 ，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），到了JDK 7的HotSpot， 已经把原本放在永久代的字符串常量池、 静态变量等移出， 而到了JDK 8， 终于完全废弃了永久代的概念， 改用与JRockit、 J9一样在本地内存中实现的元空间（Metaspace） 来代替， 把JDK 7中永久代还剩余的内容（主要是类型信息） 全部移到元空间中。  

这区域的内存回收目标主要是针对常量池的回收和对类型的卸载， 一般来说这个区域的回收效果比较难令人满意。

 如果方法区无法满足新的内存分配需求时， 将抛出**OutOfMemoryError异常**。  

### 6.运行时常量池

运行时常量池（Runtime Constant Pool） 是方法区的一部分。 Class文件中除了有类的版本、 字段、 方法、 接口等描述信息外， 还有一项信息是常量池表（Constant Pool Table） ， 用于存放编译期生成的各种字面量与符号引用， 这部分内容将在类加载后存放到方法区的运行时常量池中。  

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性， Java语言并不要求常量一定只有编译期才能产生， 也就是说， 并非预置入Class文件中常量池的内容才能进入方法区运行时常量池， 运行期间也可以将新的常量放入池中， 这种特性被开发人员利用得比较多的便是**String类的intern()方法**。  

既然运行时常量池是方法区的一部分， 自然受到方法区内存的限制， 当常量池无法再申请到内存时会抛出**OutOfMemoryError异常**。  

### 7.直接内存

直接内存（Direct Memory） 并**不是虚拟机运行时数据区的一部分**， 也不是《Java虚拟机规范》 中定义的内存区域，也可能导致OutOfMemoryError异常出现 。  

在JDK 1.4中新加入了NIO（New Input/Output） 类， 引入了一种基于通道（Channel） 与缓冲区（Buffer） 的I/O方式， 它可以使用Native函数库直接分配堆外内存， 然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。 这样能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据。  

本机直接内存的分配不会受到Java堆大小的限制， 但是， 既然是内存， 则肯定还是会受到本机总内存（包括物理内存、 SWAP分区或者分页文件） 大小以及处理器寻址空间的限制， 一般服务器管理员配置虚拟机参数时， 会根据实际内存去设置-Xmx等参数信息， 但经常忽略掉直接内存， 使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制） ， 从而导致动态扩展时出现**OutOfMemoryError异常**。  

## 二、hotspot虚拟机中的对象

### 1.对象的创建

当Java虚拟机遇到一条字节码new指令时， 首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用， 并且检查这个符号引用代表的类是否已被加载、 解析和初始化过。 如果没有， 那必须先执行相应的类加载过程。

在类加载检查通过后， 接下来虚拟机将为新生对象分配内存。 对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。   

假设Java堆中内存是绝对规整的， 所有被使用过的内存都被放在一边， 空闲的内存被放在另一边， 中间放着一个指针作为分界点的指示器， 那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离， 这种分配方式称为**“指针碰撞”**（Bump The Pointer）。

如果Java堆中的内存并不是规整的， 已被使用的内存和空闲的内存相互交错在一起， 那就没有办法简单地进行指针碰撞了， 虚拟机就必须维护一个列表， 记录上哪些内存块是可用的， 在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录， 这种分配方式称为**“空闲列表”**（Free List） 。   

选择哪种分配方式由Java堆是否规整决定， 而Java堆是否规整又由所采用的垃圾收集器是否带有**空间压缩整理（Compact）** 的能力决定。 因此， 当使用Serial、 ParNew等带压缩整理过程的收集器时， 系统采用的分配算法是指针碰撞， 既简单又高效； 而当使用CMS这种基于清除（Sweep） 算法的收集器时， 理论上[1就只能采用较为复杂的空闲列表来分配内存。  

对象创建在虚拟机中是非常频繁的行为， 即使仅仅修改一个指针所指向的位置， 在并发情况下也并不是线程安全的， 可能出现正在给对象A分配内存， 指针还没来得及修改， 对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：

- 对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；
- 把内存分配的动作按照线程划分在不同的空间之中进行， 即每个线程在Java堆中预先分配一小块内存， 称为本地线程分配缓冲（Thread Local Allocation Buffer， TLAB） ， 哪个线程要分配内存， 就在哪个线程的本地缓冲区中分配， 只有本地缓冲区用完
  了， 分配新的缓存区时才需要同步锁定。 虚拟机是否使用TLAB， 可以通过-XX： +/-UseTLAB参数来设定。  

内存分配完成之后， 虚拟机必须将分配到的内存空间（但不包括对象头） 都初始化为零值， 如果使用了TLAB的话， 这一项工作也可以提前至TLAB分配时顺便进行。 这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用， 使程序能访问到这些字段的数据类型所对应的零值。  

接下来， Java虚拟机还要对对象进行必要的设置 ，主要是设置对象头信息。

在上面工作都完成之后， 从虚拟机的视角来看， 一个新的对象已经产生了。  

从Java程序的视角看来， 对象创建才刚刚开始——构造函数， 即Class文件中的<init>()方法还没有执行， 所有的字段都为默认的零值， 对象需要的其他资源和状态信息也还没有按照预定的意图构造好。   一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定， Java编译器会在遇到new关键字的地方同时生成这两条字节码指令， 但如果直接通过其他方式产生的则不一定如此） ， new指令之后会接着执行<init>()方法， 按照程序员的意愿对对象进行初始化， 这样一个真正可用的对象才算完全被构造出来。  

### 2.对象的内存布局

在HotSpot虚拟机里， 对象在堆内存中的存储布局可以划分为三个部分： 对象头（Header） 、 实例数据（Instance Data） 和对齐填充（Padding） 。  

HotSpot虚拟机对象的**对象头部分包括两类信息**。   第一类是用于存储对象自身的运行时数据， 如哈希码（HashCode） 、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等， 这部分数据的长度在32位和64位的虚拟机（未开启压缩指针） 中分别为32个比特和64个比特， 官方称它为**“Mark Word”**。 对象需要存储的运行时数据很多， 其实已经超出了32、 64位Bitmap结构所能记录的最大限度， 但对象头里的信息是与对象自身定义的数据无关的额外存储成本， 考虑到虚拟机的空间效率， Mark Word被设计成一个有着动态定义的数据结构， 以便在极小的空间内存储尽量多的数据， 根据对象的状态复用自己的存储空间。   

对象头的另外一部分是类型指针， 即对象指向它的类型元数据的指针， Java虚拟机通过这个指针来确定该对象是哪个类的实例。   

接下来实例数据部分是对象真正存储的有效信息， 即我们在程序代码里面所定义的各种类型的字段内容， 无论是从父类继承下来的， 还是在子类中定义的字段都必须记录起来。 这部分的存储顺序会受到虚拟机分配策略参数（-XX： FieldsAllocationStyle参数） 和字段在Java源码中定义顺序的影响。  

HotSpot虚拟机默认的分配顺序为longs/doubles、 ints、 shorts/chars、 bytes/booleans、 oops（Ordinary Object Pointers， OOPs） ， 从以上默认的分配策略中可以看到， 相同宽度的字段总是被分配到一起存放， 在满足这个前提条件的情况下， 在父类中定义的变量会出现在子类之前。 如果HotSpot虚拟机的+XX： CompactFields参数值为true（默认就为true） ， 那子类之中较窄的变量也允许插入父类变量的空隙之中， 以节省出一点点空间。  

对象的第三部分是对齐填充， 这并不是必然存在的， 也没有特别的含义， 它仅仅起着占位符的作用。  HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍， 换句话说就是任何对象的大小都必须是8字节的整数倍。 对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍） ， 因此， 如果对象实例数据部分没有对齐的话， 就需要通过对齐填充来补全。  

### 3.对象的访问定位

主流的访问方式主要有使用句柄和直接指针两种：  

- 使用句柄访问的话， Java堆中将可能会划分出一块内存来作为句柄池， reference中存储的就是对象的句柄地址， 而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

![image-20230320204003118](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230320204003118.png)

- 使用直接指针访问的话， Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息， reference中存储的直接就是对象地址， 如果只是访问对象本身的话， 就不需要多一次间接访问的开销。

![image-20230320204036525](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230320204036525.png)

## 三、垃圾收集器

### 1.对象是否死亡

垃圾收集器在对堆进行回收前， 第一件事情就是要确定这些对象之中哪些还“存活”着， 哪些已经“死去”。

#### 1.引用计数器

在对象中添加一个引用计数器， 每当有一个地方引用它时， 计数器值就加一； 当引用失效时， 计数器值就减一； 任何时刻计数器为零的对象就是不可能再被使用的。   

主流的Java虚拟机里面都没有选用引用计数算法来管理内存， 主要原因是， 这个看似简单的算法有很多例外情况要考虑， 必须要配合大量额外处理才能保证正确地工作， 譬如单纯的引用计数就**很难解决对象之间相互循环引用**的问题 ——对象objA和objB都有字段instance， 赋值令objA.instance=objB及objB.instance=objA， 除此之外， 这两个对象再无任何引用， 实际上这两个对象已经不可能再被访问， 但是它们因为互相引用着对方， 导致它们的引用计数都不为零， 引用计数算法也就无法回收它们。  

#### 2.可达性分析

当前主流的商用程序语言（Java、 C#， 上溯至前面提到的古老的Lisp） 的内存管理子系统， 都是通过**可达性分析（Reachability Analysis） 算法**来判定对象是否存活的。  

基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集， 从这些节点开始， 根据引用关系向下搜索， 搜索过程所走过的路径称为“引用链”（Reference Chain） ， 如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时， 则证明此对象是不可能再被使用的。  

![image-20230320204707507](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230320204707507.png)



在Java技术体系里面， 固定**可作为GC Roots的对象**包括以下几种：  

- 在虚拟机栈（栈帧中的本地变量表） 中引用的对象， 譬如各个线程被调用的方法堆栈中使用到的
  参数、 局部变量、 临时变量等。
- 在方法区中类静态属性引用的对象， 譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象， 譬如字符串常量池（String Table） 里的引用。  
- 在本地方法栈中JNI（即通常所说的Native方法） 引用的对象。
- Java虚拟机内部的引用， 如基本数据类型对应的Class对象， 一些常驻的异常对象（比如NullPointExcepiton、 OutOfMemoryError） 等， 还有系统类加载器。
- 所有被同步锁（synchronized关键字） 持有的对象。
- 反映Java虚拟机内部情况的JMXBean、 JVMTI中注册的回调、 本地代码缓存等。  

根据用户所选用的垃圾收集器以及当前回收的内存区域不同， 还可以有其他对象“临时性”地加入， 共同构成完整GC Roots集合。   譬如后文将会提到的分代收集和局部回收（Partial GC） ， 如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集） ， 必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的） ， 更不是孤立封闭的， 所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用， 这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去， 才能保证可达性分析的正确性。  

#### 3.引用

在JDK 1.2版之前， 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址， 就称该reference数据是代表某块内存、 某个对象的引用。   

JDK 1.2版之后， Java对引用的概念进行了扩充， 将引用分为强引用（Strongly Re-ference） 、 软引用（Soft Reference） 、 弱引用（Weak Reference） 和虚引用（Phantom Reference） 4种， 这4种引用强度依次逐渐减弱。  

- 强引用是最传统的“引用”的定义， 是指在程序代码之中普遍存在的引用赋值， 即类似“Object obj=new Object()”这种引用关系。 无论任何情况下， 只要强引用关系还存在， 垃圾收集器就永远不会回收掉被引用的对象。
- 软引用是用来描述一些还有用， 但非必须的对象。 只被软引用关联着的对象， 在系统将要发生内存溢出异常前， 会把这些对象列进回收范围之中进行第二次回收， 如果这次回收还没有足够的内存，才会抛出内存溢出异常。 在JDK 1.2版之后提供了SoftReference类来实现软引用。
- 弱引用也是用来描述那些非必须对象， 但是它的强度比软引用更弱一些， 被弱引用关联的对象只能生存到下一次垃圾收集发生为止。 当垃圾收集器开始工作， 无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。 在JDK 1.2版之后提供了WeakReference类来实现弱引用。
- 虚引用也称为“幽灵引用”或者“幻影引用”， 它是最弱的一种引用关系。 一个对象是否有虚引用的存在， 完全不会对其生存时间构成影响， 也无法通过虚引用来取得一个对象实例。 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。 在JDK 1.2版之后提供了PhantomReference类来实现虚引用。  

#### 4.是否死亡

即使在可达性分析算法中判定为不可达的对象， 也不是“非死不可”的， 这时候它们暂时还处于“缓刑”阶段， 要真正宣告一个对象死亡， 至少要经历两次标记过程： 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链， 那它将会被第一次标记， 随后进行一次筛选， 筛选的条件是此对象是否有必要执行finalize()方法。 假如对象没有覆盖finalize()方法， 或者finalize()方法已经被虚拟机调用
过， 那么虚拟机将这两种情况都视为“没有必要执行”。  

如果这个对象被判定为确有必要执行finalize()方法， 那么该对象将会被放置在一个名为F-Queue的队列之中， 并在稍后由一条由虚拟机自动建立的、 低调度优先级的Finalizer线程去执行它们的finalize()方法。 这里所说的“执行”是指虚拟机会触发这个方法开始运行， 但并不承诺一定会等待它运行结束。  

这样做的原因是， 如果某个对象的finalize()方法执行缓慢， 或者更极端地发生了死循环， 将很可能导致F-Queue队列中的其他对象永久处于等待， 甚至导致整个内存回收子系统的崩溃。 finalize()方法是对象逃脱死亡命运的最后一次机会， 稍后收集器将对F-Queue中的对象进行第二次小规模的标记， 如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可， 譬如把自己（this关键字） 赋值给某个类变量或者对象的成员变量， 那在第二次标记时它将被移出“即将回收”的集合； 如果对象这时候还没有逃脱， 那基本上它就真的要被回收了。   

```java
/**
* 此代码演示了两点：
* 1.对象可以在被GC时自我拯救。
* 2.这种自救的机会只有一次， 因为一个对象的finalize()方法最多只会被系统自动调用一次
* @author zzm
*/
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;
    public void isAlive() {
   		System.out.println("yes, i am still alive :)");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    } 
    
    public static void main(String[] args) throws Throwable {
        SAVE_HOOK = new FinalizeEscapeGC();
        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低， 暂停0.5秒， 以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
        	SAVE_HOOK.isAlive();
        } else {
        	System.out.println("no, i am dead :(");
        } 
        // 下面这段代码与上面的完全相同， 但是这次自救却失败了
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低， 暂停0.5秒， 以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
        	SAVE_HOOK.isAlive();
        } else {
        	System.out.println("no, i am dead :(");
        }
    }
}

finalize method executed!
yes, i am still alive :)
no, i am dead :(
```

任何一个对象的finalize()方法都只会被系统自动调用一次， 如果对象面临下一次回收， 它的finalize()方法不会被再次执行， 因此第二段代码的自救行动失败了。  建议大家尽量避免使用它， 因为它并不能等同于C和C++语言中的析构函数。

#### 5.回收方法区

在Java堆中， 尤其是在新生代中， 对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间， 相比之下， 方法区回收囿于苛刻的判定条件， 其区域垃圾收集的回收成果往往远低于此。  

方法区的垃圾收集主要回收两部分内容： 废弃的常量和不再使用的类型。   

判定一个常量是否“废弃”还是相对简单， 而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。 需要同时满足下面三个条件：

- 该类所有的实例都已经被回收， 也就是Java堆中不存在该类及其任何派生子类的实例。
- 加载该类的类加载器已经被回收， 这个条件除非是经过精心设计的可替换类加载器的场景， 如OSGi、 JSP的重加载等， 否则通常是很难达成的。
- 该类对应的java.lang.Class对象没有在任何地方被引用， 无法在任何地方通过反射访问该类的方
  法。  

Java虚拟机被允许对满足上述三个条件的无用类进行回收， 这里说的仅仅是“**被允许**”， 而并不是和对象一样， 没有引用了就必然会回收。 关于是否要对类型进行回收， HotSpot虚拟机提供了-Xnoclassgc参数进行控制， 还可以使用-verbose： class以及-XX： +TraceClass-Loading、 -XX：+TraceClassUnLoading查看类加载和卸载信息， 其中-verbose： class和-XX： +TraceClassLoading可以在Product版的虚拟机中使用， -XX： +TraceClassUnLoading参数需要FastDebug版[1]的虚拟机支持。  

在大量使用反射、 动态代理、 CGLib等字节码框架， 动态生成JSP以及OSGi这类频繁自定义类加载器的场景中， 通常都需要Java虚拟机具备类型卸载的能力， 以保证不会对方法区造成过大的内存压力。

### 2.垃圾收集算法

从如何判定对象消亡的角度出发， 垃圾收集算法可以划分为“引用计数式垃圾收集”（ReferenceCounting GC） 和“追踪式垃圾收集”（Tracing GC） 两大类， 这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。  

#### 1.分代收集理论

建立在两个分代假说之上：  

- 弱分代假说（Weak Generational Hypothesis） ： 绝大多数对象都是朝生夕灭的。
- 强分代假说（Strong Generational Hypothesis） ： 熬过越多次垃圾收集过程的对象就越难以消亡  。

收集器应该将Java堆划分出不同的区域， 然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数） 分配到不同的区域之中存储。如果一个区域中大多数对象都是朝生夕灭， 难以熬过垃圾收集过程的话， 那么把它们集中放在一起， 每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象， 就能以较低代价回收到大量的空间； 如果剩下的都是难以消亡的对象， 那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域， 这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。  

在Java堆划分出不同的区域之后， 垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分 。

一般至少会把Java堆划分为新生代（Young Generation） 和老年代（Old Generation） 两个区域。 顾名思义， 在新生代中， 每次垃圾收集时都发现有大批对象死去， 而每次回收后存活的少量对象， 将会逐步晋升到老年代中存放。  

假如要现在进行一次只局限于新生代区域内的收集（Minor GC） ， 但新生代中的对象是完全有可能被老年代所引用的， 为了找出该区域中的存活对象， 不得不在固定的GC Roots之外， 再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性， 反过来也是一样[3]。 遍历整个老年代所有对象的方案虽然理论上可行， 但无疑会为内存回收带来很大的性能负担。 为了解决这个问题， 就需要对分代收集理论添加第三条经验法则：  

- 跨代引用假说（ Intergenerational Reference Hypothesis） ： 跨代引用相对于同代引用来说仅占极少数。

根据前两条假说逻辑推理得出的隐含推论： 存在互相引用关系的两个对象， 是应该倾向于同时生存或者同时消亡的。   

依据这条假说， 我们就不应再为了少量的跨代引用去扫描整个老年代， 也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用， 只需在新生代上建立一个全局的数据结构（ 该结构被称为“记忆集”， Remembered Set） ， 这个结构把老年代划分成若干小块， 标识出老年代的哪一块内存会存在跨代引用。 此后当发生Minor GC时， 只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。 虽然这种方法需要在对象改变引用关系（ 如将自己或者某个属性赋值） 时维护记录数据的正确性， 会增加一些运行时的开销， 但比起收集时扫描整个老年代来说仍然是划算的。  

**部分收集（ Partial GC）** ： 指目标不是完整收集整个Java堆的垃圾收集， 其中又分为 ：

- 新生代收集（ Minor GC/Young GC） ： 指目标只是新生代的垃圾收集。
- 老年代收集（ Major GC/Old GC） ： 指目标只是老年代的垃圾收集。 目前只有CMS收集器会有单独收集老年代的行为。 另外请注意“Major GC”这个说法现在有点混淆， 在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。
- 混合收集（ Mixed GC） ： 指目标是收集整个新生代以及部分老年代的垃圾收集。 目前只有G1收集器会有这种行为。  

**整堆收集（ Full GC）** ： 收集整个Java堆和方法区的垃圾收集。  

#### 2.标记-清除算法

算法分为“标记”和“清除”两个阶段： 首先标记出所有需要回收的对象， 在标记完成后， 统一回收掉所有被标记的对象， 也可以反过来， 标记存活的对象， 统一回收所有未被标记的对象。 标记过程就是对象是否属于垃圾的判定过程。

后续的收集算法大多都是以标记-清除算法为基础， 对其缺点进行改进而得到的。 它的主要缺点有两个：

-  第一个是**执行效率不稳定**， 如果Java堆中包含大量对象， 而且其中大部分是需要被回收的， 这时必须进行大量标记和清除的动作， 导致标记和清除两个过程的执行效率都随对象数量增长而降低；
- 第二个是**内存空间的碎片化问题**， 标记、 清除之后会产生大量不连续的内存碎片， 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。   

#### 3.标记-复制算法

为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，提出了一种称为“半区复制”（Semispace Copying） 的垃圾收集算法， 它将可用内存按容量划分为大小相等的两块， 每次只使用其中的一块。 当这一块的内存用完了， 就将还存活着的对象复制到另外一块上面， 然后再把已使用过的内存空间一次清理掉。 如果内存中多数对象都是存活的， 这种算法将会产生大量的内存间复制的开销， 但对于多数对象都是可回收的情况， 算法需要复制的就是占少数的存活对象， 而且每次都是针对整个半区进行内存回收， 分配内存时也就不用考虑有空间碎片的复杂情况， 只要移动堆顶指针， 按顺序分配即可。 这样实现简单， 运行高效， 不过其缺陷也显而易见， 这种复制回收算法的代价是将可用内存缩小为了原来的一半， 空间浪费较多。

![image-20230320211015467](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230320211015467.png)

现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，新生代中的对象有98%熬不过第一轮收集。 并不需要按照1∶ 1的比例来划分新生代的内存空间。  一种更优化的半区复制分代策略， 现在称为**“Appel式回收”**。 HotSpot虚拟机的Serial、 ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间， 每次分配内存只使用Eden和其中一块Survivor。 发生垃圾搜集时， 将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上， 然后直接清理掉Eden和已用过的那块Survivor空间。 HotSpot虚拟机默认Eden和Survivor的大小比例是8∶ 1， 也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%） ， 只有一个Survivor空间， 即10%的新生代是会被“浪费”的。  

Appel式回收还有一个充当罕见情况的“逃生门”的安全设计， 当Survivor空间不足以容纳一次Minor GC之后存活的对象时， 就需要依赖其他内存区域（实际上大多就是老年代） 进行**分配担保（Handle Promotion）** 。  

内存的分配担保好比我们去银行借款， 如果我们信誉很好， 在98%的情况下都能按时偿还， 于是银行可能会默认我们下一次也能按时按量地偿还贷款， 只需要有一个担保人能保证如果我不能还款时， 可以从他的账户扣钱， 那银行就认为没有什么风险了。 内存的分配担保也一样， 如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象， 这些对象便将通过分配担保机制直接进入老年代， 这对虚拟机来说就是安全的。   

#### 4.标记-整理算法（Mark-Compact）

标记-复制算法在对象存活率较高时就要进行较多的复制操作， 效率将会降低。 更关键的是， 如果不想浪费50%的空间， 就需要有额外的空间进行分配担保， 以应对被使用的内存中所有对象都100%存活的极端情况， 所以在老年代一般不能直接选用这种算法。  

标记过程仍然与“标记-清除”算法一样， 但后续步骤不是直接对可回收对象进行清理， 而是让所有存活的对象都向内存空间一端移动， 然后直接清理掉边界以外的内存。标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法， 而后者是移动
式的。 是否移动回收后的存活对象是一项优缺点并存的风险决策：  

![image-20230320211500367](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230320211500367.png)

如果移动存活对象， 尤其是在老年代这种每次回收都有大量对象存活区域， 移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作， 而且这种对象移动操作必须**全程暂停用户应用程序**才能进行， 这就更加让使用者不得不小心翼翼地权衡其弊端了， 像这样的停顿被最初的虚拟机设计者形象地描述为**“Stop The World”**。  

如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话， 弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。  内存的访问是用户程序最频繁的操作， 假如在这个环节上增加了额外的负担， 势必会直接影响应用程序的吞吐量。  

基于以上两点， 是否移动对象都存在弊端， 移动则内存回收时会更复杂， 不移动则内存分配时会更复杂。 从垃圾收集的停顿时间来看， 不移动对象停顿时间会更短， 甚至可以不需要停顿， 但是从整个程序的吞吐量来看， 移动对象会更划算。   

HotSpot虚拟机里面关注吞吐量的**Parallel Scavenge收集器是基于标记-整理算法的**， 而**关注延迟的CMS收集器则是基于标记-清除算法**的 。还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担， 做法是让虚拟机平时多数时间都采用标记-清除算法， 暂时容忍内存碎片的存在， 直到内存空间的碎片化程度已经大到影响对象分配时， 再采用标记-整理算法收集一次， 以获得规整的内存空间。 前面提到的**基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法**。  

### 3.Hotspot算法实现细节

#### 1.根节点枚举

固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性） 与执行上下文（例如栈帧中的本地变量表） 中 。所有收集器在根节点枚举这一步骤时都是**必须暂停用户线程**的， 因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。  

现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发， 但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行——这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上， 不会出现分析过程中， 根节点集合的对象引用关系还在不断变化的情况， 若这点不能满足的话， 分析结果准确性也就无法保证。 这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因， 即使是号称停顿时间可控， 或者（几乎） 不会发生停顿的CMS、 G1、ZGC等收集器， **枚举根节点时也是必须要停顿的。**  

主流Java虚拟机使用的都是准确式垃圾收集 ，当用户线程停顿下来之后， 其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置， 虚拟机应当是有办法直接得到哪些地方存放着对象引用的。 在HotSpot的解决方案里， 是使用一组称为OopMap的数据结构来达到这个目的。 一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来， 在即时编译过程中， 也会在**特定的位置记录**下栈里和寄存器里哪些位置是引用。 这样收集器在扫描时就可以直接得知这些信息了， 并不需要真正一个不漏地从方法区等GC Roots开始查找。  

#### 2.安全点

可能导致引用关系变化， 或者说导致OopMap内容变化的指令非常多， 如果为每一条指令都生成对应的OopMap， 那将会需要大量的额外存储空间， 这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。  

只是在“特定的位置”记录了这些信息， 这些位置被称为**安全点（Safepoint）** 。 有了安全点的设定， 也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集， 而是强制要求必须执行到达安全点后才能够暂停。   

安全点的选定既不能太少以至于让收集器等待时间过长， 也不能太过频繁以至于过分增大运行时的内存负荷。 安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的， 因为每条指令执行的时间都非常短暂， 程序不太可能因为指令流长度太长这样的原因而长时间执行， “长时间执行”的最明显特征就是指令序列的复用， 例如方法调用、 循环跳转、 异常跳转等都属于指令序列复用， 所以只有具有这些功能的指令才会产生安全点。  

如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程） 都跑到最近的安全点， 然后停顿下来。 这里有两种方案可供选择： 抢先式中断（Preemptive Suspension） 和主动式中断（Voluntary Suspension）：

- 抢先式中断不需要线程的执行代码主动去配合， 在垃圾收集发生时， 系统首先把所有用户线程全部中断， 如果发现有用户线程中断的地方不在安全点上， 就恢复这条线程执行， 让它一会再重新中断， 直到跑到安全点上。 现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。  
- 主动式中断的思想是当垃圾收集需要中断线程的时候， 不直接对线程操作， 仅仅简单地设置一个标志位， 各个线程执行过程时会不停地主动去轮询这个标志， 一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。 轮询标志的地方和安全点是重合的， 另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方， 这是为了检查是否即将要发生垃圾收集， 避免没有足够内存分配新对象。  

#### 3.安全区域

程序“不执行”的时候呢？ 所谓的程序不执行就是没有分配处理器时间， 典型的场景便是用户线程处于Sleep状态或者Blocked状态， 这时候线程无法响应虚拟机的中断请求， 不能再走到安全的地方去中断挂起自己， 虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。 对于这种情况， 就必须引入安全区域（Safe Region） 来解决。  

安全区域是指能够确保在某一段代码片段之中， 引用关系不会发生变化， 因此， 在这个区域中任意地方开始垃圾收集都是安全的。   

当用户线程执行到安全区域里面的代码时， 首先会标识自己已经进入了安全区域， 那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。 当线程要离开安全区域时， 它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段） ， 如果完成了， 那线程就当作没事发生过， 继续执行； 否则它就必须一直等待， 直到收到可以离开安全区域的信号为止。  

#### 4.记忆集与卡表

为解决对象跨代引用所带来的问题， 垃圾收集器在新生代中建立了名为记忆集（Remembered Set） 的数据结构， 用以避免把整个老年代加进GC Roots扫描范围。 事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集（Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。  



## 实战

### 1.Java堆溢出

### 2.虚拟机栈和本地方法栈溢出

### 3.方法区和运行时常量池溢出

### 4.本机直接内存溢出