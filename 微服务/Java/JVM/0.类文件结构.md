各种不同平台的Java虚拟机， 以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石。

实现语言无关性的基础仍然是虚拟机和字节码存储格式。   

ava虚拟机不与包括Java语言在内的任何程序语言绑定， 它只与“Class文件”这种特定的二进制文件格式所关联， Class文件中包含了Java虚拟机指令集、 符号表以及若干其他辅助信息。  

## 一.Class类文件的结构  

Class文件是一组以8个字节为基础单位的二进制流， 各个数据项目严格按照顺序紧凑地排列在文件之中， 中间没有添加任何分隔符， 这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据， 没有空隙存在。 当遇到需要占用8个字节以上空间的数据项时， 则会按照高位在前的方式分割成若干个8个字节进行存储。  

Class文件格式采用一种类似于C语言结构体的伪结构来存储数据， 这种伪结构中只有两种数据类型： “无符号数”和“表”：

-  无符号数属于基本的数据类型， 以u1、 u2、 u4、 u8来分别代表1个字节、 2个字节、 4个字节和8个
  字节的无符号数， 无符号数可以用来描述数字、 索引引用、 数量值或者按照UTF-8编码构成字符串
  值 。
- 表是由多个无符号数或者其他表作为数据项构成的复合数据类型， 为了便于区分， 所有表的命名都习惯性地以“_info”结尾。 表用于描述有层次关系的复合结构的数据， 整个Class文件本质上也可以视作是一张表 ，所示的数据项按严格顺序排列构成  ：

![image-20230318103424757](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230318103424757.png)

无论是无符号数还是表， 当需要描述同一类型但数量不定的多个数据时， 经常会使用一个前置的容量计数器加若干个连续的数据项的形式， 这时候称这一系列连续的某一类型的数据为某一类型的“集合 "。 

### 1.魔数与Class文件版本

每个Class文件的头4个字节被称为**魔数（Magic Number） ， 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件**。  使用魔数而不是扩展名来进行识别主要是基于安全考虑， 因为文件扩展名可以随意改动。   

Class文件的魔数—— 0xCAFEBABE  

紧接着魔数的4个字节存储的是Class文件的版本号： 第5和第6个字节是次版本号（MinorVersion） ， 第7和第8个字节是主版本号（Major Version） 。  

高版本的JDK能向下兼容以前版本的Class文件， 但不能运行以后版本的Class文件。

![image-20230318103814759](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230318103814759.png)

### 2.常量池  

紧接着主、 次版本号之后的是常量池入口， 常量池可以比喻为Class文件里的资源仓库， 它是Class文件结构中与其他项目关联最多的数据， 通常也是占用Class文件空间最大的数据项目之一，它还是在Class文件中第一个出现的表类型数据项目。  

由于常量池中常量的数量是不固定的， 所以在常量池的入口需要放置一项u2类型的数据， 代表常量池容量计数值（constant_pool_count） 。   

常量池容量（偏移地址： 0x00000008） 为十六进制数0x0016， 即十进制的22， 这就代表常量池中有21项常量， 索引值范围为1～21。 在Class文件格式规范制定之时， 设计者将第0项常量空出来是有特殊考虑的， 这样做的目的在于， 如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义， 可以把索引值设置为0来表示。 Class文件结构中只有常量池的容量计数是从1开始， 对于其他集合类型， 包括接口索引集合、 字段表集合、 方法表集合等的容量计数都与一般习惯相同， 是从0开始。

![image-20230318104049056](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230318104049056.png)

常量池中主要存放两大类常量： 字面量（Literal） 和符号引用（Symbolic References） 。  

- 字面量接近于Java语言层面的常量概念， 如文本字符串、 被声明为final的常量值等。  
- 符号引用则属于编译原理方面的概念， 主要包括下面几类常量 ：
  - 被模块导出或者开放的包（Package）
  - 类和接口的全限定名（Fully Qualified Name）
  - 字段的名称和描述符（Descriptor）
  - 方法的名称和描述符
  - 方法句柄和方法类型（Method Handle、 Method Type、 Invoke Dynamic）
  - 动态调用点和动态常量（Dynamically-Computed Call Site、 Dynamically-Computed Constant）  

在Class文件中不会保存各个方法、 字段最终在内存中的布局信息，  当虚拟机做类加载时， 将会从常量池获得对应的符号引用， 再在类创建时或运行时解析、 翻译到具体的内存地址之中。   

常量池中每一项常量都是一个表， 最初常量表中共有11种结构各不相同的表结构数据， 后来为了更好地支持动态语言调用， 额外增加了4种动态语言相关的常量 ，为了支持Java模块化系统（Jigsaw） ， 又加入了CONSTANT_Module_info和CONSTANT_Package_info两个常量， 所以截至JDK13， 常量表中分别有17种不同类型的常量。  

这17类表都有一个共同的特点， 表结构起始的第一位是个u1类型的标志位， 代表着当前常量属于哪种常量类型：

![image-20230318104456962](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230318104456962.png)

- CONSTANT_Class_info类型，标志位（偏移地址： 0x0000000A） 是0x07，  代表一个类或者接口的符号引用，结构如下：

![image-20230318104720252](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/image-20230318104720252.png)

tag是标志位， 它用于区分常量类型； name_index是常量池的索引值， 它指向常量池中一个CONSTANT_Utf8_info类型常量， 此常量代表了这个类（或者接口） 的全限定名  

## 二、字节码指令简介

Java虚拟机的指令由一个字节长度的、 代表着某种特定操作含义的数字（称为操作码， Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数， Operand） 构成。  

### 1.字节码与数据类型  

