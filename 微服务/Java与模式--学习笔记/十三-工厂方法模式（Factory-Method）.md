属于创建模式，用意是定义一个创建产品对象的工厂接口，但让实现这个接口的类决定实例化哪个类，实际创建工作推迟到子类中。

适用场景：创建对象需要大量重复代码；客户端（应用层）不依赖于产品类实例如何被创建细节；一个类通过其子类指定创建哪个对象。

优点：用户只关心所需产品对应的工厂，无需关心创建细节；加入新产品符合开闭原则；

缺点：类的个数容易过多，增加复杂度；增加抽象性和理解难度。

在工厂方法模式中，核心工厂类不再负责所有产品创建，而是将具体创建工作交给子类去做。核心类成为抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化的细节。

**一、结构与角色**
![](https://upload-images.jianshu.io/upload_images/9449419-ad3ea751897ec071.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 抽象工厂（Creator）角色：任何在模式中创建对象的工厂类必须实现这个接口。
- 具体工厂（Concrete Creator）角色：实现了抽象工厂接口的具体Java类。
- 抽象产品（Product）角色：工厂方法模式所创建对象的超类型，即产品对象的共同父类或共同拥有的接口。
- 具体产品（Concrete Product）角色：实现了抽象产品角色所声明的接口。
- Client客户端创建工厂对象，并调用工厂对象的工厂方法创建相应产品对象。

Client对象活动：
- 创建ConcreteCreator1对象，持有的静态变量是Creator，而实际类型是ConcreteCreator1，然后调用factory（），接着后者调用ConcreteCreator1的构造子创建产品对象。
- 创建ConcreteCreator2的过程同上。

**二、工厂方法模式与简单工厂模式比较**

1.结构上不同。工厂方法模式核心是一个抽象工厂类，而简单工厂模式把核心放在具体类上。

2.工厂方法模式退化后变得像简单工厂模式。

3.factory()方法返回的数据类型都是一个抽象类型。

如果需要加入一个新的产品，那么需要向系统中加入这个产品类以及它对应的工厂类，不需要修改客户端或抽象工厂角色或其他已有具体工厂角色。对于新增产品而言，完全支持开闭原则。

**三、关于工厂方法模式的实现**

1.使用Java接口或Java抽象类

2.使用多个工厂方法

3.产品的循环使用

4.多态性的丧失与模式退化：

一个工厂方法模式的实现依赖于工厂角色和产品角色的多态性。工厂方法返回抽象类型，这样才能保证对产品的多态性。一些情况下，工厂方法仅返回一个具体产品类型。这时工厂方法模式功能就退化了，表现为针对产品角色的多态性丧失。当抽象工厂角色被省略时，工厂方法模式也发生退化，表现为对工厂角色的多态性丧失。
