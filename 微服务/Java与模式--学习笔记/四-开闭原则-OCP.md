**一、什么是开闭原则**
一个软件实体应当对扩展开放，对修改关闭——即应当可以在不必修改源码的情况下改变模块行为。

满足开闭原则使得系统具有一定的适应性和灵活性，在变化中又具有一定的稳定性和延续性。

**二、怎么做到开闭原则**
解决问题的关键在于抽象化。
在Java语言里，可以给出一个或多个抽象Java类或接口，规定出所有具体类必须提供的方法特征作为系统设计的抽象层。抽象层预见所有的可能扩展，因此在任何情况下都不会改变，使得系统抽象层次不需修改，**从而满足”对修改关闭“。**同时，由于从抽象层导出的一个或多个新的具体类可以改变系统行为，因此系统的设计对扩展开放，**满足”对扩展开放”。**

强调：用抽象构建框架，用实现扩展细节
核心：面向抽象编程

**对可变性的封装原则**
即找到系统的可变因素，将它封装起来。

意味着：

- 一种可变性不应散落在代码很多角落里，而应当被封装到一个对象里。同一可变性的不同表象意味着同一继承等级结构中的具体子类。继承应当被看做是封装变化的方法，而不应当被认为是从一般对象生成特殊对象的方法。
- 一种可变性不应当与另一种可变性混合在一起。


**三、与其他设计原则的关系**
1.里氏替换原则 LSP
LSP说明任何基类可以出现的地方，子类一定可以出现。LSP是对开闭原则的补充，基类与子类的继承关系是抽象化的具体表现。一般违反LSP，也违反OCP，反过来不一定成立。

2.依赖倒转原则  DIP
DIP说明要依赖于抽象，不依赖于实现。针对接口编程，不针对实现编程。DIP是实现OCP的手段。违反DIP，不可能达到OCP的要求。

3.合成/聚合复用原则 CARP
CARP说明要尽量使用合成/聚合，而不是继承关系达到复用目的。违反CARP则无法实现OCP。

4.迪米特法则 LoD
LoD说明一个软件实体应当与尽可能少的其他实体发生相互作用。一个遵守LoD设计的系统在扩展时，会相对更容易做到对修改关闭。

5.接口隔离原则 ISP
ISP说明应当为客户端提供尽可能小的单独接口，而不提供大的总接口。遵守ISP与LoD会使一个系统在功能扩展过程中，不会将修改压力传递到其他对象。

3.单一职责原则
不要存在多于一个导致类变更的原因。一个类/接口/方法只负责一项职责。降低类复杂度，提高类可读性，提高系统可维护性，降低变更引起的风险。

**四、一个重构做法的讨论**
“将条件转移语句改写为多态性”，意思是将一个进行多次条件转移的逻辑封装到不同的具体子类中去，从而使用多态性替代条件转移语句。

1.寻找可变线索
因为条件转移语句往往意味着某种可变性，将这种可变性用多态性代替，就意味着将这种可变性封装起来，从而带来系统在这种变化发生时的开闭特性。**但这一做法并不能保证OCP**，而应当以OCP为指导。这一行为有明显缺陷：

- 任何语言都提供条件转移功能，条件转移本身不是错误。
-  使用多态性代替条件转移意味着大量的类被创建。

2.何时使用这种重构做法
从OCP出发来判断，如果一个条件转移语句确实封装了某种逻辑的可变性，那么将此种可变性封装起来就符合OCP。但如果一个条件转移语句没有涉及重要逻辑或不随时间变化而变化，也不意味任何可扩展性，那么它就没有涉及任何有意义的可变性。
