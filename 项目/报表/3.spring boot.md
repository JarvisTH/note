## 一、配置

### 1.配置文件格式

约定优于配置是spring boot的理念，只需要做很少的配置，就可以允许spring boot。spring boot的配置文件有两种格式：

- application.properties：了解，配置内容过多时，不实用
- application.yml：官网推荐方式

### 2.日志

spring boot默认使用Logback日志系统，默认输出到控制台。：号后一定要有空格。

- 日志级别配置
- 日志输出路径

```yml
logging:
  level:
    root: info // 系统级别
    com.jarvis.report: warn // 包级别
  file:
    name: logs/system.log
```

### 3.JPA

Java持久层API，使得应用程序以统一的方式访问持久层，JPA是一套规范。

spring data jpa是spring 提供的一套简化的开发框架，按照约定的方法命名规则写dao层接口，可以在不写接口实现的情况下，实现数据库的访问和操作，还提供分页、排序等功能。

配置完成实体类entity运行项目，会自动生成对应数据库表。

### 4.多环境配置

主配置文件控制使用哪个子配置文件



### 5.数据库连接池

Druid：阿里巴巴的数据库连接池，性能强大，分析sql性能。依赖于druid-spring-boot-starter。

从1.1.10后，可以不用写过滤类及响应的servlet，完全基于yml也可以运行。

- pom文件中配置jpa、Mysql、druid的jar包依赖
- 配置对应参数



### 6.thymeleaf

网页模板，不能直接访问，只能通过controller调转访问，一般无须在yml中配置，默认就ok：

![image-20220222235142996](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/20220222235152.png)

### 7.resource

一般情况下，不需要在yml中配置，默认：

![image-20220222235319686](https://cdn.jsdelivr.net/gh/JarvisTH/picbed/img/20220222235321.png)

## 二、创建数据仓库层接口Repositry

创建数据仓库类是一个接口，针对这个接口添加注解@Repository。

数据仓库接口作用是居于业务层与数据层之间，在内部封装数据查询和存储逻辑。

Repository与DAO的区别：DAO，Data Access Object，负责数据库的存取工作。Repository相对于对象而言，DAO是相对于数据库而言。

Repository接口：CrudRepositry、PagingAndSortingRepository、JpaRepository、JpaSpecsificationExecutor，从前到后功能逐渐增强。

一般只需要添加注解@Repository和继承JpaRepository类，非必须不需要实现其他方法。注意实现时要对应具体的实体，其中String非固定值。也支持sql语句查询。

```java
@Repository
public interface CompanyRepo extends JpaRepository<Company, String> {

    // 原生sql语句查询
    @Query(value = "select * from company where comname=?1", nativeQuery = true)
    List<Company> findByNativeSQL(String name);

    @Query(value = "select * from company where comname like '%?1%'", nativeQuery = true)
    List<Company> findByNativeSQL1(String name);

    // 涉及数据变动，必须添加@Modifying注解
    @Modifying
    @Query(value = "update company set comaddress = ?1 where conname=?2",nativeQuery = true)
    void updateByName(String comaddress, String name);
}
```



## 三、创建业务层service接口及实现

定义一个接口，实现一个或多个类，面向接口编程，可以拓展可扩展性。

- 接口及实现类命名方式，接口XXXService，实现类XXXServiceImpl
- 实现类XXXServiceImpl需要添加@Service注解，并指明名称，@Service（“companyService”）
- 实现类中，通过@Autowired，注入数据仓库层Repository接口
- 当实现接口涉及数据库数据修改和删除时，方法上需要添加注解@Transactional，否则执行不成功

```
public interface CompanyService {
    // 保存
    void save(Company company);

    // 根据uuid删除
    @Transactional
    void delete(String uuid);

    // 修改
    @Transactional
    void update(Company company);

    // 查询全部数据
    List<Company> findAll();

    // 执行原生SQL语句查询
    List<Company> findByNativeSQL(String company);
}
```

## 四、创建控制层

控制类的作用是处理http请求，从http请求中获取信息，提取参数，分发给不同服务，处理后封装为一个Model，将Model返回给对应View展示。

### 1.控制层注解

- @Controller:创建的类上添加@Controller注解表示控制层类，返回数据方式既可以是JSON/xml数据，也可以是页面模板。
- @RestController：创建的类上添加注解@RestController表示控制层类，只能返回JSON/xml数据。微服务中用的较多，因为不需要返回页面。
- 关系：@Controller + @ResponseBody = @RestController

### 2.业务层注入

- @Resource：默认byName注入方式，适用于接口只能有一个实现类，名称是@Service标注的名称，通过byName方式匹配不到，再按byType方式匹配。@Resource（name=”companySource“）
- @Qualifier：byName注入方式，名称是类名，适用于接口有多个实现类场景，@Qualifier（name=”companyService")
- @Autowired:byType注入方式，要求接口只能有一个实现类，按type方式寻找接口实现类，如果有多个实现类，spring不知道引入哪个

### 3.URL映射

- @RequestMapping：表示将特定URL映射到指定方法
- @GetMapping：只接受Get方式的url，相当于@RequestMapping（value=‘/test/hello’，method=RequestMethod.Get）
- @PostMapping：只接受Post方式的URL。

### 4.参数接收

- JavaBean对象：没有任何注释，直接通过JavaBean对象来封装单表参数或者是请求url路径中的参数，如public void save(Company company)

- @RequestParam：用于获取Request参数，也就是url中的最后一部分，形如：？xxx=yy&&zz=ww

- @PathVariable：获取url变量，一般{}中的变量名与方法中的形成名一致，用于RESTful风格。

- @RequestBody：以String方式接收前端以post方式传过来的json数据，在需要传递大量参数时很有用。适用于多条件查询场景，一般用map集合处理接收的参数，如下：

  ```java
  	@PostMapping("/save")
      @ResponseBody
      public void save(Company company){
          companyService.save(company);
      }
  
      @GetMapping("/delete")
      @ResponseBody
      public void delete(@RequestParam String uuid){
          companyService.delete(uuid);
      }
  
      @PostMapping("/multiQuery")
      @ResponseBody
      public Map<String,Object> multiQuery(@RequestBody(required = false) Map<String,Object> reqMap){
          String a1 = reqMap.get("a1").toString();
          String a2 = reqMap.get("a2").toString();
          String a3 = reqMap.get("a3").toString();
          String a4 = reqMap.get("a4").toString();
          return reqMap;
      }
  ```

### 5.页面跳转

```java
	//    访问页面
    @RequestMapping("/test.html")
    public String showPublicHtml() {
        return "redirect:/test.html";
    }

	@RequestMapping("/templateTest.html")
    public String showTemplateHtml() {
        return "/CompanyHtml/templateTest.html";
    }
```

### 6.RESTful风格

如果不是从资源考虑、对缓存要求不高，不建议采用RESTful风格涉及。不是使用资源进行系统建模和设计，与REST需要的资源第一位观点冲突。

- PostMapping：增
- GetMapping：查
- PutMapping：改
- DeleteMapping：删

必须使用PathVariable注解。

```java
	// REST风格
    @GetMapping("/company/{name}")
    @ResponseBody
    public List<Company> query1(@PathVariable String name){
        System.out.println(name);
        return companyService.findByNativeSQL(name);
    }

	@PutMapping("/company/{addr}/{name}")
    @ResponseBody
    public String query2(@PathVariable String addr, @PathVariable String name) {
        System.out.println(addr);
        System.out.println(name);
        return "addr:" + addr + ",name:" + name;
    }
```



## 五、模板梳理与公共页面抽取

模板的核心文件：模板自身样式、模板的JS脚本。基于Bootstrap的后台模板主要文件：

- Bootstrap样式
- 图标文件样式
- 模板本身样式
- Jquery
- Bootstrap js
- 模板本身JS

最佳引入方式：

- 近把核心文件导入
- CDN加速
- 模板只是参考

PS：复制文件到IDEA后，需要rebuild project。



## 六、ThymeLeaf

语法就近于html。

设置新建文本模板。



## 七、页面列表显示

在templates下创建一个首页：index.html，SpringBoot工程中默认访问的是index.html页面.

基于表格组件Bootstrap Table进行列表展示需要做的工作

- 创建列表页面ListCompany.html。

- 由于Bootstrap Table接收控制层反馈的json数据中，要求必须包含两个属性”rows”、total，所以对查询到的数据集合中要加入这两个属性，再进行数据的反馈。

- 改造Controller中对应的分页方法，以便适应Bootstrap Table对json数据的要求；在控制层中添加跳转到页面ListCompany.html的方法；

- 修改公共导航页面中的链接，修改其中一个链接，该链接指向的是上面控制层访问列表页面的接口。

- 创建列表页面对应的JS文件ListCompany.js



## 八、列表多彩格式化显示

ootstrap-Table组件能够进行丰富多彩的格式化显示，主要包括下面几个方面

- 启用Bootstrap的Table样式；

- 表头的背景色；

- 根据行中列的值动态对整行的文字及背景颜色进行设置；

- 对整列的文本进行格式化显示；

- 对单元格的文本和背景进行格式化显示；

- 灵活的采用Bootstrap的样式和自定义样式进行文本显示

## 九、列表事件





## 十、基于RequireJS模块化管理JS组件

为什么要用RequireJS？

-  随着网站功能逐渐丰富，网页中的js也变得越来越复杂和臃肿；

- 同步加载，阻塞页面；

- 不能很好的处理JS组件之间的依赖关系；

-  如果统一放在公共页面存在一次加载的js组件太多，如果分散管理则版本升级太繁琐

利用RequireJS能够达到的好处：

- 异步加载，不会阻塞页面，AMD规范；

- 按需加载，不需要的模块不加载；

- 依赖管理，能确保在所有的依赖模块都加载以后再执行相关的文件；

- 版本管理，只需改动一处地方，则所有涉及到的页面就都改了；

- 多源准备：同一个js组件，可以配置多个CDN加速、本地文件；

RequireJS配置文件简明知识点

1) paths：数组，配置js的别名和路径。引入js、css时，不要加js、css后缀，会自动加。

2) map：映射js组件的不同版本，用的较少，本项目中主要用这个属性、结合shim属性来管理css；

3) shim：用于解决非AMD标准（AMD标准，异步加载）模块的注入，这里面的deps为数组，表示其依赖的JS库/CSS

4) 引入require-css对JS组件用到的CSS进行管理

基于RequireJS进行如何模块化加载JS及其CSS

​	require.js在加载的时候会检查script的data-main属性，当加载完毕，data-main属性规定的js文件会第一个被require.js加载并执行。

## 十一、表单组件

用到的JS组件

1）layer

2）bootstrap-validator

3）bootstrap3

4）jquery.form

说明：主流的三种验证组件：jquery-validate、bootstrap-validator、formValidator 

- jquery-validate：功能强大，但与bootstrap的扁平化风格不搭；

- bootstrap-validator（推荐）：开源，表单验证神器，基于Bootstrap3

- formValidator：收费，bootstrap-validator开发者推出的收费版本，用法与bootstrap-validator一样。

工作开展步骤：

1）RequireJS配置脚本文件中增加组件的引入

2）创建“增加公司页面”，内容可暂时为空

3）创建“增加公司JS文件”，内容可暂时为空

4）列表页面中添加“增加公司”按钮

5）控制层中增加返回“增加公司页面”的方法

6）列表页面对应的JS脚本中，增加弹出层代码

7）完成“增加公司页面”页面中的表单布局及细化

8）完成“增加公司JS文件”中表单验证、异步提交功能。
